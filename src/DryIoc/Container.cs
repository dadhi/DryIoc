// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2013-2024 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#if !NET45 && !NET451 && !NET452 // todo: @wip try NET452_OR_LESS
#define SUPPORTS_ASYNC_LOCAL
#endif
#if NETSTANDARD2_1 || NET5_0_OR_GREATER
#define SUPPORTS_ASYNC_DISPOSABLE
#endif
#if !NET45 && !NET451 && !NET452 && !NET46 && !NET461 && !NET462 && !NET47 // todo: @wip try NET47_OR_LESS
#define SUPPORTS_EXPRESSION_COMPILE_WITH_PREFER_INTERPRETATION_PARAM
#endif
#if NET7_0_OR_GREATER
#define SUPPORTS_REQUIRED_PROPERTIES
#endif

namespace DryIoc;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;              // for StackTrace
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices; // for MethodImplAttribute
using System.Diagnostics.CodeAnalysis; // for SetsRequiredMembersAttribute
using System.Text;
using System.Threading;

using static System.Environment;
using ExprType = System.Linq.Expressions.ExpressionType;

using ImTools;
using static ImTools.ArrayTools;

using FastExpressionCompiler.LightExpression;
using static FastExpressionCompiler.LightExpression.Expression;
using static FastExpressionCompiler.LightExpression.ExpressionCompiler;

#nullable disable

/// <summary>Inversion of control container</summary>
public partial class Container : IContainer
{
    /// <summary>Creates new container with default rules <see cref="DryIoc.Rules.Default"/>.</summary>
    public Container() : this(Rules.Default, Ref.Of(Registry.Default), NewSingletonScope()) =>
        SetInitialRuntimeFactoryID();

    /// <summary>Creates new container, optionally providing <see cref="Rules"/> to modify default container behavior.</summary>
    /// <param name="rules">(optional) Rules to modify container default resolution behavior.
    /// If not specified, then <see cref="DryIoc.Rules.Default"/> will be used.</param>
    /// <param name="scopeContext">(optional) Scope context to use for scoped reuse.</param>
    public Container(Rules rules = null, IScopeContext scopeContext = null)
        : this(rules ?? Rules.Default, Ref.Of(Registry.Default), NewSingletonScope(), scopeContext) =>
        SetInitialRuntimeFactoryID();

    /// <summary>Creates new container with configured rules.</summary>
    /// <param name="configure">Allows to modify <see cref="DryIoc.Rules.Default"/> rules.</param>
    /// <param name="scopeContext">(optional) Scope context to use for <see cref="Reuse.InCurrentScope"/>.</param>
    public Container(Func<Rules, Rules> configure, IScopeContext scopeContext = null)
        : this(configure.ThrowIfNull()(Rules.Default) ?? Rules.Default, scopeContext)
    { }

    // todo: @perf: consider to optimize the scope for the memory with a special SingletonScope
    /// <summary>Helper to create singleton scope</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static IScope NewSingletonScope() => Scope.Of("<singletons>");

    /// <summary>Pretty prints the container info including the open scope details if any.</summary> 
    public override string ToString()
    {
        var s = _ownScopeOrContext is IScopeContext scopeContext
            ? ("container with ambient " + scopeContext)
            : "container";

        var scope = CurrentScope;
        s += scope == null ? " without scope" : " with scope " + scope;

        if (Rules != Rules.Default)
            s += NewLine + " with " + Rules;

        if (IsDisposed)
        {
            s += " is disposed!" + NewLine;
            if (_disposeStackTrace != null)
                s += " Dispose stack-trace " + _disposeStackTrace;
            else
                s += " You may include Dispose stack-trace into the message via:" + NewLine +
                    "container.With(rules => rules.WithCaptureContainerDisposeStackTrace())";
        }

        return s;
    }

    private void TryCaptureContainerDisposeStackTrace()
    {
        try { _disposeStackTrace = new StackTrace(); }
        catch { }
    }

    private static void DisposeScopeContextCurrentScope(IScopeContext scopeContext)
    {
        IScope currentScope = null;
        scopeContext.SetCurrent(s =>
        {
            // save the current scope for the later,
            // do dispose it AFTER its parent is actually set to be a new ambient current scope.
            currentScope = s;
            return s?.Parent;
        });
        currentScope?.Dispose();
    }

    /// <summary>Dispose either open scope, or container with singletons, if no scope opened.</summary>
    public void Dispose()
    {
        // if already disposed - just leave
        if (Interlocked.CompareExchange(ref _disposed, 1, 0) == 1)
            return;

        // nice to have a disposal stack-trace, but we can live without it if something goes wrong
        if (Rules.CaptureContainerDisposeStackTrace)
            TryCaptureContainerDisposeStackTrace();

        // for the scoped container, indicated by the present parent
        if (_parent != null)
        {
            Debug.Assert(_ownScopeOrContext != null, "The container with parent should be scoped");
            if (_ownScopeOrContext is IScope scope)
                scope.Dispose();
            else
                DisposeScopeContextCurrentScope((IScopeContext)_ownScopeOrContext);
        }
        else
        {
            _registry.Swap(Registry.Default);
            Rules = Rules.Default;
            _singletonScope.Dispose(); // will also dispose any tracked scopes
            _ownScopeOrContext?.Dispose();
        }
    }

#if SUPPORTS_ASYNC_DISPOSABLE
    /// <inheritdoc/>
    public System.Threading.Tasks.ValueTask DisposeAsync()
    {
        Dispose(); // todo: @wip async dispose
        // if (disposableObjects != null && disposableObjects.Count > 0)
        // {
        //     HashSet<object> disposedObjects = new HashSet<object>();

        //     for (var i = disposableObjects.Count - 1; i >= 0; i--)
        //     {
        //         object objectToDispose = disposableObjects[i];
        //         if (objectToDispose is IAsyncDisposable asyncDisposable)
        //         {
        //             if (!disposedObjects.Add(objectToDispose))
        //                 continue;

        //             ValueTask valueTask = asyncDisposable.DisposeAsync();
        //             // If we end up here, it means that the ValueTask is not completed
        //             if (!valueTask.IsCompletedSuccessfully)
        //                 return Await(i, valueTask, disposableObjects, disposedObjects);

        //             // If its a IValueTaskSource backed ValueTask, inform it its result has been read so it can reset
        //             valueTask.GetAwaiter().GetResult();
        //         }
        //         else if (disposedObjects.Add(objectToDispose))
        //             ((IDisposable)objectToDispose).Dispose();
        //         else
        //             continue;
        //     }
        // }
        return default;

        // static async ValueTask Await(int i, ValueTask vt, List<object> toDispose, HashSet<object> disposedObjects)
        // {
        //     await vt.ConfigureAwait(false);

        //     // vt is acting on the disposable at index i,
        //     // decrement it and move to the next iteration
        //     i--;

        //     for (; i >= 0; --i)
        //     {
        //         object objectToDispose = toDispose[i];
        //         if (!disposedObjects.Add(objectToDispose))
        //         {
        //             continue;
        //         }
        //         if (objectToDispose is IAsyncDisposable asyncDisposable)
        //         {
        //             await asyncDisposable.DisposeAsync().ConfigureAwait(false);
        //         }
        //         else
        //         {
        //             ((IDisposable)objectToDispose).Dispose();
        //         }
        //     }
        // }
    }
#endif

    #region IRegistrator

    /// <inheritdoc />
    public IEnumerable<ServiceRegistrationInfo> GetServiceRegistrations() =>
        Registry.GetServiceRegistrations(_registry.Value);

    /// <inheritdoc />
    public IEnumerable<R> GetServiceRegistrations<S, R>(S state, MatchOp<S, ServiceRegistrationInfo, R> match) =>
        Registry.GetServiceRegistrations(_registry.Value, state, match);

    /// <inheritdoc />
    public IEnumerable<DecoratorRegistrationInfo> GetDecoratorRegistrations() =>
        Registry.GetDecoratorRegistrations(_registry.Value);

    // todo: @api Make `serviceKey` and `factoryType` optional
    /// <summary>Searches for registered factories by type, and key (if specified),
    /// and by factory type (by default uses <see cref="FactoryType.Service"/>).
    /// May return empty, 1 or multiple factories.</summary>
    public Factory[] GetRegisteredFactories(Type serviceType, object serviceKey, FactoryType factoryType) =>
        Registry.GetRegisteredFactories(_registry.Value, serviceType.ThrowIfNull(), serviceKey, factoryType);

    /// <inheritdoc/>
    public void Register(Factory factory, Type serviceType, object serviceKey, IfAlreadyRegistered? ifAlreadyRegistered, bool isStaticallyChecked)
    {
        ThrowIfRootContainerDisposed();

        if (serviceKey == null)
            serviceKey = Rules.DefaultRegistrationServiceKey;

        if (serviceKey != null & Rules.HasMultipleSameServiceKeyForTheServiceType)
            serviceKey = Rules.EnsureUniqueServiceKey(serviceType, serviceKey);

        factory.ThrowIfNull().ValidateAndNormalizeRegistration(serviceType, serviceKey, isStaticallyChecked, Rules, throwIfInvalid: true);

        if (!ifAlreadyRegistered.HasValue)
            ifAlreadyRegistered = Rules.DefaultIfAlreadyRegistered;

        if (serviceType.IsGenericType && !serviceType.IsGenericTypeDefinition && serviceType.ContainsGenericParameters)
            serviceType = serviceType.GetGenericTypeDefinition();

        var r = _registry.Value;
        if (!_registry.TrySwapIfStillCurrent(r, Registry.Register(r, factory, serviceType, ifAlreadyRegistered.Value, serviceKey)))
            RegistrySwap(factory, serviceType, ifAlreadyRegistered.Value, serviceKey);
    }

    /// <inheritdoc/>
    public void RegisterWithoutValidation(Factory factory, Type serviceType, object serviceKey, IfAlreadyRegistered? ifAlreadyRegistered)
    {
        ThrowIfRootContainerDisposed();

        if (serviceKey == null)
            serviceKey = Rules.DefaultRegistrationServiceKey;

        if (!ifAlreadyRegistered.HasValue)
            ifAlreadyRegistered = Rules.DefaultIfAlreadyRegistered;

        if (serviceType.IsGenericType && !serviceType.IsGenericTypeDefinition && serviceType.ContainsGenericParameters)
            serviceType = serviceType.GetGenericTypeDefinition();

        var r = _registry.Value;
        if (!_registry.TrySwapIfStillCurrent(r, Registry.Register(r, factory, serviceType, ifAlreadyRegistered.Value, serviceKey)))
            RegistrySwap(factory, serviceType, ifAlreadyRegistered.Value, serviceKey);
    }

    // hiding nested lambda in method to reduce allocations
    private ImHashMap<Type, object> RegistrySwap(Factory factory, Type serviceType, IfAlreadyRegistered? ifAlreadyRegistered, object serviceKey) =>
        _registry.Swap(r => Registry.Register(r, factory, serviceType, ifAlreadyRegistered.Value, serviceKey));

    /// <inheritdoc />
    public bool IsRegistered(Type serviceType, object serviceKey, FactoryType factoryType, Func<Factory, bool> condition) =>
        Registry.IsRegistered(_registry.Value, serviceType, serviceKey, factoryType, condition);

    /// <inheritdoc />
    public void Unregister(Type serviceType, object serviceKey, FactoryType factoryType, Func<Factory, bool> condition)
    {
        ThrowIfRootContainerDisposed();
        _registry.Swap(r => Registry.Unregister(r, factoryType, serviceType, serviceKey, condition)); // todo: @perf @mem reduce closure allocation
    }

    #endregion

    #region IResolver

    /// <summary>
    /// Resolves service with the <see cref="IfUnresolved.ReturnDefaultIfNotRegistered"/> policy,
    /// enabling the fallback resolution for not registered services (default MS convention).
    /// For diagnostics reasons, you may globally set the rule <see cref="DryIoc.Rules.ServiceProviderGetServiceShouldThrowIfUnresolved"/> to alter the behavior. 
    /// It may help to highlight the issues by throwing the original rich <see cref="ContainerException"/> instead of just returning the `null`.
    /// </summary>
    object IServiceProvider.GetService(Type serviceType) =>
        Resolve(serviceType, Rules.ServiceProviderGetServiceShouldThrowIfUnresolved ? IfUnresolved.Throw : IfUnresolved.ReturnDefaultIfNotRegistered);

    /// <inheritdoc />
    public object Resolve(Type serviceType, IfUnresolved ifUnresolved)
    {
        var compTime = Rules.CompileTimeContainer;
        if (compTime != null && compTime.TryResolve(out var compTimeService, this, serviceType))
            return compTimeService;

        var serviceTypeHash = RuntimeHelpers.GetHashCode(serviceType);

        // inlined GetCachedDefaultFactoryOrDefault
        var entry = (_registry.Value as Registry)
            ?.DefaultFactoryCache?[serviceTypeHash & Registry.CACHE_SLOT_COUNT_MASK]
            ?.GetEntryOrDefaultByReferenceEquals(serviceTypeHash, serviceType);

        if (entry != null)
        {
            if (entry.Value is Func<IResolverContext, object> cachedDelegate)
                return cachedDelegate(this);
            if (entry.Value is FactoryDelegateCompiler.CachedResult cachedResult)
                return cachedResult.Instance;

            var scope = _ownScopeOrContext.AsScopeOrNull();
            if (this.TryGetUsedInstance((Scope)scope, (Scope)_singletonScope, serviceTypeHash, serviceType, out var used))
            {
                entry.Value = null; // reset the cache
                return used;
            }

            // Cached expression cannot be ConstantExpression because we unwrap the constant and put its value in the cache instead.
            // Also the expression is already normalized via NormalizeExpression before put into cache, 
            // that's why will call CompileOrInterpretFactoryDelegate
            var useInterpretation = Rules.UseInterpretation;
            while (entry.Value is Expression cachedExpr)
            {
                if (useInterpretation && Interpreter.TryInterpretAndUnwrapContainerException(this, cachedExpr, out var result))
                    return result;

                // set to Compiling to notify other threads to use the interpretation until the service is compiled
                if (Interlocked.CompareExchange(ref entry.Value, new FactoryDelegateCompiler.Compiling(cachedExpr), cachedExpr) == cachedExpr)
                {
                    var compiledFactory = cachedExpr.CompileOrInterpretFactoryDelegate(useInterpretation);
                    entry.Value = compiledFactory; // todo: @unclear should we instead cache only after invoking the factory delegate, avoiding the failing delegate in cache
                    return compiledFactory(this);
                }
            }

            if (entry.Value is FactoryDelegateCompiler.Compiling compiling)
                return Interpreter.TryInterpretAndUnwrapContainerException(this, compiling.Expression, out var result) ? result
                    : compiling.Expression.CompileOrInterpretFactoryDelegate(useInterpretation)(this);
        }

        return ResolveAndCache(serviceTypeHash, serviceType, ifUnresolved);
    }

    private object ResolveAndCache(int serviceTypeHash, Type serviceType, IfUnresolved ifUnresolved)
    {
        if (_singletonScope.IsDisposed)
            Throw.It(Error.ContainerIsDisposed, ToString());

        var scope = _ownScopeOrContext.AsScopeOrNull();
        if (this.TryGetUsedInstance((Scope)scope, (Scope)_singletonScope, serviceTypeHash, serviceType, out var used))
            return used;

        // todo: @perf Should we in the first place create the request here, or later in CreateExpression because it may be faster for the root service without dependency or with the delegate factory? 
        var request = Request.CreateFromServiceType(this, serviceType, ifUnresolved);
        var factory = ResolveFactory(request); // note: ResolveFactory may mutate request, but it should be safe because it is not shared between threads.

        // Delegate to full blown Resolve aware of service key, open scope, etc.
        var serviceKey = request.GetServiceDetails().ServiceKey;
        var scopeName = scope?.Name;
        if (serviceKey != null | scopeName != null)
            // todo: @perf optimize the call, path the created request/stack, found scope, use this.TryGetUsedInstance, etc.
            return ResolveAndCacheKeyed(serviceTypeHash, serviceType, serviceKey, ifUnresolved, scopeName, null, Request.Empty, null);

        if (factory == null)
            return null;

        var rules = Rules;
        bool requestCanCache;
        object createdInstance = null; // evaluated singleton or similar
        Func<IResolverContext, object> factoryDelegate;
        if (rules.UseInterpretationForTheFirstResolution)
        {
            var expr = factory.GetExpressionOrDefault(request);
            requestCanCache = request.CanCache();
            request.ReturnToPool();

            if (expr == null)
                return null;

            if (expr is ConstantExpression constExpr)
            {
                var value = constExpr.Value;
                if (value is ScopedItemException ex)
                    ex.ReThrow();
                if (factory.CanCache & requestCanCache)
                    TryCacheDefaultFactoryDelegateOrExprOrResult(serviceTypeHash, serviceType, value.ToCachedResult());
                return value;
            }

            // 1) First try to interpret
            if (Interpreter.TryInterpretAndUnwrapContainerException(this, expr, out var instance))
            {
                // todo: @check ...but what if exception is thrown, isn't it better to avoid caching the bad expression?
                if (factory.CanCache & requestCanCache)
                    TryCacheDefaultFactoryDelegateOrExprOrResult(serviceTypeHash, serviceType, expr);
                return instance;
            }

            // 2) Fallback to expression compilation
            factoryDelegate = expr.CompileOrInterpretFactoryDelegate(rules.UseInterpretation);
        }
        else
        {
            factoryDelegate = factory.GetDelegateOrDefault(request, out createdInstance);
            requestCanCache = request.CanCache();
            request.ReturnToPool();

            if (factoryDelegate == null & createdInstance == null)
                return null;
        }

        if (createdInstance != null)
            return createdInstance;

        if (factory.CanCache & requestCanCache)
            TryCacheDefaultFactoryDelegateOrExprOrResult(serviceTypeHash, serviceType, factoryDelegate);

        // Factory delegate may throw an exception, and in case it was thrown for the scoped dependency,
        // we need to be sure to re-throw it the next time the delegate is resolved.
        // The same way as it is done for the  first resolution in `TryInterpretAndUnwrapContainerException`.
        return this.TryInvokeFactoryDelegateAndStoreNonContainerExceptionInScope(factoryDelegate);
    }

    /// <inheritdoc />
    public object Resolve(Type serviceType, object serviceKey,
        IfUnresolved ifUnresolved, Type requiredServiceType, Request preResolveParent, object[] args)
    {
        var scopeName = CurrentScope?.Name;
        // fallback to simple Resolve and its default cache if no keys are passed
        return serviceKey == null & requiredServiceType == null & scopeName == null &&
            (preResolveParent == null || preResolveParent.IsEmpty) && args.IsNullOrEmpty()
            ? Resolve(serviceType, ifUnresolved)
            : ResolveAndCacheKeyed(RuntimeHelpers.GetHashCode(serviceType), serviceType,
                serviceKey, ifUnresolved, scopeName, requiredServiceType, preResolveParent ?? Request.Empty, args);
    }

    private object ResolveAndCacheKeyed(int serviceTypeHash, Type serviceType,
        object serviceKey, IfUnresolved ifUnresolved, object scopeName, Type requiredServiceType, Request preResolveParent,
        object[] args)
    {
        var compTime = Rules.CompileTimeContainer;
        if (compTime != null && compTime.TryResolve(out var service, this, serviceType, serviceKey, requiredServiceType, preResolveParent, args))
            return service;

        // #288 - ignoring the parent, `args`, `scopeName`seems OK because Use is supposed to overwrite anything with args,
        // and TryGetUsedInstance will look into scope with the specified `scopeName` anyway
        if (serviceKey == null & requiredServiceType == null)
            if (ResolverContext.TryGetUsedInstance(this, serviceTypeHash, serviceType, out var usedInstance))
                return usedInstance;

        object cacheKey = null;
        if (requiredServiceType == null & preResolveParent.IsEmpty && args.IsNullOrEmpty())
        {
            cacheKey = scopeName == null ? serviceKey
                : serviceKey == null ? scopeName
                : KV.Of(scopeName, serviceKey); // using the KV class and not some struct here because the object anyway and struct will be boxed anyway.

            if (Registry.GetCachedKeyedFactoryOrDefault(_registry.Value, serviceTypeHash, serviceType, cacheKey, out var cacheEntry))
            {
                if (cacheEntry.Factory is Func<IResolverContext, object> cachedDelegate)
                    return cachedDelegate(this);
                if (cacheEntry.Factory is FactoryDelegateCompiler.CachedResult cachedResult)
                    return cachedResult.Instance;
                if (TryInterpretOrCompileCachedExpression(this, cacheEntry, Rules.UseInterpretation, out var result))
                    return result;
            }
        }

        // Cache is missed, so get the factory and put it into cache, but first check if the container is still alive
        ThrowIfRootContainerDisposed();

        var serviceTypeOrInfo = ServiceInfo.OrServiceType(serviceType, requiredServiceType, ifUnresolved, serviceKey);
        var request = Request.CreateFromServiceTypeOrInfo(this, serviceTypeOrInfo, preResolveParent, default, args);
        var factory = ResolveFactory(request);
        if (factory == null)
            return null;

        // Prevents caching if factory says Don't
        if (!factory.CanCache)
            cacheKey = null;

        // Request service key may be changed when resolving the factory,
        // so we need to look into Default cache again for the new key
        var changedServiceKey = request.GetServiceDetails().ServiceKey;
        if (cacheKey != null & serviceKey == null & changedServiceKey != null)
        {
            cacheKey = scopeName == null ? changedServiceKey : KV.Of(scopeName, changedServiceKey);
            if (Registry.GetCachedKeyedFactoryOrDefault(_registry.Value, serviceTypeHash, serviceType, cacheKey, out var cacheEntry))
            {
                if (cacheEntry.Factory is Func<IResolverContext, object> cachedDelegate)
                    return cachedDelegate(this);
                if (cacheEntry.Factory is FactoryDelegateCompiler.CachedResult cachedResult)
                    return cachedResult.Instance;
                if (TryInterpretOrCompileCachedExpression(this, cacheEntry, Rules.UseInterpretation, out var result))
                    return result;
            }
        }

        var rules = Rules;
        bool requestCanCache;
        object createdInstance = null;
        Func<IResolverContext, object> factoryDelegate;
        if (rules.UseInterpretationForTheFirstResolution)
        {
            var expr = factory.GetExpressionOrDefault(request);
            requestCanCache = request.CanCache();
            request.ReturnToPool();

            if (expr == null)
                return null;

            if (expr is ConstantExpression constExpr)
            {
                var value = constExpr.Value;
                if (cacheKey != null & requestCanCache)
                    TryCacheKeyedFactoryDelegateOrExprOrResult(serviceTypeHash, serviceType, cacheKey, value.ToCachedResult());
                return value;
            }

            // Important to cache expression first before tying to interpret, so that parallel resolutions may already use it
            if (cacheKey != null & requestCanCache)
                TryCacheKeyedFactoryDelegateOrExprOrResult(serviceTypeHash, serviceType, cacheKey, expr);

            // 1) First try to interpret
            if (Interpreter.TryInterpretAndUnwrapContainerException(this, expr, out var instance))
                return instance;

            // 2) Fallback to expression compilation
            factoryDelegate = expr.CompileOrInterpretFactoryDelegate(rules.UseInterpretation);
        }
        else
        {
            factoryDelegate = factory.GetDelegateOrDefault(request, out createdInstance);
            requestCanCache = request.CanCache();
            request.ReturnToPool();

            if (factoryDelegate == null & createdInstance == null)
                return null;
        }

        if (createdInstance != null)
            return createdInstance;

        if (cacheKey != null & requestCanCache)
            TryCacheKeyedFactoryDelegateOrExprOrResult(serviceTypeHash, serviceType, cacheKey, factoryDelegate);

        return this.TryInvokeFactoryDelegateAndStoreNonContainerExceptionInScope(factoryDelegate);
    }

    private static bool TryInterpretOrCompileCachedExpression(IResolverContext r, Registry.KeyedFactoryCacheEntry cacheEntry, bool useInterpretation, out object result)
    {
        while (cacheEntry.Factory is Expression expr)
        {
            if (useInterpretation && Interpreter.TryInterpretAndUnwrapContainerException(r, expr, out result))
                return true;

            // set to Compiling to notify other threads to use the interpretation until the service is compiled
            if (Interlocked.CompareExchange(ref cacheEntry.Factory, new FactoryDelegateCompiler.Compiling(expr), expr) == expr)
            {
                var factoryDelegate = expr.CompileOrInterpretFactoryDelegate(useInterpretation);
                // todo: @unclear should we instead cache only after invoking the factory delegate
                cacheEntry.Factory = factoryDelegate;
                result = factoryDelegate(r);
                return true;
            }
        }

        if (cacheEntry.Factory is FactoryDelegateCompiler.Compiling compiling)
        {
            if (!Interpreter.TryInterpretAndUnwrapContainerException(r, compiling.Expression, out result))
                result = compiling.Expression.CompileOrInterpretFactoryDelegate(useInterpretation)(r);
            return true;
        }

        result = null;
        return false;
    }

    IEnumerable<object> IResolver.ResolveMany(Type serviceType, object serviceKey,
        Type requiredServiceType, Request preResolveParent, object[] args)
    {
        var generatedFactories = Rules.CompileTimeContainer?.ResolveMany(this, serviceType) ?? Enumerable.Empty<ResolveManyResult>();

        var requiredItemType = requiredServiceType ?? serviceType;
        if (serviceKey != null)
            generatedFactories = generatedFactories.Match(serviceKey, static (sk, x) => sk.MatchToNotNullRegisteredKey(x.ServiceKey));
        if (requiredServiceType != null)
            generatedFactories = generatedFactories.Match(requiredServiceType, static (rst, x) => rst == x.RequiredServiceType);

        foreach (var generated in generatedFactories)
            yield return generated.FactoryDelegate(this);

        // Emulating the collection parent so that collection related rules and conditions were applied
        // the same way as if resolving IEnumerable<T>
        if (preResolveParent == null || preResolveParent.IsEmpty)
            preResolveParent = Request.Empty.Push(
                typeof(IEnumerable<object>), requiredItemType, serviceKey, IfUnresolved.Throw,
                WrappersSupport.CollectionWrapperID, FactoryType.Wrapper, null, null, 0, 0);

        var unwrappedType = GetWrappedType(requiredItemType, null);
        if (unwrappedType != null & unwrappedType != typeof(void)) // accounting for the resolved action GH#114
            requiredItemType = unwrappedType;

        var items = GetAllServiceFactories(requiredItemType)
            .Map(requiredServiceType, static (t, f) => new ServiceRegistrationInfo(f.Value, t, f.Key));

        ServiceRegistrationInfo[] openGenericItems = null;
        if (requiredItemType.IsClosedGeneric())
        {
            var requiredItemOpenGenericType = requiredItemType.GetGenericTypeDefinition();
            openGenericItems = GetAllServiceFactories(requiredItemOpenGenericType)
                .Map(requiredItemOpenGenericType, requiredServiceType,
                    static (gt, t, x) => new ServiceRegistrationInfo(x.Value, t, new ServiceKeyAndRequiredOpenGenericType(gt, x.Key)));
        }

        // Append registered generic types with compatible variance,
        // e.g. for IHandler<in E> - IHandler<A> is compatible with IHandler<B> if B : A.
        ServiceRegistrationInfo[] variantGenericItems = null;
        if (requiredItemType.IsGenericType && Rules.VariantGenericTypesInResolvedCollection)
        {
            variantGenericItems = GetServiceRegistrations(requiredItemType,
                static (ref Type reqItType, ref ServiceRegistrationInfo src, out ServiceRegistrationInfo res) =>
                {
                    res = src;
                    if (!reqItType.IsAssignableVariantGenericTypeFrom(src.ServiceType))
                        return false;
                    if (res.OptionalServiceKey == null)
                        res.OptionalServiceKey = DefaultKey.Value;
                    return true;
                })
                .ToArrayOrSelf();
        }

        if (serviceKey != null)
        {
            items = items.Match(serviceKey, static (k, x) => k.MatchToNotNullRegisteredKey(x.OptionalServiceKey));
            if (openGenericItems != null && openGenericItems.Length != 0)
                openGenericItems = openGenericItems.Match(serviceKey, static (k, x) => k.MatchToNotNullRegisteredKey(x.OptionalServiceKey));
            if (variantGenericItems != null && variantGenericItems.Length != 0)
                variantGenericItems = variantGenericItems.Match(serviceKey, static (k, x) => k.MatchToNotNullRegisteredKey(x.OptionalServiceKey));
        }

        var d = preResolveParent.GetServiceDetails();
        var metadataKey = d.MetadataKey;
        var metadata = d.Metadata;
        if (metadataKey != null | metadata != null)
        {
            items = items.Match(metadataKey, metadata, static (mk, m, x) => x.Factory.Setup.MatchesMetadata(mk, m));
            if (openGenericItems != null && openGenericItems.Length != 0)
                openGenericItems = openGenericItems.Match(metadataKey, metadata, static (mk, m, x) => x.Factory.Setup.MatchesMetadata(mk, m));
            if (variantGenericItems != null && variantGenericItems.Length != 0)
                variantGenericItems = variantGenericItems.Match(metadataKey, metadata, static (mk, m, x) => x.Factory.Setup.MatchesMetadata(mk, m));
        }

        // Exclude composite parent service from items, skip decorators
        var parent = preResolveParent;
        if (parent.FactoryType != FactoryType.Service)
            parent = parent.FirstOrDefault(static p => p.FactoryType == FactoryType.Service) ?? Request.Empty;

        if (!parent.IsEmpty && parent.ActualServiceType == requiredItemType)
        {
            items = items.Match(parent.FactoryID, static (id, x) => x.Factory.FactoryID != id);
            if (openGenericItems != null)
                openGenericItems = openGenericItems.Match(parent.FactoryID,
                    static (pfid, x) => x.Factory.GeneratedFactories?.ToArray().FindFirst(pfid, static (i, f) => f.Value.FactoryID == i) == null);
            if (variantGenericItems != null)
                variantGenericItems = variantGenericItems.Match(parent.FactoryID,
                    static (pfid, x) => x.Factory.FactoryID != pfid);
        }

        var allItems = openGenericItems == null & variantGenericItems == null ? items
            : variantGenericItems == null ? items.Append(openGenericItems)
            : openGenericItems == null ? items.Append(variantGenericItems)
            : items.Append(openGenericItems).Append(variantGenericItems);

        var multipleSameServiceKeySupport = Rules.HasMultipleSameServiceKeyForTheServiceType;

        // Resolve in the registration order
        foreach (var item in allItems.OrderBy(static x => x.FactoryRegistrationOrder))
        {
            var itemServiceKey = WrappersSupport.EnsureItemKeyCanBeMatched(serviceKey, item.OptionalServiceKey, multipleSameServiceKeySupport);

            var service = Resolve(serviceType, itemServiceKey,
                IfUnresolved.ReturnDefaultIfNotRegistered, // mark the resolution to return null if failed instead of throwing, so we can filter out the nulls later
                item.ServiceType, preResolveParent, args);
            if (service != null) // skip unresolved items
                yield return service;
        }
    }

    private void ThrowIfContainerDisposed()
    {
        if (IsDisposed)
            Throw.It(Error.ContainerIsDisposed, ToString());
    }

    private void ThrowIfRootContainerDisposed()
    {
        if (_singletonScope.IsDisposed)
            Throw.It(Error.ContainerIsDisposed, ToString());
    }

    #endregion

    #region IResolverContext

    /// <inheritdoc />
    public IResolverContext Parent => _parent;

    /// <inheritdoc />
    public IResolverContext Root
    {
        get
        {
            if (_parent == null)
                return null;
            var p = _parent;
            while (p.Parent != null)
                p = p.Parent;
            return p;
        }
    }

    /// <inheritdoc />
    public IScope SingletonScope => _singletonScope;

    /// <inheritdoc />
    public IScopeContext ScopeContext => _ownScopeOrContext as IScopeContext;

    /// <inheritdoc />
    public IScope CurrentScope => _ownScopeOrContext.AsScopeOrNull();

    /// <inheritdoc />
    public IScope CurrentOrSingletonScope => _ownScopeOrContext.AsScopeOrNull() ?? _singletonScope;

    /// <inheritdoc />
    public IResolverContext WithCurrentScope(IScope ownScope)
    {
        Debug.Assert(ownScope != null, "Hey, don't pass null ownScope to WithCurrentScope, do you mean the WithScopeContext instead?");
        if (_singletonScope.IsDisposed)
            Throw.It(Error.ContainerIsDisposed, ToString());
        return new Container(Rules, _registry, _singletonScope, ownScope, 0, null, this);
    }

    /// <inheritdoc />
    public IResolverContext WithScopeContext(IScopeContext scopeContext)
    {
        if (_singletonScope.IsDisposed)
            Throw.It(Error.ContainerIsDisposed, ToString());
        return new Container(Rules, _registry, _singletonScope, scopeContext, 0, null, this);
    }

    /// <summary>Creates the new scope using the Container's current scope as a parent.
    /// Made virtual to allow additional code run when scope is opened, e.g. automatically resolve some services, see #539.
    /// </summary>
    public virtual IContainer WithNewOpenScope(out IScope newScope)
    {
        Debug.Assert(!_singletonScope.IsDisposed);
        if (_ownScopeOrContext == null)
        {
            newScope = new Scope();
            return new Container(Rules, _registry, _singletonScope, newScope, 0, null, this);
        }
        if (_ownScopeOrContext is IScope scope)
        {
            newScope = Scope.OfSomeParent(scope);
            return new Container(Rules, _registry, _singletonScope, newScope, 0, null, this);
        }

        return WithNewOpenScopeInScopeContext((IScopeContext)_ownScopeOrContext, out newScope);
    }

    private IContainer WithNewOpenScopeInScopeContext(IScopeContext scopeContext, out IScope newScope)
    {
        newScope = scopeContext.SetNewOpen();
        return new Container(Rules, _registry, _singletonScope, scopeContext, 0, null, this);
    }

    void IResolverContext.InjectPropertiesAndFields(object instance, string[] propertyAndFieldNames)
    {
        var instanceType = instance.ThrowIfNull().GetType();

        PropertiesAndFieldsSelector propertiesAndFields = null;
        if (!propertyAndFieldNames.IsNullOrEmpty())
        {
            var matchedMembers = instanceType.GetMembers(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
                .Match(propertyAndFieldNames,
                    static (p, m) => (m is PropertyInfo || m is FieldInfo) && p.IndexOf(m.Name) != -1,
                    static (p, x) => PropertyOrFieldServiceInfo.Of(x));

            propertiesAndFields = matchedMembers.ToFunc<Request, IEnumerable<PropertyOrFieldServiceInfo>>;
        }

        propertiesAndFields = propertiesAndFields ?? Rules.PropertiesAndFields ?? PropertiesAndFields.Auto;

        var request = Request.CreateFromServiceType(this, instanceType)
            .WithResolvedFactory(new InjectedIntoFactoryDummy(instanceType), skipRecursiveDependencyCheck: true, skipCaptiveDependencyCheck: true);

        foreach (var serviceInfo in propertiesAndFields(request))
            if (serviceInfo != null)
            {
                var details = serviceInfo.Details;
                var value = Resolve(serviceInfo.ServiceType, details.ServiceKey,
                    details.IfUnresolved, details.RequiredServiceType, request, args: null);
                if (value != null)
                    serviceInfo.SetValue(instance, value);
            }
    }

    /// <summary>Setting the factory directly to scope for resolution</summary> 
    public void Use(Type serviceType, object instance)
    {
        var serviceTypeHash = RuntimeHelpers.GetHashCode(serviceType);
        (_ownScopeOrContext.AsScopeOrNull() ?? _singletonScope).SetUsed(serviceTypeHash, serviceType, instance);

        // reset the cache if any
        var cacheEntry = Registry.GetCachedDefaultFactoryOrDefault(_registry.Value, serviceTypeHash, serviceType);
        if (cacheEntry != null)
            cacheEntry.Value = null;
    }

    #endregion

    #region IContainer

    /// <summary>The rules object defines policies per container for registration and resolution.</summary>
    public Rules Rules { get; private set; }

    /// <summary>Represents scope bound to container itself, and not the ambient (context) thing.</summary>
    public IScope OwnCurrentScope => _ownScopeOrContext as IScope;

    /// <summary>Indicates that container is disposed.</summary>
    public bool IsDisposed => _disposed == 1 || _singletonScope.IsDisposed || (_ownScopeOrContext as IScope)?.IsDisposed == true;

    /// <inheritdoc />
    public object DisposeInfo => _disposeStackTrace;

    /// <inheritdoc />
    public IContainer With(IResolverContext parent, Rules rules, IScopeContext scopeContext,
        RegistrySharing registrySharing, IScope singletonScope, IScope currentScope,
        IsRegistryChangePermitted? isRegistryChangePermitted)
    {
        ThrowIfContainerDisposed();

        var registryOrServices = _registry.Value;
        var r = registryOrServices as Registry;

        var registry =
            registrySharing == RegistrySharing.Share ? _registry :
            registrySharing == RegistrySharing.CloneButKeepCache ? Ref.Of(registryOrServices)
            // CloneAndDropCache
            : r != null ? Ref.Of((ImHashMap<Type, object>)r.WithoutCache()) : Ref.Of(registryOrServices);

        if (isRegistryChangePermitted.HasValue)
        {
            var isChangePermitted = isRegistryChangePermitted.Value;
            r = registry.Value as Registry;
            if (r != null)
            {
                if (r.IsChangePermitted != isChangePermitted)
                    registry = Ref.Of((ImHashMap<Type, object>)r.WithIsChangePermitted(isChangePermitted));
            }
            else if (isChangePermitted != IsRegistryChangePermitted.Permitted)
                registry = Ref.Of((ImHashMap<Type, object>)new Registry.AndCache(registryOrServices, null, null, null, isChangePermitted));
        }

        return new Container(rules ?? Rules, registry, singletonScope ?? NewSingletonScope(),
            currentScope ?? scopeContext ?? _ownScopeOrContext, _disposed, _disposeStackTrace, parent ?? _parent);
    }

    /// <inheritdoc />
    public KeyValuePair<ServiceInfo, ContainerException>[] Validate(IEnumerable<ServiceInfo> roots)
    {
        Throw.ThrowIfNull(roots, Error.FoundNoRootsToValidate, this);

        var validatingContainer = this.With(rules => rules.ForValidate());

        var depRequestStack = new Request[8];

        List<KeyValuePair<ServiceInfo, ContainerException>> errors = null;
        foreach (var root in roots)
        {
            try
            {
                var request = Request.CreateForValidation(validatingContainer, root, depRequestStack);
                validatingContainer.ResolveFactory(request)?.GetExpressionOrDefault(request);
            }
            catch (ContainerException ex)
            {
                if (errors == null)
                    errors = new List<KeyValuePair<ServiceInfo, ContainerException>>();
                errors.Add(root.Pair(ex));
            }
        }

        return errors?.ToArray() ?? ArrayTools.Empty<KeyValuePair<ServiceInfo, ContainerException>>();
    }

    /// <inheritdoc />
    public GeneratedExpressions GenerateResolutionExpressions(
        Func<IEnumerable<ServiceRegistrationInfo>, IEnumerable<ServiceInfo>> getRoots = null, bool allowRuntimeState = false)
    {
        var generatingContainer = this.WithExpressionGeneration(allowRuntimeState);
        var regs = generatingContainer.GetServiceRegistrations();
        var roots = getRoots != null ? getRoots(regs) : regs.Select(static r => r.ToServiceInfo());

        var result = new GeneratedExpressions();
        foreach (var root in roots)
        {
            try
            {
                var request = Request.Create(generatingContainer, root);
                var expr = generatingContainer.ResolveFactory(request)?.GetExpressionOrDefault(request);
                if (expr == null)
                    continue;
                result.Roots.Add(root.Pair(expr.WrapInFactoryExpressionWithoutNormalization()));
            }
            catch (ContainerException ex)
            {
                result.Errors.Add(root.Pair(ex));
            }
        }

        var depExprs = generatingContainer.Rules.DependencyResolutionCallExprs.Value;
        result.ResolveDependencies.AddRange(depExprs.Enumerate().Select(static r => r.Key.Pair(r.Value)));
        return result;
    }

    /// <inheritdoc />
    public bool ClearCache(Type serviceType, FactoryType? factoryType, object serviceKey)
    {
        var hash = RuntimeHelpers.GetHashCode(serviceType);

        if (factoryType != null)
            return Registry.ClearCache(_registry.Value, hash, serviceType, serviceKey, factoryType.Value);

        var registry = _registry.Value;
        var clearedServices = Registry.ClearCache(registry, hash, serviceType, serviceKey, FactoryType.Service);
        var clearedWrapper = Registry.ClearCache(registry, hash, serviceType, serviceKey, FactoryType.Wrapper);
        var clearedDecorator = Registry.ClearCache(registry, hash, serviceType, serviceKey, FactoryType.Decorator);

        return clearedServices | clearedWrapper | clearedDecorator;
    }

    /// <inheritdoc />
    public Factory ResolveFactory(Request request)
    {
        var factory = GetServiceFactoryOrDefault(request);
        if (factory == null)
        {
            factory = GetWrapperFactoryOrDefault(request);
            if (factory != null)
                return factory;

            // todo: @remove @obsolete
            var unknownServiceResolvers = Rules.UnknownServiceResolvers;
            if (!unknownServiceResolvers.IsNullOrEmpty())
                for (var i = 0; factory == null && i < unknownServiceResolvers.Length; i++)
                    factory = unknownServiceResolvers[i](request.Isolate())?.DoNotCache();
        }

        if (factory?.GeneratedFactories != null)
            factory = factory.GetGeneratedFactoryOrDefault(request);

        return factory != null ? factory
            : !request.IsResolutionCall && Rules.GenerateResolutionCallForMissingDependency ? null
            : ThrowUnableToResolveOrGetDefault(request, factory);
    }

    /// <inheritdoc />
    public Factory ResolveFactory(ServiceInfo serviceInfo) =>
        ResolveFactory(Request.Create(this, serviceInfo));

    /// <inheritdoc />
    public Expression ResolveExpression(ServiceInfo serviceInfo)
    {
        var request = Request.Create(this, serviceInfo);
        return ResolveFactory(request)?.GetExpressionOrDefault(request);
    }

    internal static T ThrowUnableToResolveOrGetDefault<T>(Request request, T defaultResult)
    {
        if (request.IfUnresolved == IfUnresolved.Throw)
        {
            var str = new StringBuilder();
            str = request.Container
                .GetAllServiceFactoriesPlusForOpenGeneric(request.ServiceType)
                .Aggregate(str, (s, x) => s
                    .Append((x.Value.Reuse?.CanApply(request) ?? true) ? "  " : "  without matching scope ")
                    .Print(x));

            if (str.Length != 0)
                Throw.It(Error.UnableToResolveFromRegisteredServices, request, str);
            else
                Throw.It(Error.UnableToResolveUnknownService, request,
                    request.Rules.DynamicRegistrationProviders.EmptyIfNull().Length,
                    request.Rules.UnknownServiceResolvers.EmptyIfNull().Length);
        }
        return defaultResult;
    }

    /// <inheritdoc />
    public Factory GetServiceFactoryOrDefault(Request request)
    {
        var details = request.GetServiceDetails();
        var serviceKey = details.ServiceKey;
        var requiredServiceType = details.RequiredServiceType;

        Type serviceType;
        if (requiredServiceType != null && requiredServiceType.IsOpenGeneric())
            serviceType = requiredServiceType;
        else
        {
            serviceType = request.ActualServiceType;

            // Special case when open-generic required service type is encoded in ServiceKey as a pair of { RequiredOpenGenericServiceType, ServiceKey }
            // presumes that required service type is closed generic
            if (serviceKey != null && serviceKey is ServiceKeyAndRequiredOpenGenericType keyAndType &&
                serviceType.IsClosedGeneric() && keyAndType.RequiredServiceType == serviceType.GetGenericTypeDefinition())
            {
                serviceType = keyAndType.RequiredServiceType;
                serviceKey = keyAndType.ServiceKey;
            }
        }

        var serviceFactories = _registry.Value;
        if (serviceFactories is Registry r)
            serviceFactories = r.Services;

        var rules = Rules;
        if (rules.FactorySelector != null & serviceKey == null)
            return GetRuleSelectedServiceFactoryOrDefault(rules, serviceFactories, request, details, serviceType);

        var entry = serviceFactories.GetValueOrDefault(serviceType);

        // For closed-generic type, when the entry is not found or the key in entry is not found go for the open-generic services
        Type openGenericServiceType = null;
        if (serviceType.IsClosedGeneric())
        {
            openGenericServiceType = serviceType.GetGenericTypeDefinition();
            if (entry == null ||
                serviceKey != null && (
                entry is Factory && !DefaultKey.Value.Equals(serviceKey) ||
                entry is FactoriesEntry factoriesEntry && factoriesEntry.GetFirstKeyedOrDefault(serviceKey) == null))
                entry = serviceFactories.GetValueOrDefault(openGenericServiceType) ?? entry;

            // todo: @wip wrap into the method as it is rarely used
            if (entry == null && rules.VariantGenericTypesInResolve)
            {
                foreach (var e in serviceFactories.Enumerate())
                {
                    if (e.Value is Factory f)
                    {
                        if ((serviceKey == null | serviceKey == DefaultKey.Value) &&
                            serviceType.IsAssignableVariantGenericTypeFrom(e.Key) &&
                            request.MatchFactoryConditionAndMetadata(details, f))
                        {
                            entry = f;
                            break;
                        }
                    }
                    else
                    {
                        foreach (var kf in ((FactoriesEntry)e.Value).Factories)
                            if (serviceKey.MatchToNotNullRegisteredKey(kf.Key) &&
                                serviceType.IsAssignableVariantGenericTypeFrom(e.Key) &&
                                request.MatchFactoryConditionAndMetadata(details, kf.Value))
                            {
                                entry = kf.Value;
                                break;
                            }
                    }
                }
            }
        }

        // Hot path - when we have a single default factory and no dynamic rules to apply
        if (entry is Factory defaultFactory &&
            (rules.DynamicRegistrationProviders == null ||
            !rules.HasDynamicRegistrationProvider(DynamicRegistrationFlags.Service, withoutFlags: DynamicRegistrationFlags.AsFallback)))
            return (serviceKey == null | serviceKey == DefaultKey.Value)
                && request.MatchFactoryConditionAndMetadata(details, defaultFactory)
                ? defaultFactory : null;

        var factories = FactoriesEntry.ToNotNullKeyedFactories(entry);

        if (rules.DynamicRegistrationProviders != null &&
            !serviceType.IsExcludedGeneralPurposeServiceType() &&
            !IsWrapper(serviceType, openGenericServiceType))
            factories = CombineRegisteredServiceWithDynamicFactories(factories, serviceType, openGenericServiceType, serviceKey);

        if (factories.Length == 0)
            return null;

        if (serviceKey != null)
        {
            // simplified selection if we know that serviceKey is a default key
            if (serviceKey is DefaultKey | serviceKey is DefaultDynamicKey)
            {
                foreach (var f in factories)
                    if (f.Key.Equals(serviceKey))
                        return f.Value.CheckCondition(request) ? f.Value : null;
                return null;
            }

            // normal keys from the service Resolve or Injection, and not from the ResolveMany/GetArrayExpression 
            var multipleSameServiceKeySupport = Rules.HasMultipleSameServiceKeyForTheServiceType;
            if (multipleSameServiceKeySupport && serviceKey is not UniqueRegisteredServiceKey)
            {
                factories = factories.Match(details, request, static (d, r, x) =>
                    d.ServiceKey.MatchToNotNullRegisteredKey(x.Key) &&
                    r.MatchFactoryConditionAndMetadata(d, x.Value));
                if (factories.Length == 1)
                    return factories[0].Value;
            }
            else
            {
                // find first matching factory with the unique key (in absence of multiple keys rule)
                foreach (var f in factories)
                    if (serviceKey.MatchToNotNullRegisteredKey(f.Key) &&
                        f.Value.CheckCondition(request))
                        return f.Value;
                return null;
            }
        }
        else // serviceKey == null
        {
            factories = factories.Match(details, request, static (d, r, f) =>
                (f.Key is DefaultKey | f.Key is DefaultDynamicKey) &&
                r.MatchFactoryConditionAndMetadata(d, f.Value));
        }

        var initialMatchCount = factories.Length;
        if (initialMatchCount == 0)
            return null;

        // Check the for the reuse matching scopes (the check will be down the road) (BBIssue: #175)
        if (factories.Length > 1 && rules.ImplicitCheckForReuseMatchingScope)
        {
            KV<object, Factory> singleMatchedFactory = null;

            // todo: @wip split the MatchFactoryReuse and the FindFactoryWithTheMinReuseLifespanOrDefault checks, because first leads to the errors and seconds does not
            var reuseMatchedFactories = factories.Match(request, static (r, x) => r.MatchFactoryReuse(x.Value));
            if (reuseMatchedFactories.Length == 1)
                singleMatchedFactory = reuseMatchedFactories[0];
            else if (reuseMatchedFactories.Length > 1)
                singleMatchedFactory = FindFactoryWithTheMinReuseLifespanOrDefault(factories);

            if (singleMatchedFactory != null)
            {
                // Add asResolutionCall or change the serviceKey to prevent the caching of expression as default (BBIssue: #382)
                if (!request.IsResolutionCall)
                    singleMatchedFactory.Value.SetAsResolutionCall();
                else
                    request.ChangeServiceKey(singleMatchedFactory.Key);
                return singleMatchedFactory.Value; // we are done
            }
        }

        // Match open-generic implementation with closed service type. Performance is OK because the generated factories are cached -
        // so there should not be repeating of the check, and not match of Performance decrease.
        if (factories.Length > 1)
            factories = factories.Match(request, static (r, x) => r.MatchGeneratedFactory(x.Value));

        if (factories.Length > 1)
        {
            // prefer the factories with the condition (they should be evaluated / matched earlier anyway)
            var conditionedFactories = factories.Match(static f => f.Value.Setup.Condition != null);
            if (conditionedFactories.Length == 1)
                factories = conditionedFactories;
        }

        if (factories.Length > 1)
        {
            // prefer the factories with the `Setup.PreferInSingleServiceResolve`
            var preferredFactories = factories.Match(static f => f.Value.Setup.PreferInSingleServiceResolve);
            if (preferredFactories.Length == 1)
                factories = preferredFactories;
        }

        // The result is a single matched factory
        if (factories.Length == 1)
        {
            // Changes service key for resolution call to identify single factory in cache and prevent wrong hit
            if (initialMatchCount > 1 && request.IsResolutionCall)
                request.ChangeServiceKey(factories[0].Key);
            return factories[0].Value;
        }

        if (factories.Length > 1 && request.IfUnresolved == IfUnresolved.Throw)
            Throw.It(Error.ExpectedSingleDefaultFactory, factories, request);

        // Return null to allow fallback strategies
        return null;
    }

    private Factory GetRuleSelectedServiceFactoryOrDefault(Rules rules,
        ImHashMap<Type, object> serviceFactories, Request request, ServiceDetails details, Type serviceType)
    {
        // Hot path - a single factory, no dynamic rules
        var entry = serviceFactories.GetValueOrDefault(serviceType);
        var defaultFactory = entry as Factory;
        if (defaultFactory != null &&
            (rules.DynamicRegistrationProviders == null ||
            !rules.HasDynamicRegistrationProvider(DynamicRegistrationFlags.Service, withoutFlags: DynamicRegistrationFlags.AsFallback)))
            return !request.MatchFactoryConditionAndMetadata(details, defaultFactory)
                ? null
                : rules.IsSelectLastRegisteredFactory ? defaultFactory
                : rules.FactorySelector(request, defaultFactory, null);

        var openGenericServiceType = serviceType.GetGenericDefinitionOrNull();
        KV<object, Factory>[] factories;
        if (defaultFactory != null)
        {
            factories = new[] { new KV<object, Factory>(DefaultKey.Value, defaultFactory) }; // rare or never happens so no need to optimize
        }
        else if (entry is FactoriesEntry e)
        {
            factories = e.Factories.Match(static x => x.Value != null); // todo: @perf filter out the Unregistered factories
        }
        else // nothing concrete found, so try to find the open-generic
        {
            object openGenericEntry;
            factories = Empty<KV<object, Factory>>();
            if (openGenericServiceType != null)
            {
                openGenericEntry = serviceFactories.GetValueOrDefault(openGenericServiceType);
                if (openGenericEntry != null)
                    factories = openGenericEntry is Factory gf
                        ? new[] { new KV<object, Factory>(DefaultKey.Value, gf) }
                        : ((FactoriesEntry)openGenericEntry).Factories.Match(static x => x.Value != null); // filter out the Unregistered factories

                if (openGenericEntry == null && rules.VariantGenericTypesInResolve)
                {
                    foreach (var sf in serviceFactories.Enumerate())
                    {
                        if (sf.Value is Factory f)
                        {
                            if (serviceType.IsAssignableVariantGenericTypeFrom(sf.Key) &&
                                request.MatchFactoryConditionAndMetadata(details, f))
                            {
                                factories = KV.Of<object, Factory>(DefaultKey.Value, f).One();
                                break;
                            }
                        }
                        else
                        {
                            foreach (var kf in ((FactoriesEntry)sf.Value).Factories) // todo: @perf use Match
                                if (serviceType.IsAssignableVariantGenericTypeFrom(sf.Key) &&
                                    request.MatchFactoryConditionAndMetadata(details, kf.Value))
                                {
                                    factories = KV.Of(kf.Key, kf.Value).One();
                                    break;
                                }
                        }
                    }
                }
            }
        }

        if (rules.DynamicRegistrationProviders != null &&
            !serviceType.IsExcludedGeneralPurposeServiceType() && !IsWrapper(serviceType, openGenericServiceType))
            factories = CombineRegisteredServiceWithDynamicFactories(factories, serviceType, openGenericServiceType);

        if (factories.Length == 0)
            return null;

        // optimize for the case with the single factory
        if (factories.Length == 1)
            return request.MatchFactoryConditionAndMetadata(details, factories[0].Value)
                ? rules.FactorySelector(request, null, factories)
                : null;

        // Sort in registration order
        if (factories.Length > 1)
            Array.Sort(factories, _lastFactoryIDWinsComparer);

        var matchedFactories = factories.Match(request, details, static (r, d, x) => r.MatchFactoryConditionAndMetadata(d, x.Value));
        if (matchedFactories.Length > 1 && rules.ImplicitCheckForReuseMatchingScope)
        {
            // Check for the matching scopes. Only for more than one factory, 
            // for the single factory the check will be down the road (BBIssue #175)
            matchedFactories = matchedFactories.Match(request, static (r, x) => r.MatchFactoryReuse(x.Value));
            // Add asResolutionCall for the factory to prevent caching of in-lined expression in context with not matching condition (BBIssue #382)
            if (matchedFactories.Length == 1 && !request.IsResolutionCall)
                matchedFactories[0].Value.SetAsResolutionCall();
        }

        // Match open-generic implementation with closed service type. Performance is OK because the generated factories are cached -
        // so there should not be repeating of the check, and not match of Performance decrease.
        if (matchedFactories.Length > 1)
            matchedFactories = matchedFactories.Match(request, static (r, x) => r.MatchGeneratedFactory(x.Value));

        if (matchedFactories.Length == 0)
            return null;

        var selectedFactory = matchedFactories.Length == 1
            ? rules.FactorySelector(request, matchedFactories[0].Value, null)
            : rules.FactorySelector(request, null, matchedFactories);
        if (selectedFactory == null)
            return null;

        // BBIssue: #508, GHIssue: #350
        if (request.IsResolutionCall && factories.Length > 1)
        {
            var i = 0;
            while (i < matchedFactories.Length && matchedFactories[i].Value.FactoryID != selectedFactory.FactoryID)
                ++i;
            if (i < matchedFactories.Length)
                request.ChangeServiceKey(matchedFactories[i].Key);
        }

        return selectedFactory;
    }

    // Don't forget that we have the same public method Rules.SelectFactoryWithTheMinReuseLifespan
    private static KV<object, Factory> FindFactoryWithTheMinReuseLifespanOrDefault(KV<object, Factory>[] factories)
    {
        var minLifespan = int.MaxValue;
        var multipleFactories = false;
        KV<object, Factory> minLifespanFactory = null;

        foreach (var factory in factories)
        {
            var reuse = factory.Value.Reuse;
            var lifespan = reuse == null | reuse == Reuse.Transient ? int.MaxValue : reuse.Lifespan;
            if (lifespan == minLifespan)
            {
                multipleFactories = true;
            }
            else if (lifespan < minLifespan)
            {
                minLifespan = lifespan;
                minLifespanFactory = factory;
                multipleFactories = false;
            }
        }

        return !multipleFactories & minLifespanFactory != null ? minLifespanFactory : null;
    }

    ///  <inheritdoc />
    public KV<object, Factory>[] GetAllServiceFactoriesPlusForOpenGeneric(Type serviceType) // todo: @perf add the version with the serviceTypeHash parameter
    {
        var serviceFactories = Registry.GetServiceFactories(_registry.Value);
        var entry = serviceFactories.GetValueOrDefault(serviceType);

        var factories = FactoriesEntry.ToNotNullKeyedFactories(entry);

        Type openGenericServiceType = null;
        if (serviceType.IsClosedGeneric())
        {
            openGenericServiceType = serviceType.GetGenericTypeDefinition();
            var openGenericEntry = serviceFactories.GetValueOrDefault(openGenericServiceType);
            var openGenericFactories = FactoriesEntry.ToNotNullKeyedFactories(openGenericEntry);
            factories = factories.Append(openGenericFactories);
        }

        if (Rules.DynamicRegistrationProviders != null &&
            !serviceType.IsExcludedGeneralPurposeServiceType())
            return CombineRegisteredServiceWithDynamicFactories(factories, serviceType, openGenericServiceType);

        return factories;
    }

    internal static Factory[] MergeSortedByLatestOrderOrRegistration(Factory[] source, params Factory[] added)
    {
        if (added == null || added.Length == 0)
            return source;

        if (source == null || source.Length == 0)
            return added;

        var sourceLength = source.Length;
        var addedLength = added.Length;
        if (sourceLength == 1 && addedLength == 1)
        {
            var s = source[0];
            var a = added[0];
            var sOrder = ((Setup.DecoratorSetup)s.Setup).Order;
            var aOrder = ((Setup.DecoratorSetup)a.Setup).Order;
            if (sOrder > aOrder || sOrder == aOrder && s.RegistrationOrder > a.RegistrationOrder)
                return new Factory[] { s, a };
            return new Factory[] { a, s };
        }

        var result = new Factory[sourceLength + addedLength];

        var i = 0;
        var j = 0;
        for (var k = 0; k < result.Length; ++k)
        {
            if (i < sourceLength & j < addedLength)
            {
                var s = source[i];
                var a = added[j];
                var sOrder = ((Setup.DecoratorSetup)s.Setup).Order;
                var aOrder = ((Setup.DecoratorSetup)a.Setup).Order;
                if (sOrder > aOrder || sOrder == aOrder && s.RegistrationOrder > a.RegistrationOrder)
                {
                    result[k] = s;
                    ++i;
                }
                else
                {
                    result[k] = a;
                    ++j;
                }
            }
            else if (i < sourceLength)
            {
                result[k] = source[i++];
            }
            else
            {
                result[k] = added[j++];
            }
        }

        return result;
    }

    private static int _objectTypeHash = RuntimeHelpers.GetHashCode(typeof(object));

    /// <inheritdoc />
    public KV<object, Factory>[] GetAllServiceFactories(Type serviceType) // todo @perf pass the serviceTypeHash
    {
        var serviceFactories = Registry.GetServiceFactories(_registry.Value);
        var entry = serviceFactories.GetValueOrDefault(serviceType);

        var factories = FactoriesEntry.ToNotNullKeyedFactories(entry);

        if (Rules.DynamicRegistrationProviders != null &&
            !serviceType.IsExcludedGeneralPurposeServiceType())
            return CombineRegisteredServiceWithDynamicFactories(factories, serviceType, null);

        return factories;
    }

    /// <inheritdoc />
    public Expression GetDecoratorExpressionOrDefault(Request request)
    {
        // return early if no decorators registered
        var r = _registry.Value as Registry;
        if ((r == null || r.Decorators.IsEmpty) &&
            (Rules.DynamicRegistrationProviders == null ||
            !Rules.HasDynamicRegistrationProvider(DynamicRegistrationFlags.Decorator))) // todo: @perf reuse its result
            return null;

        var arrayElementType = request.ServiceType.GetArrayElementTypeOrNull();
        if (arrayElementType != null)
            request = request.WithChangedType(arrayElementType, static (_, et) => typeof(IEnumerable<>).MakeGenericType(et)); // todo: @simplify try to remove this method

        var serviceType = request.ServiceType;
        var decorators = GetDecoratorFactoriesOrDefault(serviceType);
        var originalDecorators = decorators;

        // Combine with required service type if different from service type
        var requiredServiceType = request.ActualServiceType;
        if (requiredServiceType != serviceType)
            decorators = Container.MergeSortedByLatestOrderOrRegistration(decorators, GetDecoratorFactoriesOrDefault(requiredServiceType));

        // Define the list of ids for the already applied decorators
        int[] appliedDecoratorIDs = null;
        if (!decorators.IsNullOrEmpty()) // todo: @perf check earlier for `p.DirectParent.IsEmpty && p.DirectParent.FactoryType != FactoryType.Service` to avoid method calling and check inside
        {
            appliedDecoratorIDs = GetAppliedDecoratorIDs(request);
            if (appliedDecoratorIDs.Length != 0)
                decorators = decorators.Match(appliedDecoratorIDs, (ids, d) =>
                {
                    var id = d.FactoryID;
                    for (var i = 0; i < ids.Length; ++i)
                        if (id == ids[i])
                            return false;
                    return true;
                });
        }

        // Append open-generic decorators
        var genericDecorators = Empty<Factory>();
        var openGenericServiceType = serviceType.GetGenericDefinitionOrNull();
        if (openGenericServiceType != null)
            genericDecorators = GetDecoratorFactoriesOrDefault(openGenericServiceType);

        // Combine with open-generic required type if they are different from service type
        if (requiredServiceType != serviceType)
        {
            var openGenericRequiredType = requiredServiceType.GetGenericDefinitionOrNull();
            if (openGenericRequiredType != null && openGenericRequiredType != openGenericServiceType)
                genericDecorators = Container.MergeSortedByLatestOrderOrRegistration(genericDecorators,
                    GetDecoratorFactoriesOrDefault(openGenericRequiredType));
        }

        // Append generic type argument decorators, registered as Object
        // Note: the condition for type arguments should be checked before generating the closed generic version
        // Note: the dynamic rules for the object is not supported, sorry - too much of performance hog to be called every time
        var typeArgDecorators = GetDecoratorFactoriesOrDefault(_objectTypeHash, typeof(object)) as Factory[];
        if (!typeArgDecorators.IsNullOrEmpty())
            genericDecorators = Container.MergeSortedByLatestOrderOrRegistration(genericDecorators,
                typeArgDecorators.Match(request, static (r, d) => d.CheckCondition(r)));

        // Filter out already applied generic decorators
        // And combine with rest of decorators
        if (!genericDecorators.IsNullOrEmpty())
        {
            appliedDecoratorIDs = appliedDecoratorIDs ?? GetAppliedDecoratorIDs(request);
            if (!appliedDecoratorIDs.IsNullOrEmpty())
            {
                genericDecorators = genericDecorators.Match(appliedDecoratorIDs,
                    static (appliedDecIds, d) =>
                    {
                        var generatedFactories = d.GeneratedFactories;
                        if (generatedFactories == null)
                            return appliedDecIds.IndexOf(d.FactoryID) == -1;

                        foreach (var entry in generatedFactories.Enumerate())
                            if (appliedDecIds.IndexOf(entry.Value.FactoryID) != -1)
                                return false;

                        return true;
                    });
            }

            // Generate closed-generic versions
            if (!genericDecorators.IsNullOrEmpty())
            {
                genericDecorators = genericDecorators
                    .Map(request, static (r, d) => d.GeneratedFactories == null ? d : d.GetGeneratedFactoryOrDefault(r, ifErrorReturnDefault: true))
                    .Match(static d => d != null);
                decorators = Container.MergeSortedByLatestOrderOrRegistration(decorators, genericDecorators);
            }
        }

        // Filter out the recursive decorators by doing the same recursive check
        // that Request.WithResolvedFactory does. Fixes: #267
        if (!decorators.IsNullOrEmpty())
            decorators = decorators.Match(request, static (r, d) => !r.HasRecursiveParent(d.FactoryID));

        // Return earlier if no decorators or every decorator was filtered out
        if (decorators.IsNullOrEmpty())
            return null;

        // Select the first decorator without condition or the one which matches the condition
        // Iterate over all decorators and prevent caching if any of them has the condition,
        // because no matter if condition is true or false, we need a fresh chain of decorators
        Factory firstMatchingDecorator = null;
        foreach (var d in decorators)
        {
            var cond = d.Setup.Condition;
            if (cond != null || d.Setup.UseDecorateeReuse)
                request.Flags |= RequestFlags.DoNotCacheExpression;

            if (firstMatchingDecorator == null &&
                (cond == null || cond(request.Isolate())))
                firstMatchingDecorator = d;
        }

        var decoratorExpr = firstMatchingDecorator?.GetExpressionOrDefault(request);
        if (decoratorExpr == null)
            return null;

        // decorator of arrays should be converted back from IEnumerable to array.
        if (arrayElementType != null)
            decoratorExpr = Call(WrappersSupport.ToArrayMethod.MakeGenericMethod(arrayElementType), decoratorExpr);

        return decoratorExpr;
    }

    private static int[] GetAppliedDecoratorIDs(Request request)
    {
        var requestFactoryID = request.FactoryID;
        var appliedIDs = Empty<int>();
        for (var p = request.DirectParent; !p.IsEmpty && p.FactoryType != FactoryType.Service; p = p.DirectParent)
            if (p.FactoryType == FactoryType.Decorator && p.DecoratedFactoryID == requestFactoryID)
                appliedIDs = appliedIDs.Append(p.FactoryID);
        return appliedIDs;
    }

    /// <inheritdoc />
    public Factory GetWrapperFactoryOrDefault(Type serviceType)
    {
        var r = _registry.Value as Registry;
        var wrappers = r != null ? r.Wrappers : WrappersSupport.Wrappers;
        var wrapper = wrappers.GetValueOrDefault(serviceType);
        if (wrapper == null)
        {
            serviceType = serviceType.GetGenericDefinitionOrNull();
            if (serviceType != null)
                wrapper = wrappers.GetValueOrDefault(serviceType);
        }
        return wrapper as Factory;
    }

    /// <inheritdoc />
    public bool IsWrapper(Type serviceType, Type openGenericServiceType)
    {
        if (serviceType.IsArray)
            return true;
        var r = _registry.Value as Registry;
        var wrappers = r != null ? r.Wrappers : WrappersSupport.Wrappers;
        return wrappers.GetValueOrDefault(serviceType) != null // todo: @perf reorder things to get faster results for the open-generic wrappers - for the rest perf won't change 
            || openGenericServiceType != null && wrappers.GetValueOrDefault(openGenericServiceType) != null;
    }

    /// <inheritdoc />
    public Factory[] GetDecoratorFactoriesOrDefault(Type serviceType)
    {
        var decorators = _registry.Value is Registry r
            ? (Factory[])r.Decorators.GetValueOrDefault(serviceType)
            : null;

        if (Rules.DynamicRegistrationProviders != null)
            return CombineRegisteredDecoratorWithDynamicFactories(decorators, serviceType);

        return decorators;
    }

    /// <inheritdoc />
    public Factory[] GetDecoratorFactoriesOrDefault(int serviceTypeHash, Type serviceType)
    {
        var decorators = _registry.Value is Registry r
            ? (Factory[])r.Decorators.GetValueOrDefault(serviceTypeHash, serviceType)
            : null;

        if (Rules.DynamicRegistrationProviders != null)
            return CombineRegisteredDecoratorWithDynamicFactories(decorators, serviceType);

        return decorators;
    }

    /// <inheritdoc />
    public Type GetWrappedType(Type serviceType, Type requiredServiceType)
    {
        if (requiredServiceType != null && requiredServiceType.IsOpenGeneric())
            return GetWrappedType(serviceType, null);

        serviceType = requiredServiceType ?? serviceType;

        var wrappedType = serviceType.GetArrayElementTypeOrNull();
        if (wrappedType == null)
        {
            var factory = GetWrapperFactoryOrDefault(serviceType);
            if (factory != null)
                wrappedType = ((Setup.WrapperSetup)factory.Setup).GetWrappedTypeOrNullIfWrapsRequired(serviceType);
        }
        return wrappedType == null ? serviceType : GetWrappedType(wrappedType);
    }

    // todo @perf optimize lambda allocations and parameter usage
    /// <summary>Converts known item into literal expression or wraps it in a constant expression.</summary>
    public Expression GetConstantExpression(object item, Type itemType = null, bool throwIfStateRequired = false)
    {
        if (!throwIfStateRequired && Rules.ConstantExpressionIsFine)
            return itemType == null ? Constant(item) : Constant(item, itemType);

        if (item == null)
            return ConstantNull(itemType);

        if (item is Type t)
            return ConstantOf(t);

        if (item is IConvertibleToExpression convertible)
            return ConvertConstantToExpression(convertible, throwIfStateRequired);

        var actualItemType = item.GetType();
        if (actualItemType.GetGenericDefinitionOrNull() == typeof(KV<,>))
        {
            var kvArgTypes = actualItemType.GetGenericArguments();
            return Call(_kvOfMethod.MakeGenericMethod(kvArgTypes),
                GetConstantExpression(actualItemType.GetField("Key").GetValue(item), kvArgTypes[0], throwIfStateRequired),
                GetConstantExpression(actualItemType.GetField("Value").GetValue(item), kvArgTypes[1], throwIfStateRequired));
        }

        if (actualItemType.IsPrimitive() || typeof(Type).IsAssignableFrom(actualItemType))
            return itemType == null ? Constant(item) : Constant(item, itemType);

        // don't try to recover the non primitive type of element,
        // cause it is a too much work to find the base common element type in array
        var arrayElemType = actualItemType.GetArrayElementTypeOrNull();
        if (arrayElemType != null && arrayElemType != typeof(object) &&
            (arrayElemType.IsPrimitive() || typeof(Type).IsAssignableFrom(actualItemType)))
            return NewArrayInit(arrayElemType,
                throwIfStateRequired
                    ? ((object[])item).Map(this, arrayElemType, static (c, t, x) => c.GetConstantExpression(x, t, true))
                    : ((object[])item).Map(this, arrayElemType, static (c, t, x) => c.GetConstantExpression(x, t, false)));

        var itemExpr = Rules.ItemToExpressionConverter?.Invoke(item, itemType);
        if (itemExpr != null)
            return itemExpr;

        if (throwIfStateRequired || Rules.ThrowIfRuntimeStateRequired)
            Throw.StateIsRequiredToUseItem(item, itemType);
        return itemType == null ? Constant(item) : Constant(item, itemType);
    }

    private Expression ConvertConstantToExpression(IConvertibleToExpression convertible, bool throwIfStateRequired) =>
        throwIfStateRequired
            ? convertible.ToExpression(this, static (c, it) => c.GetConstantExpression(it, null, true))
            : convertible.ToExpression(this, static (c, it) => c.GetConstantExpression(it, null, false));

    private static readonly MethodInfo _kvOfMethod = typeof(KV).GetMethod(nameof(KV.Of));

    #endregion

    #region Factories Add/Get

    internal sealed class FactoriesEntry
    {
        public static KV<object, Factory>[] ToNotNullKeyedFactories(object factoryOrFactoryEntry)
        {
            return factoryOrFactoryEntry == null ? Empty<KV<object, Factory>>()
                : factoryOrFactoryEntry is Factory factory ? new[] { new KV<object, Factory>(DefaultKey.Value, factory) }
                : ((FactoriesEntry)factoryOrFactoryEntry).Factories
                    // filter out the Unregistered factories (see #390)
                    .Match(static x => x.Value != null); // // @perf here?
        }

        public readonly DefaultKey LastDefaultKey;
        public readonly KV<object, Factory>[] Factories; // todo: @perf convert KV to struct, c?

        // lastDefaultKey may be null
        public FactoriesEntry(DefaultKey lastDefaultKey, KV<object, Factory>[] factories)
        {
            LastDefaultKey = lastDefaultKey;
            Factories = factories;
        }

        public static readonly FactoriesEntry Empty = new FactoriesEntry(null, null);

        [MethodImpl((MethodImplOptions)256)]
        public FactoriesEntry WithDefault(Factory factory, DefaultKey newLastDefaultKey) =>
            new FactoriesEntry(newLastDefaultKey, Factories.Append(new KV<object, Factory>(newLastDefaultKey, factory)));

        [MethodImpl((MethodImplOptions)256)]
        public FactoriesEntry WithDefault(Factory factory) =>
            WithDefault(factory, LastDefaultKey == null ? DefaultKey.Value : LastDefaultKey.Next());

        public FactoriesEntry WithTwoDefault(Factory oldFactory, Factory newFactory)
        {
            var lastDefaultKey = LastDefaultKey == null ? DefaultKey.Value : LastDefaultKey.Next();
            var keyFac0 = new KV<object, Factory>(lastDefaultKey, oldFactory);
            var keyFac1 = new KV<object, Factory>(lastDefaultKey = lastDefaultKey.Next(), newFactory);
            return new FactoriesEntry(lastDefaultKey, Factories.Append(new[] { keyFac0, keyFac1 }));
        }

        // todo: @perf
        public FactoriesEntry With(Factory factory, object serviceKey)
        {
            var keyFac = KV.Of(serviceKey, factory);

            if (Factories == null || Factories.Length == 0)
                return new FactoriesEntry(serviceKey as DefaultKey, new[] { keyFac });

            // starting from the last added factories...
            for (var i = Factories.Length - 1; i >= 0; --i)
            {
                var f = Factories[i];
                if (f.Key is not Registrator.AnyServiceKey && f.Key.Equals(serviceKey))
                    return new FactoriesEntry(LastDefaultKey, Factories.UpdateNonEmpty(keyFac, i));
            }

            var ldk = LastDefaultKey;
            if (serviceKey is DefaultKey dk)
                ldk = ldk == null ? dk : dk.RegistrationOrder > ldk.RegistrationOrder ? dk : ldk;
            return new FactoriesEntry(ldk, Factories.AppendToNonEmpty(keyFac));
        }

        public KV<object, Factory> GetFirstKeyedOrDefault(object serviceKey)
        {
            var isAnyServiceKey = serviceKey is Registrator.AnyServiceKey;
            if (Factories != null)
                foreach (var f in Factories)
                {
                    if (f.Key is Registrator.AnyServiceKey)
                    {
                        if (isAnyServiceKey)
                            return f;
                        continue;
                    }
                    if (f.Key.Equals(serviceKey))
                        return f;
                }
            return default;
        }

        public int GetLastKeyedIndex(object serviceKey)
        {
            var isAnyServiceKey = serviceKey is Registrator.AnyServiceKey;
            if (Factories != null)
                for (var i = Factories.Length - 1; i >= 0; --i)
                {
                    var f = Factories[i];
                    if (f.Key is Registrator.AnyServiceKey)
                    {
                        if (isAnyServiceKey)
                            return i;
                        continue;
                    }
                    if (f.Key.Equals(serviceKey))
                        return i;
                }
            return -1;
        }

        [MethodImpl((MethodImplOptions)256)]
        public KV<object, Factory> GetLastKeyedOrDefault(object serviceKey)
        {
            var i = GetLastKeyedIndex(serviceKey);
            return i != -1 ? Factories[i] : default;
        }
    }

    /// <inheritdoc />
    public Type GetWrappedType(Type serviceType)
    {
        var wrappedType = serviceType.GetArrayElementTypeOrNull();
        if (wrappedType == null)
        {
            var factory = GetWrapperFactoryOrDefault(serviceType);
            if (factory != null)
                wrappedType = ((Setup.WrapperSetup)factory.Setup).GetWrappedTypeOrNullIfWrapsRequired(serviceType);
        }
        return wrappedType == null ? serviceType : GetWrappedType(wrappedType);
    }

    private static readonly LastFactoryIDWinsComparer _lastFactoryIDWinsComparer = new LastFactoryIDWinsComparer();
    private struct LastFactoryIDWinsComparer : IComparer<KV<object, Factory>>
    {
        public int Compare(KV<object, Factory> first, KV<object, Factory> next) =>
            (first?.Value.FactoryID ?? 0) - (next?.Value.FactoryID ?? 0);
    }

    private Factory GetWrapperFactoryOrDefault(Request request) // todo: @perf the candidate for inlining and simplification
    {
        // wrapper ignores the service key, and propagate the service key to wrapped service
        var serviceType = request.ActualServiceType;
        var itemType = serviceType.GetArrayElementTypeOrNull();
        if (itemType != null)
            serviceType = typeof(IEnumerable<>).MakeGenericType(itemType);

        var factory = GetWrapperFactoryOrDefault(serviceType);
        if (factory?.GeneratedFactories != null)
            factory = factory.GetGeneratedFactoryOrDefault(request);

        return factory != null && factory.CheckCondition(request) ? factory : null;
    }

    #endregion

    #region Implementation

    internal readonly Ref<ImHashMap<Type, object>> _registry; // either map of Services or the Registry class
    private readonly IScope _singletonScope;
    private readonly IDisposable _ownScopeOrContext; // null, or IScope or IScopeContext
    private readonly IResolverContext _parent; // if (_parent is not null) then _ownScopeOrContext is not null for sure, but it can only be a ScopeContext or null for the parent-less container, think about it 
    private StackTrace _disposeStackTrace;
    private int _disposed;

    // todo: @perf split into with and without the serviceKey
    private KV<object, Factory>[] CombineRegisteredServiceWithDynamicFactories(
        KV<object, Factory>[] factories, Type serviceType, Type openGenericServiceType, object serviceKey = null)
    {
        var withFlags = DynamicRegistrationFlags.Service;
        var withoutFlags = factories.Length != 0 ? DynamicRegistrationFlags.AsFallback : DynamicRegistrationFlags.NoFlags;

        // Assign unique continuous keys across all of the dynamic providers,
        // to prevent duplicate keys and peeking the wrong factory by collection wrappers
        // NOTE: Given that dynamic registration always return the same implementation types in the same order
        // then the dynamic key will be assigned deterministically, so that even if `CombineRegisteredWithDynamicFactories`
        // is called multiple times during the resolution (like for `ResolveMany`) it is possible to match the required factory by its order.
        DefaultDynamicKey dynamicKey = null;

        var dynamicFlags = Rules.DynamicRegistrationFlags;
        for (var i = 0; i < dynamicFlags.Length; ++i)
        {
            var flag = dynamicFlags[i];
            if ((flag & withFlags) != withFlags | (flag & withoutFlags) != 0)
                continue;

            var dynamicRegistrationProvider = Rules.DynamicRegistrationProviders[i];
            var dynamicRegistrations = dynamicRegistrationProvider(serviceType, serviceKey).ToArrayOrSelf();

        restartWithOpenGenericRegistrations:
            if (dynamicRegistrations.Length != 0)
            {
                if (factories.Length == 0)
                    foreach (var x in dynamicRegistrations)
                    {
                        var d = x.Factory;
                        if (d.FactoryType == FactoryType.Service && d.ValidateAndNormalizeRegistration(serviceType, serviceKey, false, Rules, true))
                            factories = factories.Append(KV.Of(x.ServiceKey ?? (dynamicKey = dynamicKey?.Next() ?? DefaultDynamicKey.Value), d));
                    }
                else
                {
                    foreach (var x in dynamicRegistrations)
                    {
                        var d = x.Factory;
                        if (d.FactoryType != FactoryType.Service || !d.ValidateAndNormalizeRegistration(serviceType, serviceKey, false, Rules, true))
                            continue; // skip non-relevant factory types and invalid factories

                        if (x.ServiceKey == null) // for the default dynamic factory
                            switch (x.IfAlreadyRegistered)
                            {
                                case IfAlreadyRegistered.Keep: // accept the default if result factories don't contain it already
                                case IfAlreadyRegistered.Throw:
                                    if (factories.IndexOf(static f => f.Key is DefaultKey || f.Key is DefaultDynamicKey) != -1)
                                        continue; // skip if the factories are already containing the default factory
                                    break;

                                case IfAlreadyRegistered.Replace: // remove the default from the result factories
                                    factories = factories.Match(static f => !(f.Key is DefaultKey || f.Key is DefaultDynamicKey));
                                    break;

                                case IfAlreadyRegistered.AppendNotKeyed:
                                    break;

                                case IfAlreadyRegistered.AppendNewImplementation:
                                    if (d.CanAccessImplementationType &&
                                        factories.IndexOf(d.ImplementationType, static (it, f) => f.Value.CanAccessImplementationType && f.Value.ImplementationType == it) != -1)
                                        continue; // skip if the factories contains the factory with the same dynamic implementation type
                                    break;
                            }
                        else // for the keyed dynamic factory
                            switch (x.IfAlreadyRegistered)
                            {
                                case IfAlreadyRegistered.Replace:
                                    factories = factories.Match(x.ServiceKey, static (k, f) => !f.Key.Equals(k));
                                    break; // remove from the factories the factory with the same key

                                default:
                                    if (factories.IndexOf(x.ServiceKey, static (k, f) => f.Key.Equals(k)) != -1)
                                        continue; // keep the dynamic factory with the new service key, otherwise skip it
                                    break;
                            }

                        factories = factories.Append(KV.Of(x.ServiceKey ?? (dynamicKey = dynamicKey?.Next() ?? DefaultDynamicKey.Value), d));
                    }
                }
            }

            if (openGenericServiceType != null) // todo: @bug check if we need todo that for  AsFallback
            {
                dynamicRegistrations = dynamicRegistrationProvider(openGenericServiceType, serviceKey).ToArrayOrSelf();
                openGenericServiceType = null; // prevent the infinite loop
                goto restartWithOpenGenericRegistrations;
            }
        }
        return factories;
    }

    private KV<object, Factory>[] CombineRegisteredServiceWithDynamicFactories(
        KV<object, Factory>[] factories, Type serviceType, Type openGenericServiceType)
    {
        var withFlags = DynamicRegistrationFlags.Service;
        var withoutFlags = factories.Length != 0 ? DynamicRegistrationFlags.AsFallback : DynamicRegistrationFlags.NoFlags;

        // Assign unique continuous keys across all of dynamic providers,
        // to prevent duplicate keys and peeking the wrong factory by collection wrappers
        // NOTE: Given that dynamic registration always return the same implementation types in the same order
        // then the dynamic key will be assigned deterministically, so that even if `CombineRegisteredWithDynamicFactories`
        // is called multiple times during the resolution (like for `ResolveMany` ???) it is possible to match the required factory by its order.
        DefaultDynamicKey dynamicKey = null;

        var dynamicFlags = Rules.DynamicRegistrationFlags;
        for (var i = 0; i < dynamicFlags.Length; ++i)
        {
            var flag = dynamicFlags[i];
            if ((flag & withFlags) != withFlags | (flag & withoutFlags) != 0)
                continue;

            var dynamicRegistrationProvider = Rules.DynamicRegistrationProviders[i];
            var dynamicRegistrations = dynamicRegistrationProvider(serviceType, null).ToArrayOrSelf();

        restartWithOpenGenericRegistrations:
            if (dynamicRegistrations.Length != 0)
            {
                if (factories.Length == 0)
                    foreach (var x in dynamicRegistrations)
                    {
                        var d = x.Factory;
                        if (d.FactoryType == FactoryType.Service && d.ValidateAndNormalizeRegistration(serviceType, null, false, Rules, true))
                            factories = factories.Append(KV.Of(x.ServiceKey ?? (dynamicKey = dynamicKey?.Next() ?? DefaultDynamicKey.Value), d));
                    }
                else
                {
                    foreach (var x in dynamicRegistrations)
                    {
                        var d = x.Factory;
                        if (d.FactoryType != FactoryType.Service || !d.ValidateAndNormalizeRegistration(serviceType, null, false, Rules, true))
                            continue; // skip non-relevant factory types and invalid factories

                        if (x.ServiceKey == null) // for the default dynamic factory
                            switch (x.IfAlreadyRegistered)
                            {
                                case IfAlreadyRegistered.Keep: // accept the default if result factories don't contain it already
                                case IfAlreadyRegistered.Throw:
                                    if (factories.IndexOf(static f => f.Key is DefaultKey || f.Key is DefaultDynamicKey) != -1)
                                        continue; // skip if the factories are already containing the default factory
                                    break;

                                case IfAlreadyRegistered.Replace: // remove the default from the result factories
                                    factories = factories.Match(static f => !(f.Key is DefaultKey || f.Key is DefaultDynamicKey));
                                    break;

                                case IfAlreadyRegistered.AppendNotKeyed:
                                    break;

                                case IfAlreadyRegistered.AppendNewImplementation:
                                    if (d.CanAccessImplementationType &&
                                        factories.IndexOf(d.ImplementationType, static (it, f) => f.Value.CanAccessImplementationType && f.Value.ImplementationType == it) != -1)
                                        continue; // skip if the factories contains the factory with the same dynamic implementation type
                                    break;
                            }
                        else // for the keyed dynamic factory
                            switch (x.IfAlreadyRegistered)
                            {
                                case IfAlreadyRegistered.Replace:
                                    factories = factories.Match(x.ServiceKey, static (k, f) => !f.Key.Equals(k));
                                    break; // remove from the factories the factory with the same key

                                default:
                                    if (factories.IndexOf(x.ServiceKey, static (k, f) => f.Key.Equals(k)) != -1)
                                        continue; // keep the dynamic factory with the new service key, otherwise skip it
                                    break;
                            }

                        factories = factories.Append(KV.Of(x.ServiceKey ?? (dynamicKey = dynamicKey?.Next() ?? DefaultDynamicKey.Value), d));
                    }
                }
            }

            if (openGenericServiceType != null) // todo: @bug check if we need todo that for AsFallback
            {
                dynamicRegistrations = dynamicRegistrationProvider(openGenericServiceType, null).ToArrayOrSelf();
                openGenericServiceType = null; // prevent the infinite loop
                goto restartWithOpenGenericRegistrations;
            }
        }
        return factories;
    }

    private Factory[] CombineRegisteredDecoratorWithDynamicFactories(Factory[] factories, Type serviceType)
    {
        var withFlags = DynamicRegistrationFlags.Decorator;
        if (serviceType == typeof(object))
            withFlags |= DynamicRegistrationFlags.DecoratorOfAnyTypeViaObjectServiceType;

        var withoutFlags = factories != null ? DynamicRegistrationFlags.AsFallback : DynamicRegistrationFlags.NoFlags;

        var dynamicFlags = Rules.DynamicRegistrationFlags;
        for (var i = 0; i < dynamicFlags.Length; ++i)
        {
            var flag = dynamicFlags[i];
            if ((flag & withFlags) != withFlags || (flag & withoutFlags) != 0)
                continue;

            var dynamicRegistrationProvider = Rules.DynamicRegistrationProviders[i];
            var dynamicRegistrations = dynamicRegistrationProvider(serviceType, null).ToArrayOrSelf();
            if (dynamicRegistrations.IsNullOrEmpty())
                continue;

            if (factories.IsNullOrEmpty())
            {
                foreach (var x in dynamicRegistrations)
                {
                    var d = x.Factory;
                    if (d.FactoryType == FactoryType.Decorator && d.ValidateAndNormalizeRegistration(serviceType, null, false, Rules, true))
                        factories = factories.Append(d);
                }
                continue;
            }

            foreach (var x in dynamicRegistrations)
            {
                var d = x.Factory;
                if (d.FactoryType != FactoryType.Decorator || !d.ValidateAndNormalizeRegistration(serviceType, null, false, Rules, true))
                    continue; // skip non-relevant factory types and invalid factories

                switch (x.IfAlreadyRegistered)
                {
                    case IfAlreadyRegistered.Keep:
                    case IfAlreadyRegistered.Throw:
                        continue;

                    case IfAlreadyRegistered.Replace:
                        factories = Empty<Factory>(); // remove the default from the result factories
                        break;

                    case IfAlreadyRegistered.AppendNotKeyed:
                        break;

                    case IfAlreadyRegistered.AppendNewImplementation:
                        if (d.CanAccessImplementationType &&
                            factories.IndexOf(d.ImplementationType, static (it, f) => f.CanAccessImplementationType && f.ImplementationType == it) != -1)
                            continue; // skip if the factories contains the factory with the same dynamic implementation type
                        break;
                }
                factories = factories.Append(d);
            }
        }

        return factories;
    }

    internal void TryCacheDefaultFactoryDelegateOrExprOrResult(int serviceTypeHash, Type serviceType, object factory)
    {
        var registryOrServices = _registry.Value;
        var registry = registryOrServices as Registry;
        if (registry == null ? registryOrServices.IsEmpty : registry.Services.IsEmpty)
            return; // disable caching when no services registered, not to cache an empty collection wrapper or alike.

        var withCache = (Registry.AndDefaultCache)(
            (registry as Registry.AndDefaultCache)?.WithDefaultFactoryCache() ??
            _registry.SwapAndGetNewValue(static r => r is Registry reg ? reg.WithDefaultFactoryCache() : Registry.NewWithDefaultFactoryCache(r)));

        ref var map = ref withCache._defaultFactoryCache[serviceTypeHash & Registry.CACHE_SLOT_COUNT_MASK];
        if (map == null)
            Interlocked.CompareExchange(ref map, ImHashMap<Type, object>.Empty, null);

        var m = map;
        if (Interlocked.CompareExchange(ref map, m.AddOrUpdateByReferenceEquals(serviceTypeHash, serviceType, factory), m) != m)
            Ref.Swap(ref map, serviceTypeHash, serviceType, factory, static (x, h, t, f) => x.AddOrUpdateByReferenceEquals(h, t, f));
    }

    internal void TryCacheKeyedFactoryDelegateOrExprOrResult(int serviceTypeHash, Type serviceType, object key, object factory)
    {
        // Disable caching when no services registered, not to cache an empty collection wrapper or alike.
        var registryOrServices = _registry.Value;
        var registry = registryOrServices as Registry;
        if (registry == null ? registryOrServices.IsEmpty : registry.Services.IsEmpty)
            return;

        var withCache = (Registry.AndCache)(
            (registry as Registry.AndCache)?.WithKeyedFactoryCache() ??
            (Registry.AndCache)_registry.SwapAndGetNewValue(r =>
                r is Registry reg ? reg.WithKeyedFactoryCache() : Registry.NewWithKeyedFactoryCache(r)));

        ref var map = ref withCache._keyedFactoryCache[serviceTypeHash & Registry.CACHE_SLOT_COUNT_MASK];
        if (map == null)
            Interlocked.CompareExchange(ref map, ImHashMap<Type, object>.Empty, null);

        var entry = map.GetEntryOrDefaultByReferenceEquals(serviceTypeHash, serviceType);
        if (entry == null)
        {
            entry = ImHashMap.EntryWithDefaultValue<Type, object>(serviceTypeHash, serviceType);
            var oldMap = map;
            var newMap = oldMap.AddOrKeepEntryByReferenceEquals(entry);
            if (Interlocked.CompareExchange(ref map, newMap, oldMap) != oldMap)
                entry = Ref.SwapAndGetNewValue(ref map, entry, static (x, en) => x.AddOrKeepEntryByReferenceEquals(en)).GetSurePresentByReferenceEquals(serviceTypeHash, serviceType);
            else if (newMap == oldMap)
                entry = map.GetSurePresentByReferenceEquals(serviceTypeHash, serviceType);
        }

        var e = entry.Value;
        if (Interlocked.CompareExchange(ref entry.Value, Registry.SetOrAddKeyedCacheFactory(e, key, factory), e) != e)
            Ref.Swap(ref entry.Value, key, factory, Registry.SetOrAddKeyedCacheFactory);
    }

    internal ImHashMapEntry<int, object> CacheFactoryExpression(int factoryId)
    {
        var withCache = (Registry.AndDefaultCache)(
            (_registry.Value as Registry.AndDefaultCache)?.WithFactoryExpressionCache() ??
            (Registry.AndDefaultCache)_registry.SwapAndGetNewValue(static r =>
                r is Registry reg ? reg.WithFactoryExpressionCache() : Registry.NewWithFactoryExpressionCache(r)));

        ref var map = ref withCache._factoryExpressionCache[factoryId & Registry.CACHE_SLOT_COUNT_MASK];
        if (map == null)
            Interlocked.CompareExchange(ref map, ImHashMap<int, object>.Empty, null);

        var entry = map.GetEntryOrDefault(factoryId);
        if (entry == null)
        {
            entry = ImHashMap.EntryWithDefaultValue<object>(factoryId);
            var oldMap = map;
            var newMap = oldMap.AddOrKeepEntry(entry);
            if (Interlocked.CompareExchange(ref map, newMap, oldMap) != oldMap)
                entry = Ref.SwapAndGetNewValue(ref map, entry, static (x, e) => x.AddOrKeepEntry(e)).GetSurePresent(factoryId);
            else if (newMap == oldMap)
                entry = map.GetSurePresent(factoryId);
        }
        return entry;
    }

    internal sealed class ExprCacheOfTransientWithDepCount
    {
        public Expression Expr;
        public int Count;
        public ExprCacheOfTransientWithDepCount(Expression e, int n) { Expr = e; Count = n; }
    }

    internal sealed class ExprCacheOfScopedWithName
    {
        public Expression Expr;
        public object Name;
        public ExprCacheOfScopedWithName(Expression e, object n) { Expr = e; Name = n; }
    }

    // Strange but convenient - the registry is derived from the empty ImHashMap in order to slightly improve type information to represent both Services ImHashMap and the Registry with Services, cache, etc.
    internal class Registry : ImHashMap<Type, object>
    {
        public static readonly ImHashMap<Type, object> Default = ImHashMap<Type, object>.Empty;

        public readonly ImHashMap<Type, object> Services;
        public virtual ImHashMap<Type, object> Wrappers => WrappersSupport.Wrappers; // value is Factory 
        public virtual ImHashMap<Type, object> Decorators => ImHashMap<Type, object>.Empty; // value is Factory[]  // todo: @perf make it Factory or Factory[]

        internal const int CACHE_SLOT_COUNT = 16; // todo: @perf using the fixed array buffer on stack
        internal const int CACHE_SLOT_COUNT_MASK = CACHE_SLOT_COUNT - 1;

        public virtual ImHashMap<Type, object>[] DefaultFactoryCache => null;

        // Where key is `KV.Of(ServiceKey | ScopeName | RequiredServiceType | KV.Of(ServiceKey, ScopeName | RequiredServiceType) | ...)`
        // and value is `KeyedFactoryCacheEntries`
        public virtual ImHashMap<Type, object>[] KeyedFactoryCache => null;

        ///<summary>The int key is the `FactoryID`</summary>
        public virtual ImHashMap<int, object>[] FactoryExpressionCache => null;

        internal virtual IsRegistryChangePermitted IsChangePermitted => default;

        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<Type, object> GetCachedDefaultFactoryOrDefault(ImHashMap<Type, object> rs, int serviceTypeHash, Type serviceType) =>
            (rs as Registry)
            ?.DefaultFactoryCache?[serviceTypeHash & CACHE_SLOT_COUNT_MASK]
            ?.GetEntryOrDefaultByReferenceEquals(serviceTypeHash, serviceType);

        internal sealed class KeyedFactoryCacheEntry
        {
            public readonly KeyedFactoryCacheEntry Rest;
            public readonly object Key;
            public object Factory;
            public KeyedFactoryCacheEntry(KeyedFactoryCacheEntry rest, object key, object factory)
            {
                Rest = rest;
                Key = key;
                Factory = factory;
            }
        }

        public static bool GetCachedKeyedFactoryOrDefault(ImHashMap<Type, object> rs,
            int serviceTypeHash, Type serviceType, object key, out KeyedFactoryCacheEntry result)
        {
            result = null;
            var cache = (rs as Registry)?.KeyedFactoryCache;
            if (cache != null)
            {
                var entry = cache[serviceTypeHash & CACHE_SLOT_COUNT_MASK]?.GetEntryOrDefaultByReferenceEquals(serviceTypeHash, serviceType);
                if (entry != null)
                    for (var x = (KeyedFactoryCacheEntry)entry.Value; x != null && result == null; x = x.Rest)
                        if (ReferenceEquals(x.Key, key))
                            result = x;
                        else if (x.Key.Equals(key))
                            result = x;
            }
            return result != null;
        }

        internal static object SetOrAddKeyedCacheFactory(object x, object k, object f)
        {
            for (var entry = (KeyedFactoryCacheEntry)x; entry != null; entry = entry.Rest)
                if (entry.Key.Equals(k))
                {
                    entry.Factory = f;
                    return x;
                }
            return new KeyedFactoryCacheEntry((KeyedFactoryCacheEntry)x, k, f);
        }

        internal Registry(ImHashMap<Type, object> services) => Services = services;

        [MethodImpl((MethodImplOptions)256)]
        internal static Registry NewWithDefaultFactoryCache(ImHashMap<Type, object> services) =>
            new AndDefaultCache(services, new ImHashMap<Type, object>[CACHE_SLOT_COUNT], null);

        [MethodImpl((MethodImplOptions)256)]
        internal static Registry NewWithFactoryExpressionCache(ImHashMap<Type, object> services) =>
            new AndDefaultCache(services, null, new ImHashMap<int, object>[CACHE_SLOT_COUNT]);

        [MethodImpl((MethodImplOptions)256)]
        internal static Registry NewWithKeyedFactoryCache(ImHashMap<Type, object> services) =>
            new AndCache(services, null, new ImHashMap<Type, object>[CACHE_SLOT_COUNT], null, default);

        internal sealed class AndWrappersAndDecorators : Registry
        {
            public override ImHashMap<Type, object> Wrappers => _wrappers; // value is Factory[]  // todo: @perf make it Factory or Factory[]
            readonly ImHashMap<Type, object> _wrappers;
            public override ImHashMap<Type, object> Decorators => _decorators; // value is Factory[]  // todo: @perf make it Factory or Factory[]
            readonly ImHashMap<Type, object> _decorators;
            public AndWrappersAndDecorators(ImHashMap<Type, object> services, ImHashMap<Type, object> wrappers, ImHashMap<Type, object> decorators) :
                base(services)
            {
                _wrappers = wrappers;
                _decorators = decorators;
            }

            internal override Registry WithDefaultFactoryCache() =>
                new AndDefaultCache.DefaultCacheAndWrappersAndDecorators(Services, _wrappers, _decorators, new ImHashMap<Type, object>[CACHE_SLOT_COUNT], null);

            internal override Registry WithFactoryExpressionCache() =>
                new AndDefaultCache.DefaultCacheAndWrappersAndDecorators(Services, _wrappers, _decorators, null, new ImHashMap<int, object>[CACHE_SLOT_COUNT]);

            internal override Registry WithKeyedFactoryCache() =>
                new AndCache.CacheAndWrappersAndDecorators(Services, _wrappers, _decorators, null, new ImHashMap<Type, object>[CACHE_SLOT_COUNT], null, default);

            public override Registry WithIsChangePermitted(IsRegistryChangePermitted isChangePermitted) =>
                new AndCache.CacheAndWrappersAndDecorators(Services, _wrappers, _decorators, null, null, null, isChangePermitted);

            internal override Registry WithServices(ImHashMap<Type, object> services) =>
                services == Services ? this :
                new AndWrappersAndDecorators(services, _wrappers, _decorators);

            internal override Registry WithWrappers(ImHashMap<Type, object> wrappers) =>
                wrappers == _wrappers ? this :
                new AndWrappersAndDecorators(Services, wrappers, _decorators);

            internal override Registry WithDecorators(ImHashMap<Type, object> decorators) =>
                decorators == _decorators ? this :
                new AndWrappersAndDecorators(Services, _wrappers, decorators);
        }

        internal class AndDefaultCache : Registry
        {
            public sealed override ImHashMap<Type, object>[] DefaultFactoryCache => _defaultFactoryCache;
            internal ImHashMap<Type, object>[] _defaultFactoryCache;
            public sealed override ImHashMap<int, object>[] FactoryExpressionCache => _factoryExpressionCache;
            internal ImHashMap<int, object>[] _factoryExpressionCache;

            internal AndDefaultCache(
                ImHashMap<Type, object> services,
                ImHashMap<Type, object>[] defaultFactoryCache,
                ImHashMap<int, object>[] factoryExpressionCache) : base(services)
            {
                _defaultFactoryCache = defaultFactoryCache;
                _factoryExpressionCache = factoryExpressionCache;
            }

            public override Registry WithoutCache() => new Registry(Services);

            internal override Registry WithServices(ImHashMap<Type, object> services) =>
                services == Services ? this :
                new AndDefaultCache(services, _defaultFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty());

            internal override Registry WithWrappers(ImHashMap<Type, object> wrappers) =>
                wrappers == Wrappers ? this :
                new DefaultCacheAndWrappersAndDecorators(Services, wrappers, Decorators, _defaultFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty());

            internal override Registry WithDecorators(ImHashMap<Type, object> decorators) =>
                decorators == Decorators ? this :
                new DefaultCacheAndWrappersAndDecorators(Services, Wrappers, decorators, _defaultFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty());

            public override Registry WithIsChangePermitted(IsRegistryChangePermitted isChangePermitted) =>
                isChangePermitted == default ? this :
                new AndCache(Services, _defaultFactoryCache, null, _factoryExpressionCache, isChangePermitted);

            /// Returns the same registry with cache ensuring that the cache is not null
            internal override Registry WithDefaultFactoryCache()
            {
                if (_defaultFactoryCache == null)
                    Interlocked.CompareExchange(ref _defaultFactoryCache, new ImHashMap<Type, object>[CACHE_SLOT_COUNT], null);
                return this;
            }

            /// Returns the same registry with cache ensuring that the cache is not null
            internal override Registry WithFactoryExpressionCache()
            {
                if (_factoryExpressionCache == null)
                    Interlocked.CompareExchange(ref _factoryExpressionCache, new ImHashMap<int, object>[CACHE_SLOT_COUNT], null);
                return this;
            }

            internal override void DropFactoryCache(Factory factory, int hash, Type serviceType, object serviceKey = null)
            {
                if (factory == null)
                    return; // filter out Unregistered factory (see #390)

                if (_defaultFactoryCache != null)
                {
                    if (factory.GeneratedFactories == null)
                    {
                        var d = _defaultFactoryCache;
                        if (d != null)
                            Ref.Swap(ref d[hash & CACHE_SLOT_COUNT_MASK], hash, serviceType,
                                static (x, h, t) => (x ?? ImHashMap<Type, object>.Empty).UpdateToDefault(h, t));
                    }
                    else
                    {
                        // We cannot remove generated factories, because they are keyed by implementation type and we may remove wrong factory
                        // a safe alternative is dropping the whole cache
                        _defaultFactoryCache = null;
                    }
                }

                if (_factoryExpressionCache != null)
                {
                    var exprCache = _factoryExpressionCache;
                    if (exprCache != null)
                    {
                        var factoryId = factory.FactoryID;
                        Ref.Swap(ref exprCache[factoryId & CACHE_SLOT_COUNT_MASK],
                            factoryId, static (x, i) => (x ?? ImHashMap<int, object>.Empty).UpdateToDefault(i));
                    }
                }
            }

            internal sealed class DefaultCacheAndWrappersAndDecorators : AndDefaultCache
            {
                public override ImHashMap<Type, object> Wrappers => _wrappers;
                readonly ImHashMap<Type, object> _wrappers;
                public override ImHashMap<Type, object> Decorators => _decorators;
                readonly ImHashMap<Type, object> _decorators;
                internal DefaultCacheAndWrappersAndDecorators(
                    ImHashMap<Type, object> services,
                    ImHashMap<Type, object> wrappers,
                    ImHashMap<Type, object> decorators,
                    ImHashMap<Type, object>[] defaultFactoryCache,
                    ImHashMap<int, object>[] factoryExpressionCache) :
                    base(services, defaultFactoryCache, factoryExpressionCache)
                {
                    _wrappers = wrappers;
                    _decorators = decorators;
                }

                public override Registry WithoutCache() =>
                    new AndWrappersAndDecorators(Services, _wrappers, _decorators);

                internal override Registry WithServices(ImHashMap<Type, object> services) =>
                    services == Services ? this :
                    new DefaultCacheAndWrappersAndDecorators(services, _wrappers, _decorators, _defaultFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty());

                internal override Registry WithWrappers(ImHashMap<Type, object> wrappers) =>
                    wrappers == _wrappers ? this :
                    new DefaultCacheAndWrappersAndDecorators(Services, wrappers, _decorators, _defaultFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty());

                internal override Registry WithDecorators(ImHashMap<Type, object> decorators) =>
                    decorators == _decorators ? this :
                    new DefaultCacheAndWrappersAndDecorators(Services, _wrappers, decorators, _defaultFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty());

                internal override Registry WithKeyedFactoryCache() =>
                    new AndCache.CacheAndWrappersAndDecorators(Services, _wrappers, _decorators, _defaultFactoryCache, new ImHashMap<Type, object>[CACHE_SLOT_COUNT], _factoryExpressionCache, default);

                public override Registry WithIsChangePermitted(IsRegistryChangePermitted isChangePermitted) =>
                    isChangePermitted == default ? this :
                    new AndCache.CacheAndWrappersAndDecorators(Services, _wrappers, _decorators, _defaultFactoryCache, null, _factoryExpressionCache, isChangePermitted);
            }
        }

        internal class AndCache : AndDefaultCache
        {
            public sealed override ImHashMap<Type, object>[] KeyedFactoryCache => _keyedFactoryCache;
            internal ImHashMap<Type, object>[] _keyedFactoryCache;
            internal sealed override IsRegistryChangePermitted IsChangePermitted => _isChangePermitted;
            protected IsRegistryChangePermitted _isChangePermitted;
            internal AndCache(
                ImHashMap<Type, object> services,
                ImHashMap<Type, object>[] defaultFactoryCache,
                ImHashMap<Type, object>[] keyedFactoryCache,
                ImHashMap<int, object>[] factoryExpressionCache,
                IsRegistryChangePermitted isChangePermitted) : base(services, defaultFactoryCache, factoryExpressionCache)
            {
                _keyedFactoryCache = keyedFactoryCache;
                _isChangePermitted = isChangePermitted;
            }

            public override Registry WithoutCache() =>
                _isChangePermitted == default ? new Registry(Services) :
                new AndCache(Services, null, null, null, _isChangePermitted);

            internal override Registry WithServices(ImHashMap<Type, object> services) =>
                services == Services ? this :
                new AndCache(services, _defaultFactoryCache?.CopyNonEmpty(), _keyedFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty(), _isChangePermitted);

            internal override Registry WithWrappers(ImHashMap<Type, object> wrappers) =>
                wrappers == Wrappers ? this :
                new CacheAndWrappersAndDecorators(Services, wrappers, Decorators, _defaultFactoryCache?.CopyNonEmpty(), _keyedFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty(), _isChangePermitted);

            internal override Registry WithDecorators(ImHashMap<Type, object> decorators) =>
                decorators == Decorators ? this :
                new CacheAndWrappersAndDecorators(Services, Wrappers, decorators, _defaultFactoryCache?.CopyNonEmpty(), _keyedFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty(), _isChangePermitted);

            public override Registry WithIsChangePermitted(IsRegistryChangePermitted isChangePermitted) =>
                isChangePermitted == _isChangePermitted ? this :
                new AndCache(Services, _defaultFactoryCache, _keyedFactoryCache, _factoryExpressionCache, isChangePermitted);

            internal override Registry WithKeyedFactoryCache()
            {
                if (_keyedFactoryCache == null)
                    Interlocked.CompareExchange(ref _keyedFactoryCache, new ImHashMap<Type, object>[CACHE_SLOT_COUNT], null);
                return this;
            }

            internal override void DropFactoryCache(Factory factory, int hash, Type serviceType, object serviceKey = null)
            {
                if (factory == null)
                    return; // filter out Unregistered factory (see #390)

                if (_defaultFactoryCache != null | _keyedFactoryCache != null)
                {
                    if (factory.GeneratedFactories == null)
                    {
                        var d = _defaultFactoryCache;
                        if (d != null)
                            Ref.Swap(ref d[hash & CACHE_SLOT_COUNT_MASK], hash, serviceType,
                                static (x, h, t) => (x ?? ImHashMap<Type, object>.Empty).UpdateToDefault(h, t));

                        var k = _keyedFactoryCache;
                        if (k != null)
                            Ref.Swap(ref k[hash & CACHE_SLOT_COUNT_MASK], hash, serviceType,
                                static (x, h, t) => (x ?? ImHashMap<Type, object>.Empty).UpdateToDefault(h, t));
                    }
                    else
                    {
                        // We cannot remove generated factories, because they are keyed by implementation type and we may remove wrong factory
                        // a safe alternative is dropping the whole cache
                        _defaultFactoryCache = null;
                        _keyedFactoryCache = null;
                    }
                }

                if (_factoryExpressionCache != null)
                {
                    var exprCache = _factoryExpressionCache;
                    if (exprCache != null)
                    {
                        var factoryId = factory.FactoryID;
                        Ref.Swap(ref exprCache[factoryId & CACHE_SLOT_COUNT_MASK],
                            factoryId, static (x, i) => (x ?? ImHashMap<int, object>.Empty).UpdateToDefault(i));
                    }
                }
            }

            internal sealed class CacheAndWrappersAndDecorators : AndCache
            {
                public override ImHashMap<Type, object> Wrappers => _wrappers;
                readonly ImHashMap<Type, object> _wrappers;
                public override ImHashMap<Type, object> Decorators => _decorators;
                readonly ImHashMap<Type, object> _decorators;
                internal CacheAndWrappersAndDecorators(
                    ImHashMap<Type, object> services,
                    ImHashMap<Type, object> wrappers,
                    ImHashMap<Type, object> decorators,
                    ImHashMap<Type, object>[] defaultFactoryCache,
                    ImHashMap<Type, object>[] keyedFactoryCache,
                    ImHashMap<int, object>[] factoryExpressionCache,
                    IsRegistryChangePermitted isChangePermitted) :
                    base(services, defaultFactoryCache, keyedFactoryCache, factoryExpressionCache, isChangePermitted)
                {
                    _wrappers = wrappers;
                    _decorators = decorators;
                }

                public override Registry WithoutCache() =>
                    _isChangePermitted == default
                        ? new Registry.AndWrappersAndDecorators(Services, _wrappers, _decorators)
                        : (Registry)new CacheAndWrappersAndDecorators(Services, _wrappers, _decorators, null, null, null, _isChangePermitted);

                internal override Registry WithServices(ImHashMap<Type, object> services) =>
                    services == Services ? this :
                    new CacheAndWrappersAndDecorators(services, _wrappers, _decorators,
                        _defaultFactoryCache?.CopyNonEmpty(), _keyedFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty(), _isChangePermitted);

                internal override Registry WithWrappers(ImHashMap<Type, object> wrappers) =>
                    wrappers == _wrappers ? this :
                    new CacheAndWrappersAndDecorators(Services, wrappers, _decorators,
                        _defaultFactoryCache?.CopyNonEmpty(), _keyedFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty(), _isChangePermitted);

                internal override Registry WithDecorators(ImHashMap<Type, object> decorators) =>
                    decorators == _decorators ? this :
                    new CacheAndWrappersAndDecorators(Services, _wrappers, decorators,
                        _defaultFactoryCache?.CopyNonEmpty(), _keyedFactoryCache?.CopyNonEmpty(), _factoryExpressionCache?.CopyNonEmpty(), _isChangePermitted);

                public override Registry WithIsChangePermitted(IsRegistryChangePermitted isChangePermitted) =>
                    isChangePermitted == _isChangePermitted ? this :
                    new CacheAndWrappersAndDecorators(Services, _wrappers, _decorators,
                        _defaultFactoryCache, _keyedFactoryCache, _factoryExpressionCache, isChangePermitted);
            }
        }

        public virtual Registry WithoutCache() => this;

        internal virtual Registry WithDefaultFactoryCache() =>
            new AndDefaultCache(Services, new ImHashMap<Type, object>[CACHE_SLOT_COUNT], null);

        internal virtual Registry WithKeyedFactoryCache() =>
            new AndCache(Services, DefaultFactoryCache, new ImHashMap<Type, object>[CACHE_SLOT_COUNT], FactoryExpressionCache, default);

        internal virtual Registry WithFactoryExpressionCache() =>
            new AndDefaultCache(Services, null, new ImHashMap<int, object>[CACHE_SLOT_COUNT]);

        internal virtual Registry WithServices(ImHashMap<Type, object> services) =>
            services == Services ? this : new Registry(services);

        internal virtual Registry WithWrappers(ImHashMap<Type, object> wrappers) =>
            wrappers == Wrappers ? this : new AndWrappersAndDecorators(Services, wrappers, Decorators);

        internal virtual Registry WithDecorators(ImHashMap<Type, object> decorators) =>
            decorators == Decorators ? this : new AndWrappersAndDecorators(Services, Wrappers, decorators);

        public virtual Registry WithIsChangePermitted(IsRegistryChangePermitted isChangePermitted) =>
            isChangePermitted == default ? this : new AndCache(Services, null, null, null, isChangePermitted);

        // where object value is Factory or FactoriesEntry
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ImHashMap<Type, object> GetServiceFactories(ImHashMap<Type, object> registryOrServices) =>
            registryOrServices is Registry r ? r.Services : registryOrServices;

        /// <summary>Returns the constructed registrations filtering out the unregistered services.</summary>
        public static IEnumerable<ServiceRegistrationInfo> GetServiceRegistrations(ImHashMap<Type, object> registryOrServices)
        {
            var services = GetServiceFactories(registryOrServices);
            foreach (var entry in services.Enumerate())
            {
                if (entry.Value is Factory factory)
                    yield return new ServiceRegistrationInfo(factory, entry.Key, null);
                else if (entry.Value != null) // maybe `null` for the unregistered service, see #412
                {
                    var factories = ((FactoriesEntry)entry.Value).Factories;
                    foreach (var f in factories)
                        if (f.Value != null) // maybe `null` for the unregistered service, see #412
                            yield return new ServiceRegistrationInfo(f.Value, entry.Key, f.Key);
                }
            }
        }

        /// <summary>Returns the matched result registrations filtering out the unregistered services.</summary>
        public static IEnumerable<R> GetServiceRegistrations<S, R>(
            ImHashMap<Type, object> registryOrServices, S state, MatchOp<S, ServiceRegistrationInfo, R> match)
        {
            var services = GetServiceFactories(registryOrServices);
            foreach (var entry in services.Enumerate())
            {
                if (entry.Value is Factory factory)
                {
                    var info = new ServiceRegistrationInfo(factory, entry.Key, null);
                    if (match(ref state, ref info, out var result))
                        yield return result;
                }
                else if (entry.Value != null) // maybe `null` for the unregistered service, see #412
                {
                    var factories = ((FactoriesEntry)entry.Value).Factories;
                    foreach (var f in factories)
                    {
                        if (f.Value == null)
                            continue; // maybe `null` for the unregistered service, see #412
                        var info = new ServiceRegistrationInfo(f.Value, entry.Key, f.Key);
                        if (match(ref state, ref info, out var result))
                            yield return result;
                    }
                }
            }
        }

        public static IEnumerable<DecoratorRegistrationInfo> GetDecoratorRegistrations(ImHashMap<Type, object> registryOrServices)
        {
            if (registryOrServices is Registry r)
            {
                var ds = r.Decorators;
                if (!ds.IsEmpty)
                {
                    foreach (var entry in ds.Enumerate())
                        foreach (var f in (Factory[])entry.Value)
                            yield return new DecoratorRegistrationInfo(f, entry.Key);
                }
            }
        }

        public static ImHashMap<Type, object> Register(ImHashMap<Type, object> registryOrServices,
            Factory factory, Type serviceType, IfAlreadyRegistered ifAlreadyRegistered, object serviceKey)
        {
            var r = registryOrServices as Registry;
            if (r != null && r.IsChangePermitted != IsRegistryChangePermitted.Permitted)
                return r.IsChangePermitted == IsRegistryChangePermitted.Ignored ? registryOrServices
                    : Throw.For<Registry>(Error.NoMoreRegistrationsAllowed,
                        serviceType, serviceKey != null ? "with key " + serviceKey : string.Empty, factory);

            var serviceTypeHash = RuntimeHelpers.GetHashCode(serviceType);
            if (factory.FactoryType == FactoryType.Service)
                return serviceKey == null
                    ? WithDefaultService(r, registryOrServices, factory, serviceTypeHash, serviceType, ifAlreadyRegistered)
                    : WithKeyedService(r, registryOrServices, factory, serviceTypeHash, serviceType, ifAlreadyRegistered, serviceKey);

            r ??= new Registry(registryOrServices); // todo: @perf remove the temporary new Registry allocation
            return factory.FactoryType == FactoryType.Decorator
                ? r.WithDecorators(r.Decorators.AddOrUpdateByReferenceEquals(serviceTypeHash, serviceType, factory.One(),
                    static (_, older, newer) => Container.MergeSortedByLatestOrderOrRegistration((Factory[])older, (Factory[])newer)))
                : r.WithWrappers(r.Wrappers.AddOrUpdateByReferenceEquals(serviceTypeHash, serviceType, factory));
        }

        public static Factory[] GetRegisteredFactories(ImHashMap<Type, object> registryOrServices,
            Type serviceType, object serviceKey, FactoryType factoryType)
        {
            serviceType = serviceType.ThrowIfNull();
            switch (factoryType)
            {
                case FactoryType.Wrapper:
                    {
                        var r = registryOrServices as Registry;
                        var wrappers = r != null ? r.Wrappers : WrappersSupport.Wrappers;
                        // first checking for the explicitly provided say `MyWrapper<IMyService>`
                        if (wrappers.GetValueOrDefault(serviceType) is Factory wrapper)
                            return wrapper.One();

                        var openGenServiceType = serviceType.GetGenericDefinitionOrNull();
                        if (openGenServiceType != null &&
                            wrappers.GetValueOrDefault(openGenServiceType) is Factory openGenWrapper)
                            return openGenWrapper.One();

                        if (serviceType.GetArrayElementTypeOrNull() != null &&
                            wrappers.GetValueOrDefault(typeof(IEnumerable<>)) is Factory collectionWrapper)
                            return collectionWrapper.One();

                        return null;
                    }
                case FactoryType.Decorator:
                    {
                        var r = registryOrServices as Registry;
                        if (r == null)
                            return null;
                        var allDecorators = r.Decorators;
                        var decorators = allDecorators.GetValueOrDefault(serviceType) as Factory[];
                        var openGenServiceType = serviceType.GetGenericDefinitionOrNull();
                        if (openGenServiceType != null)
                            decorators = decorators.Append(allDecorators.GetValueOrDefault(openGenServiceType) as Factory[]);
                        return decorators;
                    }
                default:
                    {
                        var services = Registry.GetServiceFactories(registryOrServices);
                        var entry = services.GetValueOrDefault(serviceType);
                        if (entry == null)
                            return null;

                        if (entry is Factory factory)
                            return serviceKey == null || DefaultKey.Value.Equals(serviceKey) ? factory.One() : null;

                        var factoriesEntry = (FactoriesEntry)entry;
                        if (serviceKey == null) // get all the factories
                            return factoriesEntry.Factories.Map(static x => x.Value);

                        return factoriesEntry.GetFirstKeyedOrDefault(serviceKey)?.Value?.One(); // todo: @wip return multiple factories
                    }
            }
        }

        public static bool IsRegistered(ImHashMap<Type, object> registryOrServices,
            Type serviceType, object serviceKey, FactoryType factoryType, Func<Factory, bool> condition)
        {
            serviceType = serviceType.ThrowIfNull();
            switch (factoryType)
            {
                case FactoryType.Wrapper:
                    {
                        var r = registryOrServices as Registry;
                        var wrappers = r != null ? r.Wrappers : WrappersSupport.Wrappers;

                        // first checking for the explicitly provided say `MyWrapper<IMyService>`
                        if (wrappers.GetValueOrDefault(serviceType) is Factory wrapper &&
                            (condition == null || condition(wrapper)))
                            return true;

                        var openGenServiceType = serviceType.GetGenericDefinitionOrNull();
                        if (openGenServiceType != null &&
                            wrappers.GetValueOrDefault(openGenServiceType) is Factory openGenWrapper &&
                            (condition == null || condition(openGenWrapper)))
                            return true;

                        if (serviceType.GetArrayElementTypeOrNull() != null &&
                            wrappers.GetValueOrDefault(typeof(IEnumerable<>)) is Factory collectionWrapper &&
                            (condition == null || condition(collectionWrapper)))
                            return true;

                        return false;
                    }
                case FactoryType.Decorator:
                    {
                        var r = registryOrServices as Registry;
                        if (r == null)
                            return false;

                        var allDecorators = r.Decorators;
                        if (allDecorators.GetValueOrDefault(serviceType) is Factory[] decorators && decorators.Length != 0 &&
                            (condition == null || decorators.FindFirst(condition) != null))
                            return true;

                        var openGenServiceType = serviceType.GetGenericDefinitionOrNull();
                        if (openGenServiceType != null &&
                            allDecorators.GetValueOrDefault(openGenServiceType) is Factory[] openGenDecorators && openGenDecorators.Length != 0 &&
                            (condition == null || openGenDecorators.FindFirst(condition) != null))
                            return true;

                        return false;
                    }
                default: // services
                    {
                        // We are not checking the open-generic for the closed-generic service type
                        // to be able to explicitly understand what registration is available - open or the closed-generic
                        var services = Registry.GetServiceFactories(registryOrServices);
                        var entry = services.GetValueOrDefault(serviceType);
                        if (entry == null)
                            return false;

                        if (entry is Factory factory)
                            return serviceKey == null || DefaultKey.Value.Equals(serviceKey)
                                ? condition == null || condition(factory)
                                : false;

                        var factoriesEntry = (FactoriesEntry)entry;
                        if (serviceKey == null)
                            return condition == null ||
                                factoriesEntry.Factories.FindFirst(condition, static (cond, f) => cond(f.Value)) != null;

                        factory = factoriesEntry.GetFirstKeyedOrDefault(serviceKey)?.Value; // todo: @wip return multiple factories
                        return factory != null && (condition == null || condition(factory));
                    }
            }
        }

        public static bool ClearCache(ImHashMap<Type, object> registryOrServices,
            int hash, Type serviceType, object serviceKey, FactoryType factoryType)
        {
            var factories = GetRegisteredFactories(registryOrServices, serviceType, serviceKey, factoryType);
            if (factories.IsNullOrEmpty())
                return false;

            if (registryOrServices is Registry r)
                for (var i = 0; i < factories.Length; i++)
                    r.DropFactoryCache(factories[i], hash, serviceType, serviceKey);

            return true;
        }

        private static ImHashMap<Type, object> WithDefaultService(Registry r, ImHashMap<Type, object> registryOrServices,
            Factory factory, int serviceTypeHash, Type serviceType, IfAlreadyRegistered ifAlreadyRegistered)
        {
            var services = r == null ? registryOrServices : r.Services;
            var newEntry = ImHashMap.Entry(serviceTypeHash, serviceType, (object)factory);
            if (services.IsEmpty)
                return r == null ? newEntry : r.WithServices(newEntry);

            var mapOrOldEntry = services.AddOrGetEntry(serviceTypeHash, newEntry);
            var oldEntry = mapOrOldEntry as ImHashMap<Type, object>.Entry;
            if (oldEntry == null)
                return r == null ? mapOrOldEntry : r.WithServices(mapOrOldEntry);

            var updatedEntry = oldEntry.AppendOrUpdateInPlaceOrKeepByReferenceEquals(ifAlreadyRegistered, newEntry, static (i, o, n) =>
            {
                var fac = (Factory)n.Value;
                switch (i)
                {
                    case IfAlreadyRegistered.AppendNotKeyed:
                        return n.SetValue(o.Value is FactoriesEntry fe
                            ? fe.WithDefault(fac)
                            : FactoriesEntry.Empty.WithTwoDefault((Factory)o.Value, fac));

                    case IfAlreadyRegistered.Throw:
                        return n.SetValue(o.Value is FactoriesEntry oldFactoriesEntry && oldFactoriesEntry.LastDefaultKey == null
                            ? oldFactoriesEntry.WithDefault(fac)
                            : Throw.For<object>(Error.UnableToRegisterDuplicateDefault, n.Key, fac, o));

                    case IfAlreadyRegistered.Replace:
                        if (o.Value is FactoriesEntry facEntryToReplace)
                        {
                            if (facEntryToReplace.LastDefaultKey == null)
                                return n.SetValue(facEntryToReplace.WithDefault(fac, DefaultKey.Value));

                            // remove defaults but keep keyed (issue #569) by collecting the only keyed factories and using them in a new factory entry
                            var keyedFactories = facEntryToReplace.Factories.Match(static x => x.Key is not DefaultKey);
                            if (keyedFactories.Length != 0)
                                return n.SetValue(new FactoriesEntry(DefaultKey.Value,
                                    keyedFactories.AppendToNonEmpty(new KV<object, Factory>(DefaultKey.Value, fac))));
                        }
                        return n;

                    case IfAlreadyRegistered.AppendNewImplementation:
                        var oldImplFacsEntry = o.Value as FactoriesEntry;
                        if (oldImplFacsEntry != null && oldImplFacsEntry.LastDefaultKey == null)
                            return n.SetValue(oldImplFacsEntry.WithDefault(fac, DefaultKey.Value));

                        var oldFactory = o.Value as Factory;
                        var implementationType = fac.ImplementationType;
                        if (implementationType == null ||
                            oldFactory != null && oldFactory.ImplementationType != implementationType)
                            return n.SetValue((oldImplFacsEntry ?? FactoriesEntry.Empty.WithDefault(oldFactory)).WithDefault(fac));

                        if (oldImplFacsEntry != null)
                        {
                            var isNewImplType = true;
                            foreach (var f in oldImplFacsEntry.Factories)
                                if (f.Value.ImplementationType == implementationType)
                                {
                                    isNewImplType = false;
                                    break;
                                }
                            return isNewImplType
                                ? n.SetValue((oldImplFacsEntry ?? FactoriesEntry.Empty.WithDefault(oldFactory)).WithDefault(fac))
                                : o;
                        }
                        return o; // return the old entry unless the implementation type is new 

                    default: // IfAlreadyRegisteredKeepDefaultService
                        return o.Value is FactoriesEntry oldFacsEntry && oldFacsEntry.LastDefaultKey == null
                            ? n.SetValue(oldFacsEntry.WithDefault(fac))
                            : o;
                }
            });

            if (updatedEntry == oldEntry)
                return registryOrServices;

            var newServices = services.ReplaceEntry(oldEntry, updatedEntry);
            if (r == null)
                return newServices;

            r = r.WithServices(newServices);

            // Don't forget the drop cache for the old value if any
            var oldValue = oldEntry.GetValueOrDefaultWithTheSameHashByReferenceEquals(serviceType);
            if (oldValue != null)
                DropFactoryCache(r, serviceTypeHash, serviceType, oldValue);

            return r;
        }

        private static void DropFactoryCache(Registry r, int serviceTypeHash, Type serviceType, object entryValue)
        {
            if (entryValue is Factory oldFactory)
                r.DropFactoryCache(oldFactory, serviceTypeHash, serviceType);
            else if (entryValue is FactoriesEntry oldFactoriesEntry && oldFactoriesEntry.LastDefaultKey != null)
            {
                foreach (var f in oldFactoriesEntry.Factories)
                    if (f.Key is DefaultKey)
                        r.DropFactoryCache(f.Value, serviceTypeHash, serviceType, f.Key);
            }
        }

        private static ImHashMap<Type, object> WithKeyedService(Registry r, ImHashMap<Type, object> registryOrServices,
            Factory factory, int serviceTypeHash, Type serviceType, IfAlreadyRegistered ifAlreadyRegistered, object serviceKey)
        {
            var services = r == null ? registryOrServices : r.Services;
            object newEntry = null;
            var oldEntry = services.GetValueOrDefaultByReferenceEquals(serviceTypeHash, serviceType);
            if (oldEntry != null)
            {
                switch (ifAlreadyRegistered)
                {
                    case IfAlreadyRegistered.Replace:
                        if (oldEntry is Factory singleDefaultFactory)
                            newEntry = DefaultKey.Value.Equals(serviceKey)
                                ? factory
                                : FactoriesEntry.Empty.WithDefault(singleDefaultFactory, DefaultKey.Value).With(factory, serviceKey);
                        else
                            newEntry = ((FactoriesEntry)oldEntry).With(factory, serviceKey);
                        break;
                    default: // covers all other cases in the presence of service key
                        // case IfAlreadyRegistered.Throw
                        // case IfAlreadyRegistered.AppendNotKeyed:
                        // case IfAlreadyRegistered.Keep:
                        // case IfAlreadyRegistered.AppendNewImplementation:

                        if (oldEntry is Factory factoryToKeep)
                            newEntry = FactoriesEntry.Empty.WithDefault(factoryToKeep, DefaultKey.Value).With(factory, serviceKey);
                        else
                        {
                            var oldFacs = (FactoriesEntry)oldEntry;
                            var oldFac = oldFacs.GetLastKeyedOrDefault(serviceKey);
                            if (oldFac != null)
                            {
                                if (ifAlreadyRegistered != IfAlreadyRegistered.Keep)
                                    Throw.It(Error.UnableToRegisterDuplicateKey, serviceKey, oldFac.Key, oldFac.Value);
                                return registryOrServices; // keep the old registry only for the explicit .Keep case
                            }
                            newEntry = oldFacs.With(factory, serviceKey);
                        }
                        break;
                }
            }

            if (newEntry == null)
                newEntry = FactoriesEntry.Empty.With(factory, serviceKey);

            var newServices = services.AddOrUpdate(serviceTypeHash, serviceType, newEntry);
            if (r == null)
                return newServices;

            r = r.WithServices(newServices);

            if (oldEntry != null & ifAlreadyRegistered == IfAlreadyRegistered.Replace &&
                oldEntry is FactoriesEntry updatedOldFactories &&
                updatedOldFactories.GetFirstKeyedOrDefault(serviceKey) is { } droppedFactory)
                r.DropFactoryCache(droppedFactory.Value, serviceTypeHash, serviceType, serviceKey);

            return r;
        }

        // todo: @perf optimize allocations away
        public static ImHashMap<Type, object> Unregister(ImHashMap<Type, object> registryOrServices,
            FactoryType factoryType, Type serviceType, object serviceKey, Func<Factory, bool> condition)
        {
            var r = registryOrServices as Registry;
            if (r != null && r.IsChangePermitted != IsRegistryChangePermitted.Permitted)
                return r.IsChangePermitted == IsRegistryChangePermitted.Ignored ? registryOrServices
                    : Throw.For<Registry>(Error.NoMoreUnregistrationsAllowed,
                        serviceType, serviceKey != null ? "with key " + serviceKey : string.Empty, factoryType);

            var serviceTypeHash = RuntimeHelpers.GetHashCode(serviceType);
            switch (factoryType)
            {
                case FactoryType.Wrapper:
                    {
                        var wrappers = r != null ? r.Wrappers : WrappersSupport.Wrappers;
                        if (r == null)
                            r = new Registry(registryOrServices); // todo: @perf remove not required allocation
                        object removedWrapper = null;
                        r = r.WithWrappers(wrappers.Update(serviceTypeHash, serviceType, null, (_, factory, _null) =>
                        {
                            if (factory != null && condition != null && !condition((Factory)factory))
                                return factory;
                            removedWrapper = factory;
                            return null;
                        }));

                        if (removedWrapper == null)
                            return registryOrServices;
                        r.DropFactoryCache((Factory)removedWrapper, serviceTypeHash, serviceType);
                        return r;
                    }
                case FactoryType.Decorator:
                    {
                        if (r == null)
                            return registryOrServices;
                        var decorators = r.Decorators;
                        Factory[] removedDecorators = null;
                        // todo: @perf minimize allocations in the lambdas below
                        if (condition == null)
                            r = r.WithDecorators(decorators.Update(serviceTypeHash, serviceType, null, (_, factories, _null) =>
                            {
                                removedDecorators = (Factory[])factories;
                                return null;
                            }));
                        else
                            r = r.WithDecorators(decorators.Update(serviceTypeHash, serviceType, null, (_, factories, _null) =>
                            {
                                removedDecorators = ((Factory[])factories).Match(condition);
                                return removedDecorators == factories ? null : factories.To<Factory[]>().Except(removedDecorators).ToArray();
                            }));

                        if (removedDecorators.IsNullOrEmpty())
                            return registryOrServices;

                        for (var i = 0; i < removedDecorators.Length; i++)
                            r.DropFactoryCache(removedDecorators[i], serviceTypeHash, serviceType);

                        return r;
                    }
                default:
                    return UnregisterServiceFactory(registryOrServices, serviceType, serviceKey, condition);
            }
        }

        // todo: @perf optimize allocations away
        private static ImHashMap<Type, object> UnregisterServiceFactory(ImHashMap<Type, object> registryOrServices,
            Type serviceType, object serviceKey = null, Func<Factory, bool> condition = null)
        {
            var r = registryOrServices as Registry;
            var services = r == null ? registryOrServices : r.Services;

            object removed = null; // Factory or FactoriesEntry or Factory[]
            var hash = RuntimeHelpers.GetHashCode(serviceType);
            if (serviceKey == null & condition == null) // simplest case with simplest handling
                services = services.Update(hash, serviceType, null, (_, entry, _null) =>
                {
                    removed = entry;
                    return null;
                });
            else
                // todo: @perf @mem
                services = services.Update(hash, serviceType, null, (_, entry, _null) =>
                {
                    if (entry == null)
                        return null;

                    if (entry is Factory defaultFac)
                    {
                        if ((serviceKey != null && !DefaultKey.Value.Equals(serviceKey)) ||
                            (condition != null && !condition(defaultFac)))
                            return entry; // keep entry
                        removed = entry; // otherwise remove it (the only case if serviceKey == DefaultKey.Value)
                        return null;
                    }

                    var factoriesEntry = (FactoriesEntry)entry;
                    var oldFactories = factoriesEntry.Factories;

                    var remainingFactories = serviceKey == null // automatically means condition != null and vise versa
                        ? oldFactories.Match(condition, static (c, oldFac) => !c(oldFac.Value))
                        : oldFactories.RemoveAt(factoriesEntry.GetLastKeyedIndex(serviceKey));

                    if (remainingFactories.Length == 0)
                    {
                        removed = entry; // if nothing remained then delete the whole entry
                        return null;
                    }

                    if (remainingFactories.Length == oldFactories.Length)
                        return entry; // keep entry - nothing was removed

                    removed = oldFactories.Except(remainingFactories).Select(static x => x.Value).ToArray();

                    if (remainingFactories.Length == 1 && DefaultKey.Value.Equals(remainingFactories[0].Key))
                        return remainingFactories[0].Value; // replace entry with single remaining default factory

                    // update the last default key if the current last default key was removed
                    var newLastDefaultKey = factoriesEntry.LastDefaultKey;
                    if (newLastDefaultKey != null && remainingFactories.FindLast(newLastDefaultKey, static (dk, x) => x.Key.Equals(dk)) == null)
                        newLastDefaultKey = (DefaultKey)remainingFactories.FindLast(static x => x.Key is DefaultKey).Key;

                    return new FactoriesEntry(newLastDefaultKey, remainingFactories);
                });

            if (removed == null)
                return registryOrServices;

            if (r == null)
                return services;

            r = r.WithServices(services);

            if (removed is Factory f)
                r.DropFactoryCache(f, hash, serviceType, serviceKey);
            else if (removed is Factory[] fs)
                foreach (var rf in fs)
                    r.DropFactoryCache(rf, hash, serviceType, serviceKey);
            else
                foreach (var e in ((FactoriesEntry)removed).Factories)
                    r.DropFactoryCache(e.Value, hash, serviceType, serviceKey);
            return r;
        }

        internal virtual void DropFactoryCache(Factory factory, int hash, Type serviceType, object serviceKey = null) { }
    }

    private Container(Rules rules, Ref<ImHashMap<Type, object>> registry, IScope singletonScope,
        IDisposable ownScopeOrContext = null,
        int disposed = 0, StackTrace disposeStackTrace = null,
        IResolverContext parent = null)
    {
        Rules = rules;
        _registry = registry;
        _singletonScope = singletonScope;
        _ownScopeOrContext = ownScopeOrContext;
        _disposed = disposed;
        _disposeStackTrace = disposeStackTrace;
        _parent = parent;
    }

    private void SetInitialRuntimeFactoryID()
    {
        // todo: @wip remove factory ID from the equation
        if (Rules.CompileTimeContainer != null && Factory._lastFactoryID <= 10_000)
            Factory._lastFactoryID = 20_000;
    }
}

/// <summary>Special service key with the info about the required open-generic service type.
/// It is applied only to resolution keys and not to the registered keys.</summary>
public sealed class ServiceKeyAndRequiredOpenGenericType : IConvertibleToExpression
{
    /// <summary>Open-generic required service-type</summary>
    public readonly Type RequiredServiceType;

    /// <summary>Optional key, may be modified when constructed, then it is fixed</summary>
    public object ServiceKey;

    /// <summary>Constructs the thing</summary>
    public ServiceKeyAndRequiredOpenGenericType(Type requiredServiceType, object serviceKey)
    {
        RequiredServiceType = requiredServiceType.ThrowIfNull();
        ServiceKey = serviceKey;
    }

    /// <inheritdoc />
    public override string ToString() =>
        new StringBuilder(nameof(ServiceKeyAndRequiredOpenGenericType)).Append('(')
            .Print(RequiredServiceType).Append(", ").Print(ServiceKey)
            .Append(')').ToString();

    /// <inheritdoc />
    public override bool Equals(object obj) => obj is ServiceKeyAndRequiredOpenGenericType other &&
        other.RequiredServiceType == RequiredServiceType &&
        Equals(other.ServiceKey, ServiceKey);

    /// <inheritdoc />
    public override int GetHashCode() => Hasher.Combine(RequiredServiceType, ServiceKey);

    /// <inheritdoc />
    public Expression ToExpression<S>(S state, Func<S, object, Expression> fallbackConverter) =>
        New(_ctor, ConstantOf<Type>(RequiredServiceType), fallbackConverter(state, ServiceKey));

    // todo: @perf use UnsafeAccessAttribute to avoid reflection
    private static readonly ConstructorInfo _ctor = typeof(ServiceKeyAndRequiredOpenGenericType).GetConstructors()[0];
}

///<summary>Hides/wraps object with disposable interface.</summary> 
public sealed class HiddenDisposable
{
    internal static ConstructorInfo Ctor = typeof(HiddenDisposable).GetConstructors()[0];
    internal static FieldInfo ValueField = typeof(HiddenDisposable).GetField(nameof(Value));
    /// <summary>Wrapped value</summary>
    public readonly object Value;
    /// <summary>Wraps the value</summary>
    public HiddenDisposable(object value) => Value = value;
}

/// <summary>Interpreter of expression - where possible uses knowledge of DryIoc internals to avoid reflection</summary>
public static class Interpreter
{
    /// <summary>Calls `TryInterpret` inside the try-catch and unwraps and rethrows the InnerException from the reflection `TargetInvocationException`</summary>
    public static bool TryInterpretAndUnwrapContainerException(IResolverContext r, Expression expr, out object result)
    {
        try
        {
            return Interpreter.TryInterpret(r, expr, FactoryDelegateCompiler.FactoryDelegateParamExprs, r, null, out result);
        }
        catch (TargetInvocationException tex) when (tex.InnerException != null)
        {
            var ex = tex.InnerException;

            // When this SPECIFIC TargetInvocationException exception is raised only in this INTERPRETATION PHASE,
            // in order to prevent waiting for the empty item entry in the subsequent resolutions, see #536, #619 for details.
            //
            // So we may:
            // - Assume that the exception happened in the scoped item resolution.
            // - Set the exception in the `Scope.NoItem` entry for the exceptional dependency 
            //   (which is optimistically set before resolving the dependency),
            //   so that exception will be re-thrown on the next resolution.
            //
            // Let's copy the current scope item maps to get the view on the items excluding the future service additions.
            // (It is fine because MapEntry reference is stable and will not change in the future and won't become stale, 
            // and we will be operating with its Value only).
            //
            // Then traverse the scope items and find the first NoItem entry for the exceptional dependency.
            // The first NoItem entry will be the one for the exception because Scope is
            // not supposed to be modified concurrently - so only one NoItem entry is expected. Read-on for more the details.
            // 
            // If found, then try to set the exception into the entry Value, 
            // if we were interrupted (by some other thread setting the exception, right?), then lookup for the next NoItem entry.
            // If not found in the current scope, go to the parent scope and repeat.
            //
            // In worse case scenario we will set the wrong item entry, 
            // but it is not a problem, because it will be overriden by the successful resolution - right?
            // Or if unsuccessful, we may get the wrong exception, but it is even more unlikely the case.
            // It is unlikely in the first place because the majority of cases the scope access is not concurrent.
            //
            var exSet = r.TrySetScopedOrSingletonItemException(ex);

            // todo: @improve should we try to `(ex as ContainerException)?.TryGetDetails(container)` here and include it into the cex message?
            throw ex.TryRethrowWithPreservedStackTrace();
        }
    }

    internal static object InterpretOrCompileSingletonAndUnwrapContainerException(this IResolverContext r, Expression expr, ImHashMapEntry<int, object> itemRef)
    {
        try
        {
            return TryInterpret(r, expr, FactoryDelegateCompiler.FactoryDelegateParamExprs, r, null, out var singleton)
                ? singleton
                : expr.CompileOrInterpretFactoryDelegate(r.Rules.UseInterpretation)(r);
        }
        catch (TargetInvocationException tex) when (tex.InnerException != null)
        {
            itemRef.Value = new ScopedItemException(tex.InnerException);
            throw tex.InnerException.TryRethrowWithPreservedStackTrace();
        }
    }

    /// <summary>Stores parent lambda params and args</summary>
    public sealed class ParentLambdaArgs
    {
        /// <summary> Parent or the `null` for the root </summary>
        public readonly ParentLambdaArgs ParentWithArgs;

        /// <summary> Params </summary>
        public readonly IParameterProvider ParamExprs;

        /// <summary> A single arg or the array of object args </summary>
        public readonly object ParamValues;

        /// <summary>Constructs with parent parent or `null` for the root</summary>
        public ParentLambdaArgs(ParentLambdaArgs parentWithArgs, IParameterProvider paramExprs, object paramValues)
        {
            ParentWithArgs = parentWithArgs;
            ParamExprs = paramExprs;
            ParamValues = paramValues;
        }
    }

    // todo: @perf take into consideration that at the root call ` paramExprs, paramValues` are `FactoryDelegateParamExprs, r`!
    /// <summary>Interprets the expression producing the `result`. If it fails then it returns `false`.</summary>
    public static bool TryInterpret(IResolverContext r, Expression expr,
        IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs, out object result)
    {
        result = null;
        switch (expr.NodeType)
        {
            case ExprType.Constant:
                result = ((ConstantExpression)expr).Value;
                return true;
            case ExprType.New:
                {
                    if (expr is NoArgsNewClassIntrinsicExpression defaultCtorExpr)
                    {
                        // we may use Activator.CreateInstance here which is made 6x faster in .NET 6 than Invoke, but then in the .NET 7 invoke is fast again, so no-op
                        result = defaultCtorExpr.Constructor.Invoke(ArrayTools.Empty<object>());
                        return true;
                    }
                    var newExpr = (NewExpression)expr;
                    object[] args = null;
                    var argCount = newExpr.ArgumentCount;
                    var k = false;
                    switch (argCount)
                    {
                        case 0:
                            // we may use Activator.CreateInstance here which is made 6x faster in .NET 6 than Invoke, but then in the .NET 7 invoke is fast again, so no-op
                            result = newExpr.Constructor.Invoke(ArrayTools.Empty<object>());
                            return true;
                        case 1:
                            if (newExpr is OneArgumentNewExpression e1)
                            {
                                k = TryInterpret(r, e1.Argument, paramExprs, paramValues, parentArgs, out var a0);
                                args = SmallArrayPool<object>.RentOrNew(1);
                                args[0] = a0;
                            }
                            break;
                        case 2:
                            if (newExpr is TwoArgumentsNewExpression e2)
                            {
                                object a0 = null, a1 = null;
                                k = TryInterpret(r, e2.Argument0, paramExprs, paramValues, parentArgs, out a0) &&
                                    TryInterpret(r, e2.Argument1, paramExprs, paramValues, parentArgs, out a1);
                                args = SmallArrayPool<object>.RentOrNew(2);
                                args[0] = a0; args[1] = a1;
                            }
                            break;
                        case 3:
                            if (newExpr is ThreeArgumentsNewExpression e3)
                            {
                                object a0 = null, a1 = null, a2 = null;
                                k = TryInterpret(r, e3.Argument0, paramExprs, paramValues, parentArgs, out a0) &&
                                    TryInterpret(r, e3.Argument1, paramExprs, paramValues, parentArgs, out a1) &&
                                    TryInterpret(r, e3.Argument2, paramExprs, paramValues, parentArgs, out a2);
                                args = SmallArrayPool<object>.RentOrNew(3);
                                args[0] = a0; args[1] = a1; args[2] = a2;
                            }
                            break;
                        case 4:
                            if (newExpr is FourArgumentsNewExpression e4)
                            {
                                object a0 = null, a1 = null, a2 = null, a3 = null;
                                k = TryInterpret(r, e4.Argument0, paramExprs, paramValues, parentArgs, out a0) &&
                                    TryInterpret(r, e4.Argument1, paramExprs, paramValues, parentArgs, out a1) &&
                                    TryInterpret(r, e4.Argument2, paramExprs, paramValues, parentArgs, out a2) &&
                                    TryInterpret(r, e4.Argument3, paramExprs, paramValues, parentArgs, out a3);
                                args = SmallArrayPool<object>.RentOrNew(4);
                                args[0] = a0; args[1] = a1; args[2] = a2; args[3] = a3;
                            }
                            break;
                        case 5:
                            if (newExpr is FiveArgumentsNewExpression e5)
                            {
                                object a0 = null, a1 = null, a2 = null, a3 = null, a4 = null;
                                k = TryInterpret(r, e5.Argument0, paramExprs, paramValues, parentArgs, out a0) &&
                                    TryInterpret(r, e5.Argument1, paramExprs, paramValues, parentArgs, out a1) &&
                                    TryInterpret(r, e5.Argument2, paramExprs, paramValues, parentArgs, out a2) &&
                                    TryInterpret(r, e5.Argument3, paramExprs, paramValues, parentArgs, out a3) &&
                                    TryInterpret(r, e5.Argument4, paramExprs, paramValues, parentArgs, out a4);
                                args = SmallArrayPool<object>.RentOrNew(5);
                                args[0] = a0; args[1] = a1; args[2] = a2; args[3] = a3; args[4] = a4;
                            }
                            break;
                        case 6:
                            if (newExpr is SixArgumentsNewExpression e6)
                            {
                                object a0 = null, a1 = null, a2 = null, a3 = null, a4 = null, a5 = null;
                                k = TryInterpret(r, e6.Argument0, paramExprs, paramValues, parentArgs, out a0) &&
                                    TryInterpret(r, e6.Argument1, paramExprs, paramValues, parentArgs, out a1) &&
                                    TryInterpret(r, e6.Argument2, paramExprs, paramValues, parentArgs, out a2) &&
                                    TryInterpret(r, e6.Argument3, paramExprs, paramValues, parentArgs, out a3) &&
                                    TryInterpret(r, e6.Argument4, paramExprs, paramValues, parentArgs, out a4) &&
                                    TryInterpret(r, e6.Argument5, paramExprs, paramValues, parentArgs, out a5);
                                args = SmallArrayPool<object>.RentOrNew(6);
                                args[0] = a0; args[1] = a1; args[2] = a2; args[3] = a3; args[4] = a4; args[5] = a5;
                            }
                            break;
                        case 7:
                            if (newExpr is SevenArgumentsNewExpression e7)
                            {
                                object a0 = null, a1 = null, a2 = null, a3 = null, a4 = null, a5 = null, a6 = null;
                                k = TryInterpret(r, e7.Argument0, paramExprs, paramValues, parentArgs, out a0) &&
                                    TryInterpret(r, e7.Argument1, paramExprs, paramValues, parentArgs, out a1) &&
                                    TryInterpret(r, e7.Argument2, paramExprs, paramValues, parentArgs, out a2) &&
                                    TryInterpret(r, e7.Argument3, paramExprs, paramValues, parentArgs, out a3) &&
                                    TryInterpret(r, e7.Argument4, paramExprs, paramValues, parentArgs, out a4) &&
                                    TryInterpret(r, e7.Argument5, paramExprs, paramValues, parentArgs, out a5) &&
                                    TryInterpret(r, e7.Argument6, paramExprs, paramValues, parentArgs, out a6);
                                args = SmallArrayPool<object>.RentOrNew(7);
                                args[0] = a0; args[1] = a1; args[2] = a2; args[3] = a3; args[4] = a4; args[5] = a5; args[6] = a6;
                            }
                            break;
                    }
                    if (args != null)
                    {
                        if (k)
                            result = newExpr.Constructor.Invoke(args);
                        SmallArrayPool<object>.Return(args);
                        return k;
                    }
                    args = new object[argCount];
                    for (var i = 0; i < args.Length; ++i)
                    {
                        var argExpr = newExpr.GetArgument(i);
                        if (argExpr is ConstantExpression ac)
                        {
                            if (ac.Value is ScopedItemException it)
                                it.ReThrow();
                            args[i] = ac.Value;
                        }
                        else if (!TryInterpret(r, argExpr, paramExprs, paramValues, parentArgs, out args[i]))
                            return false;
                    }
                    result = newExpr.Constructor.Invoke(args);
                    return true;
                }
            case ExprType.Call:
                {
                    var ok = TryInterpretMethodCall(r, (MethodCallExpression)expr, paramExprs, paramValues, parentArgs, ref result);
                    if (ok && result is ScopedItemException ie)
                        ie.ReThrow();
                    return ok;
                }
            case ExprType.Convert:
                {
                    object instance = null;
                    var convertExpr = (UnaryExpression)expr;
                    var operandExpr = convertExpr.Operand;
                    if (operandExpr is MethodCallExpression m)
                    {
                        if (!TryInterpretMethodCall(r, m, paramExprs, paramValues, parentArgs, ref instance))
                            return false;
                        if (instance is ScopedItemException ie)
                            ie.ReThrow();
                    }
                    else if (!TryInterpret(r, operandExpr, paramExprs, paramValues, parentArgs, out instance))
                        return false;

                    // skip conversion for the null and for the directly assignable type
                    var targetType = convertExpr.Type;
                    result = instance == null || targetType == instance.GetType()
                        || convertExpr.Method == null && targetType.IsAssignableFrom(instance.GetType())
                        ? instance
                        : Converter.ConvertWithOperator(instance, expr, targetType, convertExpr.Method);
                    return true;
                }
            case ExprType.MemberAccess:
                {
                    var memberExpr = (MemberExpression)expr;
                    var instanceExpr = memberExpr.Expression;
                    object instance = null;
                    if (instanceExpr != null && !TryInterpret(r, instanceExpr, paramExprs, paramValues, parentArgs, out instance))
                        return false;

                    if (memberExpr.Member is FieldInfo field)
                    {
                        result = field.GetValue(instance);
                        return true;
                    }

                    if (memberExpr.Member is PropertyInfo prop)
                    {
                        result = prop.GetValue(instance, null);
                        return true;
                    }

                    return false;
                }
            case ExprType.MemberInit:
                {
                    var memberInit = (MemberInitExpression)expr;
                    if (!TryInterpret(r, memberInit.NewExpression, paramExprs, paramValues, parentArgs, out var instance))
                        return false;

                    var count = memberInit.ArgumentCount;
                    for (var i = 0; i < count; i++)
                    {
                        var binding = (MemberAssignment)memberInit.GetArgument(i);
                        var bindingExpr = binding.Expression;
                        object memberValue = null;
                        if (bindingExpr is ConstantExpression cm)
                        {
                            memberValue = cm.Value;
                            if (memberValue is ScopedItemException ie)
                                ie.ReThrow();
                        }
                        else if (!TryInterpret(r, bindingExpr, paramExprs, paramValues, parentArgs, out memberValue))
                            return false;

                        if (binding.Member is FieldInfo field)
                            field.SetValue(instance, memberValue);
                        else
                            ((PropertyInfo)binding.Member).SetValue(instance, memberValue, null);
                    }

                    result = instance;
                    return true;
                }
            case ExprType.NewArrayInit:
                {
                    var newArray = (NewArrayExpression)expr;
                    var items = new object[newArray.ArgumentCount];
                    for (var i = 0; i < items.Length; ++i)
                    {
                        var arg = newArray.GetArgument(i);
                        if (arg is ConstantExpression ca)
                        {
                            items[i] = ca.Value;
                            if (items[i] is ScopedItemException ie)
                                ie.ReThrow();
                        }
                        else if (!TryInterpret(r, arg, paramExprs, paramValues, parentArgs, out items[i]))
                            return false;
                    }
                    // todo: @perf check if using Array.CreateInstance(Type, Int32) is faster
                    result = Converter.ConvertMany(items, newArray.Type.GetElementType());
                    return true;
                }
            case ExprType.Invoke:
                {
                    var invokeExpr = (InvocationExpression)expr;
                    if (invokeExpr is InvokeFactoryDelegateExpression fdInvoke)
                    {
                        result = fdInvoke.FactoryDelegate(fdInvoke is InvokeFactoryDelegateOfRootOrSelfExpression ? r.Root ?? r : r);
                        return true;
                    }

                    var delegateExpr = invokeExpr.Expression;
                    if (delegateExpr is ConstantExpression dc && dc.Value is Func<IResolverContext, object> facDel)
                    {
                        if (!TryInterpret(r, invokeExpr.GetArgument(0), paramExprs, paramValues, parentArgs, out var resolver))
                            return false;
                        result = facDel((IResolverContext)resolver);
                        return true;
                    }

                    // The Invocation of Func is used for splitting the big object graphs
                    // so we can ignore this split and go directly to the body
                    if (delegateExpr.Type == typeof(Func<object>) && delegateExpr is LambdaExpression f)
                        return TryInterpret(r, f.Body, paramExprs, paramValues, parentArgs, out result);

                    if (!TryInterpret(r, delegateExpr, paramExprs, paramValues, parentArgs, out var delegateObj))
                        return false;

                    var lambda = (Delegate)delegateObj;
                    var argCount = invokeExpr.ArgumentCount;
                    if (argCount == 0)
                        result = lambda.GetMethodInfo().Invoke(lambda.Target, ArrayTools.Empty<object>());
                    else // it does not make sense to avoid array allocating for the single argument because we still need to pass array to the Invoke call
                    {
                        var args = new object[argCount];
                        for (var i = 0; i < args.Length; ++i)
                        {
                            var arg = invokeExpr.GetArgument(i);
                            if (arg is ConstantExpression ca)
                                args[i] = ca.Value;
                            else if (!TryInterpret(r, arg, paramExprs, paramValues, parentArgs, out args[i]))
                                return false;
                        }
                        result = lambda.GetMethodInfo().Invoke(lambda.Target, args);
                    }
                    return true;
                }
            case ExprType.Parameter:
                {
                    if (paramExprs != null)
                    {
                        if (paramExprs.ParameterCount == 1 && expr == paramExprs.GetParameter(0))
                        {
                            result = paramValues; // contains a single arg object
                            return true;
                        }
                        if (paramValues is object[] args) // also check that args are not null, see #470
                        {
                            for (var i = 0; i < args.Length; ++i)
                                if (expr == paramExprs.GetParameter(i))
                                {
                                    result = args[i];
                                    return true;
                                }
                        }
                    }
                    for (var p = parentArgs; p != null; p = p.ParentWithArgs)
                    {
                        if ((paramExprs = p.ParamExprs) == null)
                            continue;

                        if (paramExprs.ParameterCount == 1 && expr == paramExprs.GetParameter(0))
                        {
                            result = p.ParamValues; // contains a single arg object
                            return true;
                        }
                        if (p.ParamValues is object[] args) // also check that args are not null, see #470
                        {
                            for (var i = 0; i < args.Length; ++i)
                                if (expr == paramExprs.GetParameter(i))
                                {
                                    result = args[i];
                                    return true;
                                }
                        }
                    }
                    return false;
                }
            case ExprType.Lambda:
                return TryInterpretNestedLambda(r, (LambdaExpression)expr, paramExprs, paramValues, parentArgs, ref result);
            default:
                return false;
        }
    }

    private static bool TryInterpretNestedLambda(IResolverContext r, LambdaExpression lambdaExpr,
        IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs, ref object result)
    {
        var returnType = lambdaExpr.ReturnType;
        if (paramExprs != null)
            parentArgs = new ParentLambdaArgs(parentArgs, paramExprs, paramValues);

        // todo: @wip add specialization for the factory delegate Func<IResolverContext, object>
        if (lambdaExpr.Type == typeof(Func<IResolverContext, object>))
        {
            Debug.WriteLine("foo bar");
        }

        var bodyExpr = lambdaExpr.Body;
        var paramCount = lambdaExpr.ParameterCount;
        if (paramCount == 0)
        {
            if (returnType != typeof(void))
            {
                result = new Func<object>(() => TryInterpretNestedLambdaBodyAndUnwrapException(r, bodyExpr, null, null, parentArgs));
                if (returnType != typeof(object))
                    result = _convertFuncMethod.MakeGenericMethod(returnType).Invoke(null, new[] { result });
            }
            else
            {
                result = new Action(() => TryInterpretNestedLambdaBodyAndUnwrapException(r, bodyExpr, null, null, parentArgs));
            }
        }
        else if (paramCount == 1)
        {
            var paramExpr = lambdaExpr.GetParameter(0);
            if (returnType != typeof(void))
            {
                result = new Func<object, object>(arg => TryInterpretNestedLambdaBodyAndUnwrapException(r, bodyExpr, lambdaExpr, arg, parentArgs));
                if (paramExpr.Type != typeof(object) || returnType != typeof(object))
                    result = _convertOneArgFuncMethod.MakeGenericMethod(paramExpr.Type, returnType).Invoke(null, new[] { result });
            }
            else
            {
                result = new Action<object>(arg => TryInterpretNestedLambdaBodyAndUnwrapException(r, bodyExpr, lambdaExpr, arg, parentArgs));
                if (paramExpr.Type != typeof(object))
                    result = _convertOneArgActionMethod.MakeGenericMethod(paramExpr.Type).Invoke(null, new[] { result });
            }
        }
        else if (paramCount == 2)
        {
            var p0 = lambdaExpr.GetParameter(0);
            var p1 = lambdaExpr.GetParameter(1);
            if (returnType != typeof(void))
            {
                result = new Func<object, object, object>((a0, a1) =>
                    TryInterpretNestedLambdaBodyAndUnwrapException(r, bodyExpr, lambdaExpr, new[] { a0, a1 }, parentArgs));

                if (p0.Type != typeof(object) || p1.Type != typeof(object) || returnType != typeof(object))
                    result = _convertTwoArgFuncMethod.MakeGenericMethod(p0.Type, p1.Type, returnType).Invoke(null, new[] { result });
            }
            else
            {
                result = new Action<object, object>((a0, a1) =>
                    TryInterpretNestedLambdaBodyAndUnwrapException(r, bodyExpr, lambdaExpr, new[] { a0, a1 }, parentArgs));

                if (p0.Type != typeof(object) || p1.Type != typeof(object))
                    result = _convertTwoArgActionMethod.MakeGenericMethod(p0.Type, p1.Type).Invoke(null, new[] { result });
            }
        }
        else
        {
            // todo: @feature support interpretation of the lambdas with 5+ parameters
            if (paramCount > 4)
                return false;

            if (returnType != typeof(void))
            {
                result = new Func<object[], object>(args =>
                    TryInterpretNestedLambdaBodyAndUnwrapException(r, bodyExpr, lambdaExpr, args, parentArgs));

                var convertMethod = paramCount == 3 ? _convertThreeArgFuncMethod : _convertFourArgFuncMethod;
                result = convertMethod.MakeGenericMethod(GetParamsAndReturnType(lambdaExpr, returnType)).Invoke(null, new[] { result });
            }
            else
            {
                result = new Action<object[]>(args =>
                    TryInterpretNestedLambdaBodyAndUnwrapException(r, bodyExpr, lambdaExpr, args, parentArgs));

                var convertMethod = paramCount == 3 ? _convertThreeArgActionMethod : _convertFourArgActionMethod;
                result = convertMethod.MakeGenericMethod(GetParamTypes(lambdaExpr)).Invoke(null, new[] { result });
            }
        }

        var resultType = result.GetType();
        var lambdaType = lambdaExpr.Type;
        if ((resultType.GetGenericDefinitionOrNull() ?? resultType) != (lambdaType.GetGenericDefinitionOrNull() ?? lambdaType))
            result = ((Delegate)result).GetMethodInfo().CreateDelegate(lambdaType, ((Delegate)result).Target);

        return true;
    }

    private static Type[] GetParamTypes(IParameterProvider ps)
    {
        var count = ps.ParameterCount;
        var ts = new Type[count];
        for (var i = 0; i < ts.Length; ++i)
            ts[i] = ps.GetParameter(i).Type;
        return ts;
    }
    private static Type[] GetParamsAndReturnType(IParameterProvider ps, Type returnType)
    {
        var count = ps.ParameterCount;
        var ts = new Type[count + 1];
        for (var i = 0; i < count; ++i)
            ts[i] = ps.GetParameter(i).Type;
        ts[count] = returnType;
        return ts;
    }

    internal static object TryInterpretNestedLambdaBodyAndUnwrapException(IResolverContext r,
        Expression bodyExpr, IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs)
    {
        try
        {
            if (!TryInterpret(r, bodyExpr, paramExprs, paramValues, parentArgs, out var lambdaResult))
                Throw.It(Error.UnableToInterpretTheNestedLambda, bodyExpr);
            return lambdaResult;
        }
        catch (TargetInvocationException tex) when (tex.InnerException != null)
        {
            throw tex.InnerException.TryRethrowWithPreservedStackTrace();
        }
    }

    internal static Func<IResolverContext, R> ConvertFactoryDelegate<R>(Func<IResolverContext, object> f) => r =>
        (R)f(r);
    internal static readonly MethodInfo ConvertFactoryDelegateMethod = typeof(Interpreter).GetMethod(nameof(ConvertFactoryDelegate), BindingFlags.NonPublic | BindingFlags.Static);

    internal static Func<R> ConvertFunc<R>(Func<object> f) => () => (R)f();
    private static readonly MethodInfo _convertFuncMethod = typeof(Interpreter).GetMethod(nameof(ConvertFunc), BindingFlags.NonPublic | BindingFlags.Static);

    internal static Func<T, R> ConvertOneArgFunc<T, R>(Func<object, object> f) => a => (R)f(a);
    private static readonly MethodInfo _convertOneArgFuncMethod = typeof(Interpreter).GetMethod(nameof(ConvertOneArgFunc), BindingFlags.NonPublic | BindingFlags.Static);

    internal static Action<T> ConvertOneArgAction<T>(Action<object> f) => a => f(a);
    private static readonly MethodInfo _convertOneArgActionMethod = typeof(Interpreter).GetMethod(nameof(ConvertOneArgAction), BindingFlags.NonPublic | BindingFlags.Static);

    internal static Func<T0, T1, R> ConvertTwoArgFunc<T0, T1, R>(Func<object, object, object> f) => (a0, a1) => (R)f(a0, a1);
    private static readonly MethodInfo _convertTwoArgFuncMethod = typeof(Interpreter).GetMethod(nameof(ConvertTwoArgFunc), BindingFlags.NonPublic | BindingFlags.Static);

    internal static Action<T0, T1> ConvertTwoArgAction<T0, T1>(Action<object, object> f) => (a0, a1) => f(a0, a1);
    private static readonly MethodInfo _convertTwoArgActionMethod = typeof(Interpreter).GetMethod(nameof(ConvertTwoArgAction), BindingFlags.NonPublic | BindingFlags.Static);

    internal static Func<T0, T1, T2, R> ConvertThreeArgFunc<T0, T1, T2, R>(Func<object[], object> f) => (a0, a1, a2) => (R)f(new object[] { a0, a1, a2 });
    private static readonly MethodInfo _convertThreeArgFuncMethod = typeof(Interpreter).GetMethod(nameof(ConvertThreeArgFunc), BindingFlags.NonPublic | BindingFlags.Static);

    internal static Action<T0, T1, T2> ConvertThreeArgAction<T0, T1, T2>(Action<object[]> f) => (a0, a1, a2) => f(new object[] { a0, a1, a2 });
    private static readonly MethodInfo _convertThreeArgActionMethod = typeof(Interpreter).GetMethod(nameof(ConvertThreeArgAction), BindingFlags.NonPublic | BindingFlags.Static);

    internal static Func<T0, T1, T2, T3, R> ConvertFourArgFunc<T0, T1, T2, T3, R>(Func<object[], object> f) => (a0, a1, a2, a3) => (R)f(new object[] { a0, a1, a2, a3 });
    private static readonly MethodInfo _convertFourArgFuncMethod = typeof(Interpreter).GetMethod(nameof(ConvertFourArgFunc), BindingFlags.NonPublic | BindingFlags.Static);

    internal static Action<T0, T1, T2, T3> ConvertFourArgAction<T0, T1, T2, T3>(Action<object[]> f) => (a0, a1, a2, a3) => f(new object[] { a0, a1, a2, a3 });
    private static readonly MethodInfo _convertFourArgActionMethod = typeof(Interpreter).GetMethod(nameof(ConvertFourArgAction), BindingFlags.NonPublic | BindingFlags.Static);

    private static bool TryInterpretMethodCall(IResolverContext r, MethodCallExpression callExpr,
        IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs, ref object result)
    {
        // the order of the 2 expressions cases is intentional starting from the subtype to the supertype
        if (callExpr is CurrentScopeReuse.GetScopedOrSingletonViaFactoryDelegateWithDisposalOrderExpression sd)
        {
            result = InterpretGetScopedOrSingletonViaFactoryDelegateWithDisposalOrder(r, sd, paramExprs, paramValues, parentArgs);
            return true;
        }

        if (callExpr is CurrentScopeReuse.GetScopedOrSingletonViaFactoryDelegateExpression s)
        {
            result = InterpretGetScopedOrSingletonViaFactoryDelegate(r, s, paramExprs, paramValues, parentArgs);
            return true;
        }

        if (callExpr is IFuncInvokeExpression)
            return TryInterpretFuncInvoke(r, callExpr, paramExprs, paramValues, parentArgs, ref result);

        var method = callExpr.Method;
        var methodDeclaringType = method.DeclaringType;

        if (methodDeclaringType == typeof(CurrentScopeReuse))
        {
            if (method == CurrentScopeReuse.GetNameScopedViaFactoryDelegateMethod)
            {
                result = InterpretGetNameScopedViaFactoryDelegate(r, callExpr, paramExprs, paramValues, parentArgs);
                return true;
            }

            var resolver = r;
            var rArg = callExpr.GetArgument(0);
            if (!ReferenceEquals(rArg, FactoryDelegateCompiler.ResolverContextParamExpr))
            {
                if (!TryInterpret(resolver, rArg, paramExprs, paramValues, parentArgs, out var resolverObj))
                    return false;
                resolver = (IResolverContext)resolverObj;
            }

            if (method == CurrentScopeReuse.TrackScopedOrSingletonMethod)
            {
                var args = (TwoArgumentsMethodCallExpression)callExpr;
                if (!TryInterpret(resolver, args.Argument1, paramExprs, paramValues, parentArgs, out var service))
                    return false;
                result = CurrentScopeReuse.TrackScopedOrSingleton(resolver, service);
                return true;
            }

            if (method == CurrentScopeReuse.TrackScopedMethod)
            {
                var args = (ThreeArgumentsMethodCallExpression)callExpr;
                var scope = resolver.GetCurrentScope((bool)ConstValue(args.Argument1));
                if (scope == null)
                    result = null; // result is null in this case
                else
                {
                    if (!TryInterpret(resolver, args.Argument2, paramExprs, paramValues, parentArgs, out var service))
                        return false;
                    result = service is IDisposable d ? scope.TrackDisposable(d) : service;
                }
                return true;
            }

            if (method == CurrentScopeReuse.TrackNameScopedMethod)
            {
                var args = (FourArgumentsMethodCallExpression)callExpr;
                var scope = resolver.GetNamedScope(ConstValue(args.Argument1), (bool)ConstValue(args.Argument2));
                if (scope == null)
                    result = null; // result is null in this case
                else
                {
                    if (!TryInterpret(resolver, args.Argument3, paramExprs, paramValues, parentArgs, out var service))
                        return false;
                    result = service is IDisposable d ? scope.TrackDisposable(d) : service;
                }
                return true;
            }
        }
        else if (methodDeclaringType == typeof(IScope))
        {
            if (method == Scope.GetOrAddViaFactoryDelegateMethod)
            {
                var args = (InstanceThreeArgumentsMethodCallExpression)callExpr;
                // check if scoped dependency is already in scope, then just return it
                var factoryId = TryGetIntConstantValue(args.Argument0);
                if (!r.SingletonScope.TryGet(out result, factoryId))
                {
                    result = r.SingletonScope.TryGetOrAddWithoutClosure(factoryId, r, ((LambdaExpression)args.Argument1).Body,
                        (rc, e) =>
                        {
                            if (TryInterpret(rc, e, paramExprs, paramValues, parentArgs, out var value))
                                return value;
                            return e.CompileOrInterpretFactoryDelegate(rc.Rules.UseInterpretation)(rc);
                        });
                }
                return true;
            }

            if (method == Scope.GetOrAddViaFactoryDelegateWithDisposalOrderMethod)
            {
                var args = (InstanceFourArgumentsMethodCallExpression)callExpr;
                r = r.Root ?? r;
                // check if scoped dependency is already in scope, then just return it
                var factoryId = TryGetIntConstantValue(args.Argument0);
                if (!r.SingletonScope.TryGet(out result, factoryId))
                {
                    result = r.SingletonScope.TryGetOrAddWithoutClosure(factoryId, r, ((LambdaExpression)args.Argument1).Body,
                        // todo: @perf @memory optimize closure away
                        (rc, e) => TryInterpret(rc, e, paramExprs, paramValues, parentArgs, out var value)
                            ? value
                            : e.CompileOrInterpretFactoryDelegate(rc.Rules.UseInterpretation)(rc),
                        TryGetIntConstantValue(args.Argument3));
                }
                return true;
            }

            if (method.IsGenericMethod && method.GetGenericMethodDefinition() == Scope.TrackDisposableOpenGenericMethod)
            {
                var args = (InstanceTwoArgumentsMethodCallExpression)callExpr;
                if (!TryInterpret(r, args.Argument0, paramExprs, paramValues, parentArgs, out var service))
                    return false;
                if (service is IDisposable d)
                    result = r.SingletonScope.TrackDisposable(d, TryGetIntConstantValue(args.Argument1));
                return true;
            }
        }
        else if (methodDeclaringType == typeof(IResolver))
        {
            var resolver = r;
            if (!ReferenceEquals(callExpr.Object, FactoryDelegateCompiler.ResolverContextParamExpr))
            {
                if (!TryInterpret(resolver, callExpr.Object, paramExprs, paramValues, parentArgs, out var resolverObj))
                    return false;
                resolver = (IResolverContext)resolverObj;
            }

            if (method == Resolver.ResolveFastMethod)
            {
                var args = (InstanceTwoArgumentsMethodCallExpression)callExpr;
                result = resolver.Resolve((Type)ConstValue(args.Argument0), (IfUnresolved)ConstValue(args.Argument1));
                return true;
            }

            if (method == Resolver.ResolveMethod)
            {
                var args = (InstanceSixArgumentsMethodCallExpression)callExpr;
                TryInterpret(resolver, args.Argument1, paramExprs, paramValues, parentArgs, out var serviceKey);
                TryInterpret(resolver, args.Argument4, paramExprs, paramValues, parentArgs, out var preResolveParent);
                TryInterpret(resolver, args.Argument5, paramExprs, paramValues, parentArgs, out var resolveArgs);
                result = resolver.Resolve(
                    (Type)ConstValue(args.Argument0), serviceKey, (IfUnresolved)ConstValue(args.Argument2),
                    (Type)ConstValue(args.Argument3), (Request)preResolveParent, (object[])resolveArgs);
                return true;
            }

            if (method == Resolver.ResolveManyMethod)
            {
                var fiveArgs = (InstanceFiveArgumentsMethodCallExpression)callExpr;
                TryInterpret(resolver, fiveArgs.Argument1, paramExprs, paramValues, parentArgs, out var serviceKey);
                TryInterpret(resolver, fiveArgs.Argument3, paramExprs, paramValues, parentArgs, out var preResolveParent);
                TryInterpret(resolver, fiveArgs.Argument4, paramExprs, paramValues, parentArgs, out var resolveArgs);
                result = resolver.ResolveMany(
                    (Type)ConstValue(fiveArgs.Argument0), serviceKey, (Type)ConstValue(fiveArgs.Argument2), (Request)preResolveParent, (object[])resolveArgs);
                return true;
            }
        }

        if (ReferenceEquals(callExpr, ResolverContext.RootOrSelfExpr))
        {
            result = r.Root ?? r;
            return true;
        }

        // fallback to reflection invocation
        object instance = null;
        var callObjectExpr = callExpr.Object;
        if (callObjectExpr != null)
        {
            if (callObjectExpr is ConstantExpression oc)
                instance = oc.Value;
            else if (!TryInterpret(r, callObjectExpr, paramExprs, paramValues, parentArgs, out instance))
                return false;
        }

        var argCount = callExpr.ArgumentCount;
        if (argCount == 0)
            result = method.Invoke(instance, ArrayTools.Empty<object>());
        else
        {
            var args = new object[argCount];
            for (var i = 0; i < args.Length; ++i)
            {
                var argExpr = callExpr.GetArgument(i);
                if (argExpr is ConstantExpression ac)
                    args[i] = ac.Value;
                else if (!TryInterpret(r, argExpr, paramExprs, paramValues, parentArgs, out args[i]))
                    return false;
            }
            result = method.Invoke(instance, args);
        }

        return true;
    }

    private static bool TryInterpretFuncInvoke(IResolverContext r, MethodCallExpression e,
        IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs, ref object result)
    {
        var argCount = e.ArgumentCount;
        if (argCount == 0)
            result = ((Func<object>)((FuncInvoke0Expression)e).Func)();
        else if (argCount == 1)
        {
            var f1 = (FuncInvoke1Expression)e;
            if (!TryInterpret(r, f1.Argument, paramExprs, paramValues, parentArgs, out var a0))
                return false;
            result = ((Func<object, object>)f1.Func)(a0);
        }
        else if (argCount == 2)
        {
            var f2 = (FuncInvoke2Expression)e;
            if (!TryInterpret(r, f2.Argument0, paramExprs, paramValues, parentArgs, out var a0) ||
                !TryInterpret(r, f2.Argument1, paramExprs, paramValues, parentArgs, out var a1))
                return false;
            result = ((Func<object, object, object>)f2.Func)(a0, a1);
        }
        else if (argCount == 3)
        {
            var f3 = (FuncInvoke3Expression)e;
            if (!TryInterpret(r, f3.Argument0, paramExprs, paramValues, parentArgs, out var a0) ||
                !TryInterpret(r, f3.Argument1, paramExprs, paramValues, parentArgs, out var a1) ||
                !TryInterpret(r, f3.Argument2, paramExprs, paramValues, parentArgs, out var a2))
                return false;
            result = ((Func<object, object, object, object>)f3.Func)(a0, a1, a2);
        }
        else if (argCount == 4)
        {
            var f4 = (FuncInvoke4Expression)e;
            if (!TryInterpret(r, f4.Argument0, paramExprs, paramValues, parentArgs, out var a0) ||
                !TryInterpret(r, f4.Argument1, paramExprs, paramValues, parentArgs, out var a1) ||
                !TryInterpret(r, f4.Argument2, paramExprs, paramValues, parentArgs, out var a2) ||
                !TryInterpret(r, f4.Argument3, paramExprs, paramValues, parentArgs, out var a3))
                return false;
            result = ((Func<object, object, object, object, object>)f4.Func)(a0, a1, a2, a3);
        }
        else if (argCount == 5)
        {
            var f5 = (FuncInvoke5Expression)e;
            if (!TryInterpret(r, f5.Argument0, paramExprs, paramValues, parentArgs, out var a0) ||
                !TryInterpret(r, f5.Argument1, paramExprs, paramValues, parentArgs, out var a1) ||
                !TryInterpret(r, f5.Argument2, paramExprs, paramValues, parentArgs, out var a2) ||
                !TryInterpret(r, f5.Argument3, paramExprs, paramValues, parentArgs, out var a3) ||
                !TryInterpret(r, f5.Argument4, paramExprs, paramValues, parentArgs, out var a4))
                return false;
            result = ((Func<object, object, object, object, object, object>)f5.Func)(a0, a1, a2, a3, a4);
        }
        else if (argCount == 6)
        {
            var f6 = (FuncInvoke6Expression)e;
            if (!TryInterpret(r, f6.Argument0, paramExprs, paramValues, parentArgs, out var a0) ||
                !TryInterpret(r, f6.Argument1, paramExprs, paramValues, parentArgs, out var a1) ||
                !TryInterpret(r, f6.Argument2, paramExprs, paramValues, parentArgs, out var a2) ||
                !TryInterpret(r, f6.Argument3, paramExprs, paramValues, parentArgs, out var a3) ||
                !TryInterpret(r, f6.Argument4, paramExprs, paramValues, parentArgs, out var a4) ||
                !TryInterpret(r, f6.Argument5, paramExprs, paramValues, parentArgs, out var a5))
                return false;
            result = ((Func<object, object, object, object, object, object, object>)f6.Func)(a0, a1, a2, a3, a4, a5);
        }
        else
        {
            var f7 = (FuncInvoke7Expression)e;
            if (!TryInterpret(r, f7.Argument0, paramExprs, paramValues, parentArgs, out var a0) ||
                !TryInterpret(r, f7.Argument1, paramExprs, paramValues, parentArgs, out var a1) ||
                !TryInterpret(r, f7.Argument2, paramExprs, paramValues, parentArgs, out var a2) ||
                !TryInterpret(r, f7.Argument3, paramExprs, paramValues, parentArgs, out var a3) ||
                !TryInterpret(r, f7.Argument4, paramExprs, paramValues, parentArgs, out var a4) ||
                !TryInterpret(r, f7.Argument5, paramExprs, paramValues, parentArgs, out var a5) ||
                !TryInterpret(r, f7.Argument6, paramExprs, paramValues, parentArgs, out var a6))
                return false;
            result = ((Func<object, object, object, object, object, object, object, object>)f7.Func)(a0, a1, a2, a3, a4, a5, a6);
        }
        return true;
    }

    private static object InterpretGetScopedOrSingletonViaFactoryDelegate(
        IResolverContext r, CurrentScopeReuse.GetScopedOrSingletonViaFactoryDelegateExpression e,
        IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs)
    {
        Scope scope;
        if (e is CurrentScopeReuse.CurrentScopeGetScopedViaFactoryDelegateExpression cs)
        {
            scope = (Scope)r.CurrentScope; // todo: @perf cast IResolverContext and avoid virtual calls, @unsafe cast to Scope
            if (scope == null)
                return null;
        }
        else if (e is CurrentScopeReuse.ThrowIfNoScopeGetScopedViaFactoryDelegateExpression ts)
        {
            scope = (Scope)r.CurrentScope;
            if (scope == null)
                return Throw.For<IScope>(Error.NoCurrentScope, r);
        }
        else
            scope = (Scope)r.CurrentOrSingletonScope; // todo: @perf cast IResolverContext and avoid virtual calls, @unsafe cast to Scope

        var id = e.FactoryID;
        var noItem = Scope.NoItem;
        ref var map = ref scope._maps[id & Scope.MAP_COUNT_SUFFIX_MASK];
        var itemRef = map.GetEntryOrDefault(id);
        if (itemRef != null && itemRef.Value != noItem)
            return itemRef.Value;

        if (scope.IsDisposed)
            Throw.ScopeIsDisposed(scope, r);

        itemRef = ImHashMap.Entry(id, noItem);
        var oldMap = map;
        var newMap = oldMap.AddOrKeepEntry(itemRef);
        if (Interlocked.CompareExchange(ref map, newMap, oldMap) != oldMap)
        {
            newMap = Ref.SwapAndGetNewValue(ref map, itemRef, static (x, i) => x.AddOrKeepEntry(i));
            var otherItemRef = newMap.GetSurePresent(id);
            if (otherItemRef != itemRef)
                return otherItemRef.Value != noItem ? otherItemRef.Value : Scope.WaitForItemIsSet(otherItemRef);
        }
        else if (newMap == oldMap)
        {
            var otherItemRef = newMap.GetSurePresent(id);
            return otherItemRef.Value != noItem ? otherItemRef.Value : Scope.WaitForItemIsSet(otherItemRef);
        }

        object result = null;
        var serviceExpr = e.ServiceOrInvokeExpr;
        if (serviceExpr is InvokeFactoryDelegateExpression invokeExpr)
            result = invokeExpr.FactoryDelegate(r);
        else if (!TryInterpret(r, serviceExpr, paramExprs, paramValues, parentArgs, out result))
            result = serviceExpr.CompileOrInterpretFactoryDelegate(r.Rules.UseInterpretation)(r);

        itemRef.Value = result;
        if (result is IDisposable disp && !ReferenceEquals(disp, scope))
            scope.AddUnorderedDisposable(disp);
        return result;
    }

    private static object InterpretGetScopedOrSingletonViaFactoryDelegateWithDisposalOrder(
        IResolverContext r, CurrentScopeReuse.GetScopedOrSingletonViaFactoryDelegateWithDisposalOrderExpression e,
        IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs)
    {
        Scope scope;
        if (e is CurrentScopeReuse.CurrentScopeGetScopedViaFactoryDelegateWithDisposalOrderExpression cs)
        {
            scope = (Scope)r.CurrentScope; // todo: @perf cast IResolverContext and avoid virtual calls, @unsafe cast to Scope
            if (scope == null)
                return null;
        }
        else if (e is CurrentScopeReuse.ThrowIfNoScopeGetScopedViaFactoryDelegateWithDisposalOrderExpression ts)
        {
            scope = (Scope)r.CurrentScope;
            if (scope == null)
                return Throw.For<IScope>(Error.NoCurrentScope, r);
        }
        else
            scope = (Scope)r.CurrentOrSingletonScope; // todo: @perf cast IResolverContext and avoid virtual calls, @unsafe cast to Scope


        var id = e.FactoryID;

        ref var map = ref scope._maps[id & Scope.MAP_COUNT_SUFFIX_MASK];
        var itemRef = map.GetEntryOrDefault(id);
        if (itemRef != null && itemRef.Value != Scope.NoItem)
            return itemRef.Value;

        if (scope.IsDisposed)
            Throw.ScopeIsDisposed(scope, r);

        itemRef = ImHashMap.Entry(id, Scope.NoItem);
        var oldMap = map;
        var newMap = oldMap.AddOrKeepEntry(itemRef);
        if (Interlocked.CompareExchange(ref map, newMap, oldMap) != oldMap)
        {
            newMap = Ref.SwapAndGetNewValue(ref map, itemRef, static (x, i) => x.AddOrKeepEntry(i));
            var otherItemRef = newMap.GetSurePresent(id);
            if (otherItemRef != itemRef)
                return otherItemRef.Value != Scope.NoItem ? otherItemRef.Value : Scope.WaitForItemIsSet(otherItemRef);
        }
        else if (newMap == oldMap)
        {
            var otherItemRef = newMap.GetSurePresent(id);
            return otherItemRef.Value != Scope.NoItem ? otherItemRef.Value : Scope.WaitForItemIsSet(otherItemRef);
        }

        object result = null;
        var serviceExpr = e.ServiceOrInvokeExpr;
        if (serviceExpr is InvokeFactoryDelegateExpression invokeExpr)
            result = invokeExpr.FactoryDelegate(r);
        else if (!TryInterpret(r, serviceExpr, paramExprs, paramValues, parentArgs, out result))
            result = serviceExpr.CompileOrInterpretFactoryDelegate(r.Rules.UseInterpretation)(r);

        itemRef.Value = result;
        if (result is IDisposable disp && !ReferenceEquals(disp, scope))
            scope.AddDisposable(disp, e.DisposalOrder);
        return result;
    }

    private static object InterpretGetNameScopedViaFactoryDelegate(
        IResolverContext r, MethodCallExpression callExpr, IParameterProvider paramExprs, object paramValues, ParentLambdaArgs parentArgs)
    {
        var args = (SixArgumentsMethodCallExpression)callExpr;
        if (!ReferenceEquals(args.Argument0, FactoryDelegateCompiler.ResolverContextParamExpr))
        {
            if (!TryInterpret(r, args.Argument0, paramExprs, paramValues, parentArgs, out var resolverObj))
                return false;
            r = (IResolverContext)resolverObj;
        }

        var scope = (Scope)r.GetNamedScope(ConstValue(args.Argument1), (bool)ConstValue(args.Argument2));// todo: @unsafe cast to Scope,
        if (scope == null)
            return null; // result is null in this case

        // check if scoped dependency is already in scope, then just return it
        var id = TryGetIntConstantValue(args.Argument3);

        ref var map = ref scope._maps[id & Scope.MAP_COUNT_SUFFIX_MASK];
        var itemRef = map.GetEntryOrDefault(id);
        if (itemRef != null && itemRef.Value != Scope.NoItem)
            return itemRef.Value;

        itemRef = ImHashMap.Entry(id, Scope.NoItem);
        var oldMap = map;
        var newMap = oldMap.AddOrKeepEntry(itemRef);
        if (Interlocked.CompareExchange(ref map, newMap, oldMap) != oldMap)
        {
            newMap = Ref.SwapAndGetNewValue(ref map, itemRef, static (x, i) => x.AddOrKeepEntry(i));
            var otherItemRef = newMap.GetSurePresent(id);
            if (otherItemRef != itemRef)
                return otherItemRef.Value != Scope.NoItem ? otherItemRef.Value : Scope.WaitForItemIsSet(otherItemRef);
        }
        else if (newMap == oldMap)
        {
            var otherItemRef = newMap.GetSurePresent(id);
            return otherItemRef.Value != Scope.NoItem ? otherItemRef.Value : Scope.WaitForItemIsSet(otherItemRef);
        }

        var lambda = args.Argument4;
        object result = null;
        // todo: @perf optimize
        if (lambda is ConstantExpression lambdaConstExpr)
            result = ((Func<IResolverContext, object>)lambdaConstExpr.Value)(r);
        else if (!TryInterpret(r, ((LambdaExpression)lambda).Body, paramExprs, paramValues, parentArgs, out result))
            result = ((LambdaExpression)lambda).Body.CompileOrInterpretFactoryDelegate(r.Rules.UseInterpretation)(r);

        itemRef.Value = result;
        if (result is IDisposable disp)
            scope.AddDisposable(disp, TryGetIntConstantValue(args.Argument5));
        return result;
    }

    [MethodImpl((MethodImplOptions)256)]
    private static object ConstValue(Expression expr) => ((ConstantExpression)expr).Value;
}

internal static class Converter
{
    public static object ConvertWithOperator(object source, Expression expr, Type targetType, MethodInfo convertMethod = null)
    {
        if (convertMethod != null)
            return convertMethod.Invoke(null, new[] { source });

        var sourceType = source.GetType();
        var sourceConvertOp = sourceType.FindConvertOperator(sourceType, targetType);
        if (sourceConvertOp != null)
            return sourceConvertOp.Invoke(null, new[] { source });

        var targetConvertOp = targetType.FindConvertOperator(sourceType, targetType);
        if (targetConvertOp == null)
            Throw.It(Error.NoConversionOperatorFoundWhenInterpretingTheConvertExpression, source, targetType, expr);
        return targetConvertOp.Invoke(null, new[] { source });
    }

    public static object ConvertMany(object[] source, Type targetType) =>
        _convertManyMethod.MakeGenericMethod(targetType).Invoke(null, source.One());

    public static R[] DoConvertMany<R>(object[] items)
    {
        if (items == null || items.Length == 0)
            return ArrayTools.Empty<R>();

        var results = new R[items.Length];
        for (var i = 0; i < items.Length; i++)
            results[i] = (R)items[i];
        return results;
    }

    private static readonly MethodInfo _convertManyMethod = typeof(Converter).GetMethod(nameof(DoConvertMany));
}

/// <summary>Compiles expression to factory delegate.</summary>
public static class FactoryDelegateCompiler
{
    // Holds the expression meanwhile it is being compiled to indicate this fact for another threads
    internal sealed class Compiling
    {
        public readonly Expression Expression;
        public Compiling(Expression expression) => Expression = expression;
    }

    // Holds the interpreted or compiled and invoked result of service resolution, to distinguish it from the factory delegate
    internal sealed class CachedResult
    {
        public readonly object Instance;
        public CachedResult(object instance) => Instance = instance;
    }

    [MethodImpl((MethodImplOptions)256)]
    internal static CachedResult ToCachedResult(this object result) => new CachedResult(result);

    /// <summary>Resolver context parameter expression in FactoryDelegate.</summary>
    public static readonly ParameterExpression ResolverContextParamExpr = ParameterOf<IResolverContext>("r");

    /// <summary>The array of a single `ResolverContextParamExpr` for memory optimization</summary>
    public static readonly ParameterExpression[] ResolverContextParamExprs = { ResolverContextParamExpr };

    /// <summary>Invoke method info for calling from Reflection</summary>
    public static MethodInfo InvokeMethod = typeof(Func<IResolverContext, object>).GetMethod("Invoke");

    /// Optimization: the empty lambda with a single IResolverContext parameters
    internal static readonly OneParameterLambdaExpression FactoryDelegateParamExprs = new OneParameterLambdaExpression(null, null, ResolverContextParamExpr);

    /// <summary>Strips the unnecessary or adds the necessary cast to expression return result</summary>
    public static Expression NormalizeExpression(this Expression expr)
    {
        if (expr.NodeType == ExprType.Convert)
        {
            var operandExpr = ((UnaryExpression)expr).Operand;
            if (operandExpr.Type == typeof(object))
                return operandExpr;
        }
        var exprType = expr.Type;
        return exprType != typeof(void) & exprType.IsValueType ? new ConvertIntrinsicExpression<object>(expr) : expr;
    }

    /// <summary>Wraps service creation expression (body) into `Func{IResolverContext, object}` and returns result lambda expression.</summary>
    public static Expression<Func<IResolverContext, object>> WrapInFactoryExpression(this Expression expression) =>
        new FactoryDelegateExpression(expression.NormalizeExpression());

    /// <summary>Wraps service creation expression (body) into `Func{IResolverContext, object}` and returns result lambda expression.</summary>
    public static Expression<Func<IResolverContext, object>> WrapInFactoryExpressionWithoutNormalization(this Expression expression) =>
        new FactoryDelegateExpression(expression);

    private static Type[] _factoryDelegateAndClosureParams = new[] { typeof(ExpressionCompiler.ArrayClosure), typeof(IResolverContext) };

    /// <summary>Compiles or interprets the passed expression based on the second parameter `preferInterpretation`.
    /// If the passed expression is already a constant with the result, it should be handled by the calling side.</summary>
    public static Func<IResolverContext, object> CompileOrInterpretFactoryDelegate(this Expression expression, bool preferInterpretation)
    {
        // let's be on the safe side and convert value types to object if required
        expression = expression.NormalizeExpression();
        if (!preferInterpretation)
        {
            var factoryDelegate = (Func<IResolverContext, object>)(ExpressionCompiler.TryCompileBoundToFirstClosureParam(
                typeof(Func<IResolverContext, object>), expression, FactoryDelegateParamExprs, _factoryDelegateAndClosureParams, typeof(object),
                CompilerFlags.NoInvocationLambdaInlining));
            if (factoryDelegate != null)
                return factoryDelegate;
        }

        // It is required for the expression based Made.Of (sigh...) and ExpressionFactory with an arbitrary expressions, not covered by the own DryIoc Interpreter (sigh...).
        // Or as a fallback to the platforms where FastExpressionCompiler is not able to compile the expression.
        return new FactoryDelegateExpression(expression).ToLambdaExpression()
            .Compile(
#if SUPPORTS_EXPRESSION_COMPILE_WITH_PREFER_INTERPRETATION_PARAM
                preferInterpretation
#endif
            );
    }

    /// <summary>Compiles the passed expression into the Func{IResolverContext, ResultType}.</summary>
    public static object CompileTypedResultFactoryDelegate(
        this Expression expression, Type factoryDelegateType, Type resultType)
    {
        var customFactoryDelegate = ExpressionCompiler.TryCompileBoundToFirstClosureParam(
            factoryDelegateType, expression, FactoryDelegateParamExprs, _factoryDelegateAndClosureParams, resultType,
            CompilerFlags.NoInvocationLambdaInlining);
        if (customFactoryDelegate != null)
            return customFactoryDelegate;
        return Lambda(factoryDelegateType, expression, ResolverContextParamExpr, resultType).ToLambdaExpression().Compile();
    }
}

// It is not an intrinsic because it is harder to correctly isolate the nested lambda both in the Collecting and Emitting phase
internal sealed class FactoryDelegateExpression : Expression<Func<IResolverContext, object>>
{
    public override Type ReturnType => typeof(object);
    public override int ParameterCount => 1;
    public override IReadOnlyList<ParameterExpression> Parameters => FactoryDelegateCompiler.ResolverContextParamExprs;
    public override ParameterExpression GetParameter(int index) => FactoryDelegateCompiler.ResolverContextParamExpr;
    public FactoryDelegateExpression(Expression body) : base(body) { }
}

/// <summary>Result of GenerateResolutionExpressions methods</summary>
public struct GeneratedExpressions
{
    /// <summary>Resolutions roots</summary>
    public readonly List<KeyValuePair<ServiceInfo, Expression<Func<IResolverContext, object>>>> Roots = new();
    /// <summary>Dependency of Resolve calls</summary>
    public readonly List<KeyValuePair<Request, Expression>> ResolveDependencies = new();
    /// <summary>Errors</summary>
    public readonly List<KeyValuePair<ServiceInfo, ContainerException>> Errors = new();
    /// <summary>Default constructor</summary>
    public GeneratedExpressions() { }
}

/// <summary>Container extended features.</summary>
public static class ContainerTools
{
    internal static readonly ConstantExpression NullTypeConstant = ConstantNull<Type>();
    [MethodImpl((MethodImplOptions)256)]
    internal static ConstantExpression ToConstant(this Type type) =>
        type == null ? NullTypeConstant : ConstantOf<Type>(type);

    internal static readonly ConstantExpression IfUnresolvedThrowConstant = Constant(IfUnresolved.Throw);
    internal static readonly ConstantExpression IfUnresolvedReturnDefaultConstant = Constant(IfUnresolved.ReturnDefault);
    internal static readonly ConstantExpression IfUnresolvedReturnDefaultIfNotRegisteredConstant = Constant(IfUnresolved.ReturnDefaultIfNotRegistered);

    [MethodImpl((MethodImplOptions)256)]
    internal static ConstantExpression ToConstant(this IfUnresolved ifUnresolved) =>
        ifUnresolved == IfUnresolved.Throw ? IfUnresolvedThrowConstant :
        ifUnresolved == IfUnresolved.ReturnDefault ? IfUnresolvedThrowConstant :
        IfUnresolvedReturnDefaultIfNotRegisteredConstant;

    /// <summary>Creates new container from the current one by specifying the listed parameters.
    /// If the null or default values are provided then the default or new values will be applied.
    /// Nothing will be inherited from the current container. If you want to inherit something you need to provide it as parameter.</summary>
    public static T With<T>(this T container, IResolverContext parent, Rules rules, IScopeContext scopeContext,
        RegistrySharing registrySharing, IScope singletonScope, IScope currentScope) where T : IContainer =>
        (T)container.With(parent, rules, scopeContext, registrySharing, singletonScope, currentScope, null);

    /// <summary>Creates new container from the current one by specifying the listed parameters.
    /// If the null or default values are provided then the default or new values will be applied.
    /// Nothing will be inherited from the current container. If you want to inherit something you need to provide it as parameter.</summary>
    public static T With<T>(this T container, Rules rules, IScopeContext scopeContext, RegistrySharing registrySharing, IScope singletonScope) where T : IContainer =>
        container.With(container.Parent, rules, scopeContext, registrySharing, singletonScope, container.OwnCurrentScope);

    /// <summary>Produces new container which prevents any further registrations.
    /// An optional parameter <paramref name="ignoreInsteadOfThrow" /> controls what to do with registrations: ignore or throw exception.</summary>
    public static T WithNoMoreRegistrationAllowed<T>(this T container, bool ignoreInsteadOfThrow = false) where T : IContainer =>
        (T)container.With(container.Parent, container.Rules, container.ScopeContext, RegistrySharing.Share, container.SingletonScope, container.OwnCurrentScope,
            ignoreInsteadOfThrow ? IsRegistryChangePermitted.Ignored : IsRegistryChangePermitted.Error);

    /// <summary>The default key for services registered into container created by <see cref="CreateFacade"/></summary>
    public const string FacadeKey = "@facade";

    /// <summary>Uses the provided or the default <see cref="FacadeKey" /> to tweak the rules
    /// to use with the `CreateFacade` methods</summary>
    public static Rules WithFacadeRules(this Rules rules, string facadeKey = FacadeKey) =>
        rules.WithDefaultRegistrationServiceKey(facadeKey)
                .WithFactorySelector(Rules.SelectKeyedOverDefaultFactory(facadeKey));

    /// <summary>Allows to register new specially keyed services which will facade the same default service,
    /// registered earlier. May be used to "override" registrations when testing the container.
    /// Facade will clone the source container singleton and open scope (if any) so
    /// that you may safely disposing the facade without disposing the source container scopes.</summary>
    public static T CreateFacade<T>(this T container, string facadeKey = FacadeKey) where T : IContainer =>
        container.CreateChild(newRules: container.Rules.WithFacadeRules(facadeKey));

    /// <summary>The "child" container detached from the parent container.
    /// With <paramref name="registrySharing" /> you control how registrations will be shared or separated between the parent and child.
    /// The not `null` <paramref name="childDefaultServiceKey" /> will allow mark services registered to child with the specified key,
    /// making them invisible for the parent (if they share the registry). Meanwhile you may resolve them from the child without
    /// specifying any key. So the `childDefaultServiceKey` is like an invisible stamp on the child registration.
    /// </summary>
    public static IContainer CreateChild(this IContainer container,
        RegistrySharing registrySharing, object childDefaultServiceKey = null,
        IfAlreadyRegistered? ifAlreadyRegistered = null, Rules newRules = null, bool withDisposables = false)
    {
        var rules = newRules != null && newRules != container.Rules ? newRules : container.Rules;
        if (childDefaultServiceKey != null)
            rules = rules
                .WithDefaultRegistrationServiceKey(childDefaultServiceKey)
                .WithFactorySelector(Rules.SelectKeyedOverDefaultFactory(childDefaultServiceKey));
        if (ifAlreadyRegistered != null)
            rules = rules
                .WithDefaultIfAlreadyRegistered(ifAlreadyRegistered.Value);
        return container.With(
            container.Parent,
            rules,
            container.ScopeContext,
            registrySharing,
            container.SingletonScope.Clone(withDisposables),
            container.CurrentScope?.Clone(withDisposables));
    }

    /// <summary>The "child" container detached from the parent:
    /// Child creation has O(1) cost - it is cheap thanks to the fast immutable collections cloning.
    /// Child has all parent registrations copied, then the registrations added or removed in the child are not affecting the parent.
    /// By default child will use the parent <see cref="IfAlreadyRegistered"/> policy - you may specify `IfAlreadyRegistered.Replace` to "shadow" the parent registrations
    /// Child has an access to the scoped services and singletons already created by parent.
    /// Child can be disposed without affecting the parent, disposing the child will dispose only the scoped services and singletons created in the child and not in the parent (can be opt-out)</summary>
    public static T CreateChild<T>(this T container,
        IfAlreadyRegistered? ifAlreadyRegistered = null, Rules newRules = null, bool withDisposables = false) where T : IContainer
    {
        // todo: api should we add the DropSingletons or DropScope as an options? see #259
        var rules = newRules != null && newRules != container.Rules ? newRules : container.Rules;
        return (T)container.With(
            container.Parent,
            ifAlreadyRegistered == null ? rules : rules.WithDefaultIfAlreadyRegistered(ifAlreadyRegistered.Value),
            container.ScopeContext,
            RegistrySharing.CloneAndDropCache,
            container.SingletonScope.Clone(withDisposables),
            container.CurrentScope?.Clone(withDisposables));
    }

    /// <summary>Shares all of container state except the cache and the new rules.</summary>
    public static T With<T>(this T container,
        Func<Rules, Rules> configure = null, IScopeContext scopeContext = null) where T : IContainer =>
        container.With(configure?.Invoke(container.Rules) ?? container.Rules, scopeContext ?? container.ScopeContext,
            RegistrySharing.CloneAndDropCache, container.SingletonScope);

    /// <summary>Shares all of container state except the cache and the new rules.</summary>
    public static T With<T, S>(this T container, S state,
        Func<Rules, S, Rules> configure = null, IScopeContext scopeContext = null) where T : IContainer =>
        container.With(configure?.Invoke(container.Rules, state) ?? container.Rules, scopeContext ?? container.ScopeContext,
            RegistrySharing.CloneAndDropCache, container.SingletonScope);

    /// <summary>Prepares container for expression generation.</summary>
    public static T WithExpressionGeneration<T>(this T container, bool allowRuntimeState = false) where T : IContainer =>
        container.With(allowRuntimeState, static (rules, allow) => rules.WithExpressionGeneration(allow));

    /// <summary>Returns new container with all expression, delegate, items cache removed/reset.
    /// But it will preserve resolved services in Singleton/Current scope.</summary>
    public static T WithoutCache<T>(this T container) where T : IContainer =>
        container.With(container.Rules, container.ScopeContext,
        RegistrySharing.CloneAndDropCache, container.SingletonScope);

    /// <summary>Creates new container with state shared with original, except for the singletons and cache.</summary>
    public static T WithoutSingletonsAndCache<T>(this T container) where T : IContainer =>
        container.With(container.Rules, container.ScopeContext,
        RegistrySharing.CloneAndDropCache, singletonScope: null);

    /// <summary>Shares the setup with original container but copies the registrations, so the new registrations
    /// won't be visible in original. Registrations include decorators and wrappers as well.</summary>
    public static T WithRegistrationsCopy<T>(this T container, bool preserveCache = false) where T : IContainer =>
        container.With(container.Rules, container.ScopeContext,
            preserveCache ? RegistrySharing.CloneButKeepCache : RegistrySharing.CloneAndDropCache,
            container.SingletonScope);

    /// <summary>Shares the setup with original container but copies the registrations, so the new registrations
    /// won't be visible in original. Registrations include decorators and wrappers as well.
    /// You may control <see cref="IsRegistryChangePermitted" /> behavior and opt-in for the keeping or cloning the cache.</summary>
    public static T WithRegistrationsCopy<T>(this T container, IsRegistryChangePermitted isRegistryChangePermitted,
        bool preserveCache = false) where T : IContainer =>
        (T)container.With(container.Parent, container.Rules, container.ScopeContext,
            preserveCache ? RegistrySharing.CloneButKeepCache : RegistrySharing.CloneAndDropCache,
            container.SingletonScope, container.OwnCurrentScope, isRegistryChangePermitted);

    /// <summary>For given instance resolves and sets properties and fields.
    /// It respects <see cref="Rules.PropertiesAndFields"/> rules set per container,
    /// or if rules are not set it uses <see cref="PropertiesAndFields.Auto"/>.</summary>
    public static TService InjectPropertiesAndFields<TService>(this IResolverContext r, TService instance) =>
        r.InjectPropertiesAndFields<TService>(instance, null);

    /// <summary>For given instance resolves and sets properties and fields. You may specify what 
    /// properties and fields.</summary>
    public static TService InjectPropertiesAndFields<TService>(this IResolverContext r, TService instance,
        params string[] propertyAndFieldNames)
    {
        r.InjectPropertiesAndFields(instance, propertyAndFieldNames);
        return instance;
    }

    // todo: @unclear does it OK to share the singletons though despite the promise of not affecting the original container?
    /// <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/> if the TYPE is not registered yet. 
    /// The note is that container will share the singletons though.</summary>
    public static object New(this IContainer container, Type concreteType, Setup setup, Made made = null,
        RegistrySharing registrySharing = RegistrySharing.CloneButKeepCache)
    {
        var containerClone = container.With(
            container.Parent, container.Rules, container.ScopeContext,
            registrySharing,
            container.SingletonScope, container.OwnCurrentScope, // reusing the singletons and scopes
            null);

        var implType = containerClone.GetWrappedType(concreteType, null);

        var condition = setup == null && made == null ? null
            : made == null ? (Func<Factory, bool>)(f => f.Setup == setup)
            : setup == null ? (Func<Factory, bool>)(f => f.Made == made)
            : (f => f.Made == made && f.Setup == setup);

        if (!containerClone.IsRegistered(implType, condition: condition))
            containerClone.Register(implType, made: made, setup: setup);

        // No need to Dispose facade because it shares singleton/open scopes with source container, and disposing source container does the job.
        return containerClone.Resolve(concreteType, IfUnresolved.Throw);
    }

    /// <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
    /// <param name="container">Container to use for type creation and injecting its dependencies.</param>
    /// <param name="concreteType">Type to instantiate. Wrappers (Func, Lazy, etc.) is also supported.</param>
    /// <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, 
    /// properties and fields.</param>
    /// <param name="registrySharing">The default is <see cref="RegistrySharing.CloneButKeepCache"/></param>
    /// <returns>Object instantiated by constructor or object returned by factory method.</returns>
    public static object New(this IContainer container, Type concreteType, Made made = null,
        RegistrySharing registrySharing = RegistrySharing.CloneButKeepCache) =>
        container.New(concreteType, setup: null, made, registrySharing);

    /// <summary>Creates service using container for injecting parameters without registering anything in <paramref name="container"/>.</summary>
    /// <typeparam name="T">Type to instantiate.</typeparam>
    /// <param name="container">Container to use for type creation and injecting its dependencies.</param>
    /// <param name="made">(optional) Injection rules to select constructor/factory method, inject parameters, properties and fields.</param>
    /// <param name="registrySharing">The default is <see cref="RegistrySharing.CloneButKeepCache"/></param>
    /// <returns>Object instantiated by constructor or object returned by factory method.</returns>
    public static T New<T>(this IContainer container, Made made = null,
        RegistrySharing registrySharing = RegistrySharing.CloneButKeepCache) =>
        (T)container.New(typeof(T), made, registrySharing);

    /// <summary>Creates service given strongly-typed creation expression.
    /// Can be used to invoke arbitrary method returning some value with injecting its parameters from container.</summary>
    /// <typeparam name="T">Method or constructor result type.</typeparam>
    /// <param name="container">Container to use for injecting dependencies.</param>
    /// <param name="made">Creation expression.</param>
    /// <param name="registrySharing">The default is <see cref="RegistrySharing.CloneButKeepCache"/></param>
    /// <returns>Created result.</returns>
    public static T New<T>(this IContainer container, Made.TypedMade<T> made,
        RegistrySharing registrySharing = RegistrySharing.CloneButKeepCache) =>
        (T)container.New(typeof(T), made, registrySharing);

    /// <summary>Provides automatic fallback resolution mechanism for not normally registered
    /// services. Underneath it uses the `WithDynamicRegistrations`.</summary>
    public static IContainer WithAutoFallbackDynamicRegistrations(this IContainer container,
        Func<Type, object, IEnumerable<Type>> getImplTypes, Func<Type, Factory> factory = null) =>
        factory == null
            ? container.ThrowIfNull().With(getImplTypes, (r, git) => r.WithDynamicRegistrationsAsFallback(Rules.AutoFallbackDynamicRegistrations(git)))
            : container.ThrowIfNull().With(getImplTypes, (r, git) => r.WithDynamicRegistrationsAsFallback(Rules.AutoFallbackDynamicRegistrations(git, factory)));

    /// <summary>Provides automatic fallback resolution mechanism for not normally registered
    /// services. Underneath it uses the `WithDynamicRegistrations`.</summary>
    public static IContainer WithAutoFallbackDynamicRegistrations(this IContainer container,
        DynamicRegistrationFlags flags,
        Func<Type, object, IEnumerable<Type>> getImplTypes, Func<Type, Factory> factory = null) =>
        container.ThrowIfNull()
            .With(rules => rules.WithDynamicRegistrationsAsFallback(flags,
                Rules.AutoFallbackDynamicRegistrations(getImplTypes, factory)));

    /// <summary>Provides automatic fallback resolution mechanism for not normally registered
    /// services. Underneath it uses the `WithDynamicRegistrations`.</summary>
    public static IContainer WithAutoFallbackDynamicRegistrations(this IContainer container, params Type[] implTypes) =>
        container.WithAutoFallbackDynamicRegistrations((_, __) => implTypes);

    /// <summary>Provides automatic fallback resolution mechanism for not normally registered
    /// services. Underneath it uses the `WithDynamicRegistrations`.</summary>
    public static IContainer WithAutoFallbackDynamicRegistrations(this IContainer container,
        IReuse reuse, params Type[] implTypes) =>
        container.WithAutoFallbackDynamicRegistrations((_, __) => implTypes, implType => ReflectionFactory.Of(implType, reuse));

    /// <summary>Provides automatic fallback resolution mechanism for not normally registered
    /// services. Underneath it uses the `WithDynamicRegistrations`.</summary>
    public static IContainer WithAutoFallbackDynamicRegistrations(this IContainer container,
        IReuse reuse, Setup setup, params Type[] implTypes) =>
        container.WithAutoFallbackDynamicRegistrations(
            (_, __) => implTypes, implType => ReflectionFactory.Of(implType, reuse, setup: setup));

    /// <summary>Provides automatic fallback resolution mechanism for not normally registered
    /// services. Underneath it uses the `WithDynamicRegistrations`.</summary>
    public static IContainer WithAutoFallbackDynamicRegistrations(this IContainer container,
        Func<Type, object, IEnumerable<Assembly>> getImplTypeAssemblies, Func<Type, Factory> factory = null) =>
        container.WithAutoFallbackDynamicRegistrations(DryIoc.Rules.DefaultDynamicRegistrationFlags, getImplTypeAssemblies, factory);

    /// <summary>Provides automatic fallback resolution mechanism for not normally registered
    /// services. Underneath it uses the `WithDynamicRegistrations`.</summary>
    public static IContainer WithAutoFallbackDynamicRegistrations(this IContainer container,
        DynamicRegistrationFlags flags,
        Func<Type, object, IEnumerable<Assembly>> getImplTypeAssemblies,
        Func<Type, Factory> factory = null) =>
        container.ThrowIfNull().With(rules => rules.WithDynamicRegistrationsAsFallback(
            flags,
            Rules.AutoFallbackDynamicRegistrations(
                (serviceType, serviceKey) =>
                {
                    var assemblies = getImplTypeAssemblies(serviceType, serviceKey);
                    if (assemblies == null)
                        return Empty<Type>();
                    return assemblies
                        .SelectMany(a => ReflectionTools.GetLoadedTypes(a))
                        .Where(t => Registrator.IsImplementationType(t))
                        .ToArray();
                },
                factory)));

    /// <summary>Provides automatic fallback resolution mechanism for not normally registered
    /// services. Underneath it uses the `WithDynamicRegistrations`.</summary>
    public static IContainer WithAutoFallbackDynamicRegistrations(this IContainer container,
        params Assembly[] implTypeAssemblies) =>
        container.WithAutoFallbackDynamicRegistrations((_, __) => implTypeAssemblies);

    /// <summary>Provides automatic fallback resolution mechanism for not normally registered
    /// services. Underneath it uses the `WithDynamicRegistrations`.</summary>
    public static IContainer WithAutoFallbackDynamicRegistrations(this IContainer container,
        IEnumerable<Assembly> implTypeAssemblies) =>
        container.WithAutoFallbackDynamicRegistrations((_, __) => implTypeAssemblies);

    /// <summary>Creates new container with provided parameters and properties
    /// to pass the custom dependency values for injection. The old parameters and properties are overridden,
    /// but not replaced.</summary>
    /// <param name="container">Container to work with.</param>
    /// <param name="parameters">(optional) Parameters specification, can be used to proved custom values.</param>
    /// <param name="propertiesAndFields">(optional) Properties and fields specification, can be used to proved custom values.</param>
    /// <returns>New container with adjusted rules.</returns>
    /// <example><code lang="cs"><![CDATA[
    ///     var c = container.WithDependencies(Parameters.Of.Type<string>(_ => "Nya!"));
    ///     var a = c.Resolve<A>(); // where A accepts string parameter in constructor
    ///     Assert.AreEqual("Nya!", a.Message)
    /// ]]></code></example>
    public static IContainer WithDependencies(this IContainer container,
        ParameterSelector parameters = null, PropertiesAndFieldsSelector propertiesAndFields = null) =>
        container.With(rules => rules.With(Made.Create(
            rules.FactoryMethodOrSelector,
            rules.Parameters.OverrideWith(parameters),
            rules.PropertiesAndFields.OverrideWith(propertiesAndFields),
            isConditionalImplementation: rules._made.IsConditionalImplementation),
            overrideRegistrationMade: true));

    /// <summary>Generates expressions for provided root services</summary>
    public static GeneratedExpressions GenerateResolutionExpressions(
        this IContainer container, Func<ServiceRegistrationInfo, bool> condition) =>
        container.GenerateResolutionExpressions(regs => regs.Where(condition.ThrowIfNull()).Select(static r => r.ToServiceInfo()));

    /// <summary>Generates expressions for provided root services</summary>
    public static GeneratedExpressions GenerateResolutionExpressions(
        this IContainer container, params ServiceInfo[] roots) =>
        container.GenerateResolutionExpressions(roots.ToFunc<IEnumerable<ServiceRegistrationInfo>, IEnumerable<ServiceInfo>>);

    /// <summary>Excluding open-generic registrations, cause you need to provide type arguments to actually create these types.</summary>
    public static bool DefaultValidateCondition(ServiceRegistrationInfo reg) => !reg.ServiceType.IsOpenGeneric();

    // todo: @vNext instead of `condition` we may use a transformer to close the open-generic types. But may be having `roots` parameters covers it as well.
    /// <summary>Helps to find potential problems in service registration setup. Method tries to resolve the specified registrations, collects exceptions, 
    /// and returns them to user. Does not create any actual service objects. You must specify <paramref name="condition"/> to define your resolution roots,
    /// otherwise container will try to resolve the registrations marked with `Setup.With(asResolutionRoot: true)` 
    /// or the all registrations (which usually is not realistic case to validate).</summary>
    public static KeyValuePair<ServiceInfo, ContainerException>[] Validate(this IContainer container, Func<ServiceRegistrationInfo, bool> condition = null)
    {
        var roots = ArrayTools.Empty<ServiceRegistrationInfo>();
        if (condition == null)
        {
            var allNonGenericRegistrations = container.GetServiceRegistrations().Match(DefaultValidateCondition).ToArrayOrSelf();
            if (allNonGenericRegistrations.Length == 0)
                Throw.It(Error.FoundNoRootsToValidate, container);

            // We try to find the registrations marked by `Setup.With(asResolutionRoot: true)` and if nothing found, fallback to the all found.
            // This allow to make asResolutionRoot marking to be optional for validate, but if used - provide the convenient validation by convention. 
            roots = allNonGenericRegistrations.Match(static r => r.Factory.Setup.AsResolutionRoot);
            if (roots.Length == 0)
                roots = allNonGenericRegistrations;
        }
        else
        {
            // condition overrides whatever resolution roots are marked in registrations 
            roots = container.GetServiceRegistrations().Match(condition, static (cond, r) => cond(r) && DefaultValidateCondition(r)).ToArrayOrSelf();
            if (roots.Length == 0)
                Throw.It(Error.FoundNoRootsToValidate, container);
        }
        return container.Validate(roots.Map(static r => r.ToServiceInfo()));
    }

    /// <summary>Helps to find potential problems in service registration setup by trying to resolve the <paramref name="serviceTypes"/> and 
    /// returning the found errors. This method does not throw the errors but collects and returns them.</summary>
    public static KeyValuePair<ServiceInfo, ContainerException>[] Validate(this IContainer container, params Type[] serviceTypes)
    {
        if (serviceTypes.IsNullOrEmpty())
            Throw.It(Error.NoServiceTypesToValidate, container);
        return container.Validate(serviceTypes.Map(static t => ServiceInfo.Of(t)));
    }

    /// <summary>Helps to find potential problems in service registration setup by trying to resolve the <paramref name="roots"/> and 
    /// returning the found errors. This method does not throw the errors but collects and returns them.</summary>
    public static KeyValuePair<ServiceInfo, ContainerException>[] Validate(this IContainer container, params ServiceInfo[] roots) =>
        container.Validate(roots);

    /// <summary>Same as the Validate with the same parameters but throws the exception with all collected errors</summary>
    public static void ValidateAndThrow(this IContainer container, Func<ServiceRegistrationInfo, bool> condition = null)
    {
        var errors = container.Validate(condition);
        if (!errors.IsNullOrEmpty())
            Throw.Many(Error.ValidateFoundErrors, errors.Map(static x => x.Value));
    }

    /// <summary>Same as the Validate with the same parameters but throws the exception with all collected errors</summary>
    public static void ValidateAndThrow(this IContainer container, params Type[] serviceTypes)
    {
        var errors = container.Validate(serviceTypes);
        if (!errors.IsNullOrEmpty())
            Throw.Many(Error.ValidateFoundErrors, errors.Map(static x => x.Value));
    }

    /// <summary>Same as the Validate with the same parameters but throws the exception with all collected errors</summary>
    public static void ValidateAndThrow(this IContainer container, params ServiceInfo[] roots)
    {
        var errors = container.Validate(roots);
        if (!errors.IsNullOrEmpty())
            Throw.Many(Error.ValidateFoundErrors, errors.Map(static x => x.Value));
    }

    /// <summary>Re-constructs the whole request chain as request creation expression.</summary>
    public static Expression GetRequestExpression(this IContainer container, Request request,
        RequestFlags requestParentFlags = default(RequestFlags))
    {
        if (request.IsEmpty)
            return (requestParentFlags & RequestFlags.OpensResolutionScope) != 0
                ? Field(typeof(Request).GetField(nameof(Request.EmptyOpensResolutionScope))) // we may not refactor it to readonly field because it is rarely used
                : Request.EmptyRequestExpr;

        var flags = request.Flags | requestParentFlags;
        var r = requestParentFlags == default(RequestFlags) ? request : request.WithFlags(flags); // todo: @perf @mem in-place mutation

        // When not for generation, using run-time request object to Minimize generated object graph.
        if (!container.Rules.UsedForExpressionGeneration)
            return Constant(r.IsolateRequestChain());

        // recursively ask for parent expression until it is empty
        var parentExpr = container.GetRequestExpression(request.DirectParent);

        var serviceType = r.ServiceType;
        var d = r.GetServiceDetails();

        var factoryID = r.FactoryID;
        var factoryType = r.FactoryType;
        var implementationType = r.ImplementationType;
        var decoratedFactoryID = r.DecoratedFactoryID;

        var serviceTypeExpr = Constant(serviceType);
        var factoryIdExpr = ConstantInt(factoryID);
        var implTypeExpr = implementationType.ToConstant();
        var reuseExpr = r.Reuse == null ? ConstantNull<IReuse>() : r.Reuse.ToExpression(container, static (c, it) => c.GetConstantExpression(it));

        if (d.IfUnresolved == IfUnresolved.Throw && d.RequiredServiceType == null && d.ServiceKey == null && d.MetadataKey == null && d.Metadata == null &&
            factoryType == FactoryType.Service && decoratedFactoryID == 0)
            return flags == default(RequestFlags)
                ? Call(parentExpr, Request.PushMethodWith4Args.Value, serviceTypeExpr, factoryIdExpr, implTypeExpr, reuseExpr)
                : Call(parentExpr, Request.PushMethodWith5Args.Value, serviceTypeExpr, factoryIdExpr, implTypeExpr, reuseExpr, ConstantOf(flags));

        var requiredServiceTypeExpr = ConstantOf(d.RequiredServiceType);
        var serviceKeyExpr = container.GetConstantExpression(d.ServiceKey, typeof(object));
        var factoryTypeExpr = ConstantOf(factoryType); // todo: @perf all types to the singleton constants same as IfUnresolved below
        var flagsExpr = ConstantOf(flags);

        if (d.IfUnresolved == IfUnresolved.Throw && d.MetadataKey == null && d.Metadata == null && decoratedFactoryID == 0)
            return Call(parentExpr, Request.PushMethodWith8Args.Value,
                serviceTypeExpr, requiredServiceTypeExpr, serviceKeyExpr, factoryIdExpr, factoryTypeExpr, implTypeExpr, reuseExpr, flagsExpr);

        var ifUnresolvedExpr = d.IfUnresolved.ToConstant();
        var decoratedFactoryIDExpr = ConstantOf(decoratedFactoryID);

        if (d.MetadataKey == null && d.Metadata == null)
            return Call(parentExpr, Request.PushMethodWith10Args.Value,
                serviceTypeExpr, requiredServiceTypeExpr, serviceKeyExpr, ifUnresolvedExpr,
                factoryIdExpr, factoryTypeExpr, implTypeExpr, reuseExpr, flagsExpr, decoratedFactoryIDExpr);

        var metadataKeyExpr = Constant(d.MetadataKey);
        var metadataExpr = container.GetConstantExpression(d.Metadata, typeof(object));

        return Call(parentExpr, Request.PushMethodWith12Args.Value,
            serviceTypeExpr, requiredServiceTypeExpr, serviceKeyExpr, metadataKeyExpr, metadataExpr, ifUnresolvedExpr,
            factoryIdExpr, factoryTypeExpr, implTypeExpr, reuseExpr, flagsExpr, decoratedFactoryIDExpr);
    }

    /// <summary>Clears delegate and expression cache for specified <typeparamref name="T"/>.
    /// But does not clear instances of already resolved/created singletons and scoped services!</summary>
    public static bool ClearCache<T>(this IContainer container, FactoryType? factoryType = null, object serviceKey = null) =>
        container.ClearCache(typeof(T), factoryType, serviceKey);

    /// <summary>Clears delegate and expression cache for specified service.
    /// But does not clear instances of already resolved/created singletons and scoped services!</summary>
    public static bool ClearCache(this IContainer container, Type serviceType,
        FactoryType? factoryType = null, object serviceKey = null) =>
        container.ClearCache(serviceType, factoryType, serviceKey);

    /// <summary>Setting the factory directly to scope for resolution</summary> 
    public static void Use(this IContainer container, Type serviceType, Func<IResolverContext, object> factory) =>
        container.Use(serviceType, factory);

    internal static bool TryGetCachedExpression(this Container.Registry r,
        Request request, IReuse reuse, Rules rules, ref ImHashMapEntry<int, object> cacheEntry, out Expression result)
    {
        var id = request.FactoryID;
        cacheEntry = r.FactoryExpressionCache?[id & Container.Registry.CACHE_SLOT_COUNT_MASK]?.GetEntryOrDefault(id);
        if (cacheEntry?.Value is object entry)
        {
            if (entry is Expression expr)
            {
                if (reuse is SingletonReuse || reuse is CurrentScopeReuse sr && sr.Name == null)
                {
                    result = expr;
                    return true;
                }
            }
            else if (entry is Container.ExprCacheOfTransientWithDepCount t)
            {
                if (reuse == DryIoc.Reuse.Transient)
                {
                    if (t.Count > 0 && !rules.UsedForValidation && !rules.UsedForExpressionGeneration)
                        request.IncreaseTrackedDependencyCountForParents(t.Count);
                    {
                        result = t.Expr;
                        return true;
                    }
                }
            }
            else if (entry is Container.ExprCacheOfScopedWithName s && reuse.Name?.Equals(s.Name) == true)
            {
                result = s.Expr;
                return true;
            }
        }
        result = null;
        return false;
    }

    internal static bool TrySetScopedOrSingletonItemException(this IResolverContext r, Exception ex)
    {
        ScopedItemException sex = null;
        for (var s = r.CurrentScope; s != null; s = s.Parent)
            if (TryFindNoItemAndStoreWrappedException(s, ex, ref sex))
                return true;
        return TryFindNoItemAndStoreWrappedException(r.SingletonScope, ex, ref sex);

        static bool TryFindNoItemAndStoreWrappedException(IScope scope, Exception ex, ref ScopedItemException sex)
        {
            var clonedMaps = ((Scope)scope).CloneMaps();
            foreach (var m in clonedMaps)
                if (!m.IsEmpty)
                    foreach (var entry in m.Enumerate())
                    {
                        if (entry.Value == Scope.NoItem)
                        {
                            sex ??= new ScopedItemException(ex);

                            // Here is the parallel thread may set the Value or exception.
                            // For the Value - it is fine, because the thread knows exact set reference, and we are here just wandering around.
                            // Therefore the entry is likely not our exception culprit. Let's proceed the search.
                            // The problem is when we are faster than the parallel thread and set the exception first. 
                            // The solution to that is slow down before setting the exception and give other thread time to complete 
                            // (via the timeout or spin wait).
                            // It is wrong to put the responsibility on the other thread to check for exception in the entry,
                            // because the other thread has no way to notify us here of the wrong, because we are done already.

                            // So, slowing down and given a chance for the other thread to set the NoItem entry to the value.
                            Thread.Sleep(1); // per design, because Thread.Sleep(0) or Thread.Yield() are not reliable enough.

                            var actualValueWas = Interlocked.CompareExchange(ref entry.Value, sex, Scope.NoItem);
                            if (actualValueWas == Scope.NoItem)
                                return true; // set, done
                        }
                    }
            return false;
        }
    }

    ///<summary>
    /// A similar thing to the `Interpreter.TryInterpretAndUnwrapContainerException` but for the compiled delegate,
    /// It rethrows the Container exception right away, but stores the other User exceptions into the Scoped item entry, 
    /// to be re-thrown on the next resolution and to prevent the futile wait for the empty item entry.
    ///</summary> 
    internal static object TryInvokeFactoryDelegateAndStoreNonContainerExceptionInScope(this IResolverContext r, Func<IResolverContext, object> factoryDelegate)
    {
        try
        {
            return factoryDelegate(r);
        }
        catch (Exception ex) when (ex is not ContainerException)
        {
            var exSet = TrySetScopedOrSingletonItemException(r, ex);
            throw;
        }
    }
}

/// <summary>Interface used to convert reuse instance to expression.</summary>
public interface IConvertibleToExpression
{
    /// <summary>Returns expression representation without closure.
    /// Use <paramref name="fallbackConverter"/> to converting the sub-items, constants to container.</summary>
    Expression ToExpression<S>(S state, Func<S, object, Expression> fallbackConverter);
}

/// <summary>Used to represent multiple default service keys.
/// Exposes <see cref="RegistrationOrder"/> to determine order of service added.</summary>
public sealed class DefaultKey : IConvertibleToExpression
{
    /// <summary>Default value.</summary>
    public static readonly DefaultKey Value = new DefaultKey(0);

    /// <summary>Allows to determine service registration order.</summary>
    public readonly int RegistrationOrder;

    /// <summary>Returns the default key with specified registration order.</summary>
    public static DefaultKey Of(int registrationOrder) =>
        registrationOrder == 0 ? Value : new DefaultKey(registrationOrder);

    private static readonly MethodInfo _ofMethod = typeof(DefaultKey).GetMethod(nameof(Of));

    /// <summary>Converts to expression</summary>
    public Expression ToExpression<S>(S state, Func<S, object, Expression> fallbackConverter) =>
        Call(_ofMethod, ConstantInt(RegistrationOrder));

    /// <summary>Returns next default key with increased <see cref="RegistrationOrder"/>.</summary>
    public DefaultKey Next() => Of(RegistrationOrder + 1);

    /// <summary>Compares keys based on registration order. The null (represents default) key is considered equal.</summary>
    public override bool Equals(object key) =>
        key == null || (key as DefaultKey)?.RegistrationOrder == RegistrationOrder;

    /// <summary>Returns registration order as hash.</summary>
    public override int GetHashCode() => RegistrationOrder;

    /// <summary>Prints registration order to string.</summary>
    public override string ToString() => GetType().Name + "(" + RegistrationOrder + ")";

    private DefaultKey(int registrationOrder) => RegistrationOrder = registrationOrder;
}

/// <summary>Represents default key for dynamic registrations</summary>
public sealed class DefaultDynamicKey : IConvertibleToExpression
{
    /// <summary>Default value.</summary>
    public static readonly DefaultDynamicKey Value = new DefaultDynamicKey(0);

    /// <summary>Associated ID.</summary>
    public readonly int RegistrationOrder;

    /// <summary>Returns dynamic key with specified ID.</summary>
    public static DefaultDynamicKey Of(int registrationOrder) =>
        registrationOrder == 0 ? Value : new DefaultDynamicKey(registrationOrder);

    private static readonly MethodInfo _ofMethod = typeof(DefaultDynamicKey).GetMethod(nameof(Of));

    /// <summary>Converts to expression</summary>
    public Expression ToExpression<S>(S state, Func<S, object, Expression> fallbackConverter) =>
        Call(_ofMethod, ConstantInt(RegistrationOrder));

    /// <summary>Returns next dynamic key with increased <see cref="RegistrationOrder"/>.</summary> 
    public DefaultDynamicKey Next() => Of(RegistrationOrder + 1);

    /// <summary>Compares key's IDs. The null (default) key is considered equal!</summary>
    public override bool Equals(object key) =>
        key == null || (key as DefaultDynamicKey)?.RegistrationOrder == RegistrationOrder;

    /// <summary>Returns key index as hash.</summary>
    public override int GetHashCode() => RegistrationOrder;

    /// <summary>Prints registration order to string.</summary>
    public override string ToString() => GetType().Name + "(" + RegistrationOrder + ")";

    private DefaultDynamicKey(int registrationOrder) => RegistrationOrder = registrationOrder;
}

/// <summary>Extends IResolver to provide an access to scope hierarchy.</summary>
public interface IResolverContext : IResolver, IDisposable
#if SUPPORTS_ASYNC_DISPOSABLE
    , IAsyncDisposable
#endif
{
    /// <summary>The rules object defines policies per container for registration and resolution.</summary>
    Rules Rules { get; }

    /// <summary>True if container is disposed.</summary>
    bool IsDisposed { get; }

    /// <summary>Usually the disposal stack trace (if supported) to add the error message 
    /// to identify the place and possible reason of disposal. The `null` otherwise</summary>
    object DisposeInfo { get; }

    /// <summary>Parent context of the scoped context.</summary>
    IResolverContext Parent { get; }

    /// <summary>The root context of the scoped context.</summary>
    IResolverContext Root { get; }

    /// <summary>Singleton scope, always associated with root scope.</summary>
    IScope SingletonScope { get; }

    /// <summary>Optional ambient scope context.</summary>
    IScopeContext ScopeContext { get; }

    /// <summary>Current opened scope. May return the current scope from <see cref="ScopeContext"/> if context is not null.</summary>
    IScope CurrentScope { get; }

    /// <summary>This property exist mostly for the performance reasons to have single virtual call instead of 
    /// `CurrentScope ?? SingletonScope`</summary>
    IScope CurrentOrSingletonScope { get; }

    /// <summary>The current scope belonged to the resolver context and not to the scope context. Maybe null if ScopeContext is not null.</summary>
    IScope OwnCurrentScope { get; }

    /// <summary>Creates the new/child resolver context with specified scope</summary>
    IResolverContext WithCurrentScope(IScope ownScope);

    /// <summary>Creates the new/child resolver context with specified scope context with the new scope</summary>
    IResolverContext WithScopeContext(IScopeContext scopeContext);

    /// <summary>Combines `WithCurrentScope` and `OwnCurrentScope` for the hot-path case to avoid two virtual calls</summary>
    IContainer WithNewOpenScope(out IScope newScope);

    /// <summary>Puts instance created via the passed factory on demand into the current or singleton scope</summary>
    void Use(Type serviceType, object instance);

    /// <summary>For given instance resolves and sets properties and fields.</summary>
    void InjectPropertiesAndFields(object instance, string[] propertyAndFieldNames);
}

/// <summary>Provides a usable abstractions for <see cref="IResolverContext"/></summary>
public static class ResolverContext
{
    /// <summary>Just a sugar that allow to get root or self container.</summary>
    public static IResolverContext RootOrSelf(this IResolverContext r) => r.Root ?? r;

    internal static readonly MethodInfo OpenScopeMethod = typeof(ResolverContext)
        .GetMethod(nameof(OpenScope), new[] { typeof(IResolverContext), typeof(object), typeof(bool) });

    /// <summary>Finds the correct resolver context expression for e.g. resolution calls dependency,
    /// or for the injecting the resolver context as parameter, opening the resolution scope, etc.</summary>
    public static Expression GetRootOrSelfExpr(Request request) =>
        request.Reuse is CurrentScopeReuse == false
        && request.DirectParent.IsSingletonOrDependencyOfSingleton
        && request.Rules.ThrowIfDependencyHasShorterReuseLifespan // see the #378
        && !request.OpensResolutionScopeUpToResolutionCall()
            ? RootOrSelfExpr
            : FactoryDelegateCompiler.ResolverContextParamExpr;

    private static bool OpensResolutionScopeUpToResolutionCall(this Request r)
    {
        var p = r.DirectParent;
        while (p != null)
        {
            if ((p.Flags & RequestFlags.OpensResolutionScope) != 0)
                return true;
            p = p.DirectParent;
        }
        return false;
    }

    /// <summary>Root or the current resolver context (if it is the root).</summary>
    public static readonly Expression RootOrSelfExpr =
        new ResolverContextArgMethodCallExpression(typeof(ResolverContext).GetMethod(nameof(RootOrSelf)));

    /// <summary>Resolver parameter expression.</summary>
    public static readonly PropertyExpression SingletonScopeExpr =
        new ResolverContextPropertyParamExpression(typeof(IResolverContext).GetProperty(nameof(IResolverContext.SingletonScope)));

    /// <summary>Access to the current scope.</summary>
    public static readonly PropertyExpression CurrentScopeExpr =
        new ResolverContextPropertyParamExpression(typeof(IResolverContext).GetProperty(nameof(IResolverContext.CurrentScope)));

    /// <summary>Access to the current scope or singletons.</summary>
    public static readonly PropertyExpression CurrentOrSingletonScopeExpr =
        new ResolverContextPropertyParamExpression(typeof(IResolverContext).GetProperty(nameof(IResolverContext.CurrentOrSingletonScope)));
    internal sealed class ResolverContextPropertyParamExpression : PropertyExpression
    {
        public override bool IsIntrinsic => true;

        public override Expression Expression => FactoryDelegateCompiler.ResolverContextParamExpr;
        internal ResolverContextPropertyParamExpression(PropertyInfo property) : base(property) { }

        public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas) =>
            ExpressionCompiler.TryCollectInfo(ref closure, FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, nestedLambda, ref rootNestedLambdas, flags);

        public override bool TryEmit(CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs,
            ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
            EmittingVisitor.TryEmitNonByRefNonValueTypeParameter(FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, il, ref closure) &&
            EmittingVisitor.EmitVirtualMethodCall(il, PropertyInfo.GetMethod);
    }

    /// <summary>Indicates that context is scoped - that's is only possible if container is not the Root one and has a Parent context</summary>
    public static bool IsScoped(this IResolverContext r) => r.Parent != null;

    /// <summary>Get current scope or throw the exception otherwise.</summary>
    public static IScope GetCurrentScopeOrThrow(this IResolverContext r) =>
        r.CurrentScope ?? Throw.For<IScope>(Error.NoCurrentScope, r);

    /// <summary>Get current scope expression or throw the exception otherwise.</summary>
    public static readonly MethodCallExpression GetCurrentScopeOrThrowExpr =
        new ResolverContextArgMethodCallExpression(typeof(ResolverContext).GetMethod(nameof(GetCurrentScopeOrThrow)));

    internal sealed class ResolverContextArgMethodCallExpression : MethodCallExpression
    {
        public override bool IsIntrinsic => true;

        public override MethodInfo Method { get; }
        public override int ArgumentCount => 1;
        public override IReadOnlyList<Expression> Arguments => FactoryDelegateCompiler.ResolverContextParamExprs;
        public override Expression GetArgument(int i) => FactoryDelegateCompiler.ResolverContextParamExpr;
        public ResolverContextArgMethodCallExpression(MethodInfo method) => Method = method;
        public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas) =>
            ExpressionCompiler.TryCollectInfo(ref closure, FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, nestedLambda, ref rootNestedLambdas, flags);

        public override bool TryEmit(CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs,
            ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
            EmittingVisitor.TryEmitNonByRefNonValueTypeParameter(FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, il, ref closure) &&
            EmittingVisitor.EmitMethodCall(il, Method);
    }

    /// <summary>Provides access to the current scope - may return `null` if ambient scope context has it scope changed in-between</summary>
    public static IScope GetCurrentScope(this IResolverContext r, bool throwIfNotFound) =>
        r.CurrentScope ?? (throwIfNotFound ? Throw.For<IScope>(Error.NoCurrentScope, r) : null);

    /// <summary>Gets current scope matching the <paramref name="name"/></summary>
    public static IScope GetNamedScope(this IResolverContext r, object name, bool throwIfNotFound)
    {
        var currentScope = r.CurrentScope;
        if (currentScope == null)
            return throwIfNotFound ? Throw.For<IScope>(Error.NoCurrentScope, r) : null;

        var s = currentScope;
        if (name != null)
        {
            if (name is IScopeName scopeName)
            {
                for (; s != null; s = s.Parent)
                    if (scopeName.Match(s.Name))
                        break;
            }
            else
            {
                for (; s != null; s = s.Parent)
                    if (ReferenceEquals(name, s.Name) || name.Equals(s.Name))
                        break;
            }
        }

        if (s == null)
            return throwIfNotFound ? Throw.For<Scope>(Error.NoMatchedScopeFound, name, currentScope) : null;

        if (s.IsDisposed)
        {
            if (throwIfNotFound)
                Throw.ScopeIsDisposed(s, r);
            return null;
        }

        return s;
    }

    /// <summary>Opens scope with optional name and optional tracking of new scope in a parent scope.</summary>
    /// <param name="r">Parent context to use.</param>
    /// <param name="name">(optional)</param>
    /// <param name="trackInParent">(optional) Instructs to additionally store the opened scope in parent, 
    /// so it will be disposed when parent is disposed. If no parent scope is available the scope will be tracked by Singleton scope.
    /// Used to dispose a resolution scope.</param>
    /// <returns>Scoped resolver context.</returns>
    /// <example><code lang="cs"><![CDATA[
    /// using (var scope = container.OpenScope())
    /// {
    ///     var handler = scope.Resolve<IHandler>();
    ///     handler.Handle(data);
    /// }
    /// ]]></code></example>
    public static IResolverContext OpenScope(this IResolverContext r, object name, bool trackInParent = false)
    {
        var scopeContext = r.ScopeContext;
        if (scopeContext != null)
        {
            var newContextScope = name == null ? scopeContext.SetNewOpen() : scopeContext.SetNewOpenWithName(name);
            if (trackInParent)
                (newContextScope.Parent ?? r.SingletonScope).TrackDisposable(newContextScope);
            return r.WithScopeContext(scopeContext);
        }

        var parentScope = r.OwnCurrentScope;
        var newOwnScope = Scope.Of(parentScope, name);
        if (trackInParent)
            (parentScope ?? r.SingletonScope).TrackDisposable(newOwnScope);
        return r.WithCurrentScope(newOwnScope);
    }

    /// <summary>Set scope context with the new scope with current scope as parent</summary>
    public static IScope SetNewOpen(this IScopeContext ctx) => ctx.SetCurrent(static parent => Scope.Of(parent));

    /// <summary>Set scope context with the new scope with current scope as parent and name</summary>
    public static IScope SetNewOpenWithName(this IScopeContext ctx, object name) => ctx.SetCurrent(parent => Scope.Of(parent, name));

    /// <summary>Opens scope with optional name and optional tracking of new scope in a parent scope.</summary>
    /// <example><code lang="cs"><![CDATA[
    /// using (var scope = container.OpenScope())
    /// {
    ///     var handler = scope.Resolve<IHandler>();
    ///     handler.Handle(data);
    /// }
    /// ]]></code></example>
    [MethodImpl((MethodImplOptions)256)]
    public static IResolverContext OpenScope(this IResolverContext r)
    {
        return r.WithNewOpenScope(out _);
    }

    /// <summary>Check if the service instance or factory is added to the current or singleton scope</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static bool IsUsed(this IResolverContext r, Type serviceType)
    {
        var hash = RuntimeHelpers.GetHashCode(serviceType);
        var scope = r.CurrentScope;
        return scope != null && scope.TryGetUsed(hash, serviceType, out _)
            || r.SingletonScope.TryGetUsed(hash, serviceType, out _);
    }

    /// <summary>Check if the service instance or factory is added to the current or singleton scope</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static bool IsUsed<TService>(this IResolverContext r) => r.IsUsed(typeof(TService));

    [MethodImpl((MethodImplOptions)256)]
    internal static bool TryGetUsedInstance(this IResolverContext r, int serviceTypeHash, Type serviceType, out object instance) =>
        r.TryGetUsedInstance((Scope)r.CurrentScope, (Scope)r.SingletonScope, serviceTypeHash, serviceType, out instance); // todo @unsafe @perf remove cast to Scope

    // todo: @unsafe @improve assuming that the IScope is Scope
    internal static bool TryGetUsedInstance(this IResolverContext r, Scope scope, Scope singletons, int serviceTypeHash, Type serviceType, out object instance)
    {
        ImHashMapEntry<Type, object> e = null;
        while (scope != null)
        {
            if (scope._disposed != 1 && !scope._used.IsEmpty &&
                null != (e = scope._used.GetEntryOrDefaultByReferenceEquals(serviceTypeHash, serviceType)))
                break;
            scope = (Scope)scope.Parent;
        }
        if (e == null)
            e = singletons._used.GetEntryOrDefaultByReferenceEquals(serviceTypeHash, serviceType);
        instance = e == null ? default : e.Value is Func<IResolverContext, object> f ? f(r) : e.Value;
        return e != null;
    }

    /// <summary>A bit if sugar to track disposable in the current scope or in the singleton scope as a fallback</summary>
    public static T TrackDisposable<T>(this IResolverContext r, T instance, int disposalOrder = 0) where T : IDisposable =>
        (T)r.CurrentOrSingletonScope.TrackDisposable(instance, disposalOrder);
}

/// <summary>Adds to Container support for:
/// <list type="bullet">
/// <item>Open-generic services</item>
/// <item>Service generics wrappers and arrays using <see cref="Rules.UnknownServiceResolvers"/> extension point.
/// Supported wrappers include: Func of <see cref="FuncTypes"/>, Lazy, Many, IEnumerable, arrays, Meta, KeyValuePair, DebugExpression.
/// All wrapper factories are added into collection of <see cref="Wrappers"/>.
/// unregistered resolution rule.</item>
/// </list></summary>
public static class WrappersSupport
{
    /// <summary>Supported Func types.</summary>
    public static readonly Type[] FuncTypes =
    {
        typeof(Func<>), typeof(Func<,>), typeof(Func<,,>), typeof(Func<,,,>), typeof(Func<,,,,>),
        typeof(Func<,,,,,>), typeof(Func<,,,,,,>), typeof(Func<,,,,,,,>)
    };

    /// <summary>Supported Action types. Yeah, action I can resolve or inject void returning method as action.</summary>
    public static readonly Type[] ActionTypes =
    {
        typeof(Action), typeof(Action<>), typeof(Action<,>), typeof(Action<,,>), typeof(Action<,,,>),
        typeof(Action<,,,,>), typeof(Action<,,,,,>), typeof(Action<,,,,,,>)
    };

    /// <summary>Supported open-generic collection types - all the interfaces implemented by array.</summary>
    public static readonly Type[] SupportedCollectionTypes =
        typeof(object[]).GetInterfaces().Match(t => t.IsGenericType, t => t.GetGenericTypeDefinition());

    /// <summary>Returns true if type is supported <see cref="FuncTypes"/>, and false otherwise.</summary>
    public static bool IsFunc(this Type type)
    {
        if (type.IsGenericType)
        {
            var typeDef = type.GetGenericTypeDefinition();
            var funcTypes = FuncTypes;
            for (var i = 0; i < funcTypes.Length; ++i)
                if (ReferenceEquals(funcTypes[i], typeDef))
                    return true;
        }
        return false;
    }

    internal static int CollectionWrapperID { get; private set; }

    /// <summary>Registered wrappers by their concrete or generic definition service type.</summary>
    public static readonly ImHashMap<Type, object> Wrappers = BuildSupportedWrappers();

    private static ImHashMap<Type, object> BuildSupportedWrappers()
    {
        var wrappers = ImHashMap.BuildFromDifferent(
            typeof(LazyEnumerable<>).Entry(WrapperExpressionFactory.Of(static (r, _) => GetLazyEnumerableExpressionOrDefault(r, itemType: null), setup: Setup.Wrapper)),
            typeof(Lazy<>).Entry(WrapperExpressionFactory.Of(static (r, f) => GetLazyExpressionOrDefault(r, f))),
            typeof(KeyValuePair<,>).Entry(WrapperExpressionFactory.Of(static (r, f) => GetKeyValuePairExpressionOrDefault(r, f), Setup.WrapperWith(1))),
            typeof(Meta<,>).Entry(WrapperExpressionFactory.Of(static (r, f) => GetMetaExpressionOrDefault(r, f), Setup.WrapperWith(0))),
            typeof(Tuple<,>).Entry(WrapperExpressionFactory.Of(static (r, f) => GetMetaExpressionOrDefault(r, f), Setup.WrapperWith(0))),
            typeof(System.Linq.Expressions.LambdaExpression).Entry(WrapperExpressionFactory.Of(static (r, _) => GetLambdaExpressionExpressionOrDefault(r), setup: Setup.Wrapper)),
            typeof(LambdaExpression).Entry(WrapperExpressionFactory.Of(static (r, _) => GetFastExpressionCompilerLambdaExpressionExpressionOrDefault(r), setup: Setup.Wrapper)),
            typeof(Func<>).Entry(WrapperExpressionFactory.Of(static (r, f) => GetFuncOrActionExpressionOrDefault(r, f), Setup.Wrapper))
        );

        var arrayExpr = WrapperExpressionFactory.Of(static (r, _) => GetArrayExpression(r), setup: Setup.Wrapper);
        CollectionWrapperID = arrayExpr.FactoryID;

        var arrayInterfaces = SupportedCollectionTypes;
        for (var i = 0; i < arrayInterfaces.Length; i++)
            wrappers = wrappers.AddSureNotPresent(arrayInterfaces[i], arrayExpr);

        // Skip the `i == 0` because `Func<>` type was added above
        for (var i = 1; i < FuncTypes.Length; i++)
            wrappers = wrappers.AddSureNotPresent(FuncTypes[i],
                WrapperExpressionFactory.Of(static (r, f) => GetFuncOrActionExpressionOrDefault(r, f), Setup.WrapperWith(i)));

        for (var i = 0; i < ActionTypes.Length; i++)
            wrappers = wrappers.AddSureNotPresent(ActionTypes[i],
                WrapperExpressionFactory.Of(static (r, f) => GetFuncOrActionExpressionOrDefault(r, f), Setup.WrapperWith(unwrap: typeof(void).ToFunc<Type, Type>)));

        wrappers = wrappers.AddSureNotPresent(typeof(IDictionary<,>),
            WrapperExpressionFactory.Of(static (r, _) => GetDictionaryExpressionOrDefault(r), Setup.WrapperWith(1)));

        wrappers = wrappers.AddContainerInterfaces();
        return wrappers;
    }

    private static ImHashMap<Type, object> AddContainerInterfaces(this ImHashMap<Type, object> wrappers)
    {
        var resolverContextExpr = new WrapperExpressionFactory.OfContainer(
            static (r, _) => ResolverContext.GetRootOrSelfExpr(r));

        var containerExpr = new WrapperExpressionFactory.OfContainer(
            static (r, _) => TryConvertIntrinsic<IContainer>(ResolverContext.GetRootOrSelfExpr(r)));

        var registratorExpr = new WrapperExpressionFactory.OfContainer(
            static (r, _) => TryConvertIntrinsic<IRegistrator>(ResolverContext.GetRootOrSelfExpr(r)));

        return wrappers
            .AddSureNotPresent(typeof(IContainer), containerExpr)
            .AddSureNotPresent(typeof(IRegistrator), registratorExpr)
            .AddSureNotPresent(typeof(IResolverContext), resolverContextExpr)
            .AddSureNotPresent(typeof(IResolver), resolverContextExpr)
            .AddSureNotPresent(typeof(IServiceProvider), resolverContextExpr);
    }

    internal static readonly MethodInfo ToArrayMethod = typeof(ArrayTools).GetMethod(nameof(ArrayTools.ToArrayOrSelf));

    private static Expression GetArrayExpression(Request request, Type collectionType = null)
    {
        collectionType ??= request.ActualServiceType;
        var container = request.Container;
        var rules = container.Rules;

        var serviceType = collectionType.GetArrayElementTypeOrNull() ?? collectionType.GetGenericArguments()[0];

        if (rules.ResolveIEnumerableAsLazyEnumerable)
        {
            var lazyEnumerableExpr = GetLazyEnumerableExpressionOrDefault(request, serviceType);
            return collectionType.GetGenericDefinitionOrNull() != typeof(IEnumerable<>)
                ? Call(ToArrayMethod.MakeGenericMethod(serviceType), lazyEnumerableExpr)
                : lazyEnumerableExpr;
        }

        var details = request.GetServiceDetails();
        var requiredItemType = container.GetWrappedType(serviceType, details.RequiredServiceType);

        var items = container.GetAllServiceFactories(requiredItemType)
            .Map(requiredItemType, static (t, x) => new ServiceRegistrationInfo(x.Value, t, x.Key));

        if (requiredItemType.IsClosedGeneric())
        {
            var requiredItemOpenGenericType = requiredItemType.GetGenericTypeDefinition();
            var openGenericItems = container.GetAllServiceFactories(requiredItemOpenGenericType)
                .Map(requiredItemOpenGenericType, requiredItemType,
                    static (gt, t, f) => new ServiceRegistrationInfo(f.Value, t, new ServiceKeyAndRequiredOpenGenericType(gt, f.Key)));
            items = items.Append(openGenericItems);
        }

        // Append registered generic types with compatible variance,
        // e.g. for IHandler<in E> - IHandler<A> is compatible with IHandler<B> if B : A.
        if (requiredItemType.IsGenericType && rules.VariantGenericTypesInResolvedCollection)
        {
            var variantGenericItems = container.GetServiceRegistrations(requiredItemType,
                static (ref Type reqItType, ref ServiceRegistrationInfo src, out ServiceRegistrationInfo res) =>
                {
                    res = src;
                    if (!reqItType.IsAssignableVariantGenericTypeFrom(src.ServiceType))
                        return false;
                    if (res.OptionalServiceKey == null)
                        res.OptionalServiceKey = DefaultKey.Value;
                    return true;
                });
            items = items.Append(variantGenericItems);
        }

        // Composite pattern support: filter out composite parent service skip wrappers and decorators
        var parent = request.Parent;
        if (parent.FactoryType != FactoryType.Service)
            parent = parent.FirstOrDefault(static p => p.FactoryType == FactoryType.Service) ?? Request.Empty;

        // check fast for the parent of the same type
        if (!parent.IsEmpty && parent.ActualServiceType == requiredItemType)
        {
            items = items.Match(parent.FactoryID, static (pfid, x) => x.Factory.FactoryID != pfid); // todo: @perf replace the Match with the in-place replacement with the `null` without reallocating the arrays
            if (requiredItemType.IsGenericType)
                items = items.Match(parent.FactoryID,
                    static (pfid, x) => x.Factory.GeneratedFactories?.Enumerate()
                        .FindFirst(pfid, static (fid, f) => f.Value.FactoryID == fid) == null);
        }

        // Return collection of items matched the specified key.
        var serviceKey = details.ServiceKey;
        if (serviceKey != null)
            items = items.Match(serviceKey, static (key, x) => key.MatchToNotNullRegisteredKey(x.OptionalServiceKey));

        var metadataKey = details.MetadataKey;
        var metadata = details.Metadata;
        if (metadataKey != null | metadata != null)
            items = items.Match(metadataKey, metadata, static (mk, m, x) => x.Factory.Setup.MatchesMetadata(mk, m));

        if (items.IsNullOrEmpty())
            return NewArrayInit(serviceType, Empty<Expression>());

        // todo: @perf replace explicit Sort with the insertion of the resolved expressions (which may be less than items) in the right position
        Array.Sort(items); // to resolve the items in order of registration

        var itemExprs = new Expression[items.Length];
        var itemExprIndex = 0;

        var multipleSameServiceKeySupport = rules.HasMultipleSameServiceKeyForTheServiceType;

        foreach (var item in items)
        {
            var itemServiceKey = EnsureItemKeyCanBeMatched(serviceKey, item.OptionalServiceKey, multipleSameServiceKeySupport);

            requiredItemType = item.ServiceType;
            var itemInfo = ServiceInfo.Of(serviceType, requiredItemType, IfUnresolved.ReturnDefaultIfNotRegistered, itemServiceKey);
            var itemRequest = request.Push(itemInfo);

            // For the required service type (not a wrapper) we at least looking at the unwrapped type, so we may check that type factory condition,
            // or going to resolve the nested wrapper and Store the unwrapped factory in the request but did not check it until we down the wrappers chain with all available information
            var factory = requiredItemType == serviceType
                ? itemRequest.MatchGeneratedFactoryByReuseAndConditionOrNull(item.Factory)
                : container.ResolveFactory(itemRequest.WithWrappedServiceFactory(item.Factory));

            var itemExpr = factory?.GetExpressionOrDefault(itemRequest);
            if (itemExpr != null)
                itemExprs[itemExprIndex++] = itemExpr;
        }

        if (itemExprIndex < itemExprs.Length)
            Array.Resize(ref itemExprs, itemExprIndex);

        return NewArrayInit(serviceType, itemExprs);
    }

    internal static object EnsureItemKeyCanBeMatched(object resolutionKey, object itemKey, bool multipleSameServiceKeySupport)
    {
        if (resolutionKey != null && resolutionKey is not Registrator.AnyServiceKey && itemKey is Registrator.AnyServiceKey)
            itemKey = Registrator.AnyKeyOfResolutionKey(resolutionKey);

        var typeAndKeyWrapped = itemKey as ServiceKeyAndRequiredOpenGenericType;
        var k = typeAndKeyWrapped != null ? typeAndKeyWrapped.ServiceKey : itemKey;
        if (multipleSameServiceKeySupport &&
            k is not DefaultKey && k is not DefaultDynamicKey && // the key is not the default one
            k is not UniqueRegisteredServiceKey && // is not already of a multi-keyed
            k is not Registrator.AnyServiceKey) // is not for the any service key
        {
            if (typeAndKeyWrapped != null)
                typeAndKeyWrapped.ServiceKey = k;
            else
                itemKey = new UniqueRegisteredServiceKey(k);
        }

        return itemKey;
    }

    private static readonly MethodInfo _enumerableCastMethod = typeof(Enumerable).GetMethod(nameof(Enumerable.Cast));

    private static Expression GetLazyEnumerableExpressionOrDefault(Request request, Type itemType = null)
    {
        if (itemType == null)
        {
            var collectionType = request.ServiceType;
            itemType = collectionType.GetArrayElementTypeOrNull() ?? collectionType.GetGenericArguments()[0];
        }
        var container = request.Container;
        var details = request.GetServiceDetails();
        var requiredItemType = container.GetWrappedType(itemType, details.RequiredServiceType);
        var resolverExpr = ResolverContext.GetRootOrSelfExpr(request);
        var preResolveParentExpr = container.GetRequestExpression(request);

        var resolveManyExpr = Call(resolverExpr, Resolver.ResolveManyMethod,
            ConstantOf<Type>(itemType),
            container.GetConstantExpression(details.ServiceKey),
            ConstantOf<Type>(requiredItemType),
            preResolveParentExpr,
            request.GetInputArgsExpr());

        return New(typeof(LazyEnumerable<>).MakeGenericType(itemType).GetConstructors()[0],
            // cast to object is not required cause Resolve already returns IEnumerable<object>
            itemType == typeof(object) ? resolveManyExpr : Call(_enumerableCastMethod.MakeGenericMethod(itemType), resolveManyExpr));
    }

    /// <summary>Gets the expression for <see cref="Lazy{T}"/> wrapper.</summary>
    /// <param name="request">The resolution request.</param>
    /// <param name="serviceFactory">The already resolved factory by the collection or the higher wrapper.</param>
    /// <returns>Expression: <c><![CDATA[r => new Lazy<TService>(() => r.Resolve{TService}(key, ifUnresolved, requiredType))]]></c></returns>
    public static Expression GetLazyExpressionOrDefault(Request request, Factory serviceFactory = null)
    {
        var wrapperType = request.ActualServiceType;
        var serviceType = wrapperType.GetGenericArguments()[0];
        var serviceRequest = request.PushServiceType(serviceType);

        var generateResolutionCallForMissingDependency = false;
        var container = request.Container;
        if (!container.Rules.FuncAndLazyWithoutRegistration)
        {
            // Here we need to know if Lazy is resolvable, 
            // by resolving the factory we are checking that the service itself is registered...
            // But what about its dependencies. In order to check on them we need to get the expression,
            // but avoid the creation of singletons on the way (and materializing the types) - because "lazy".
            // Plus we need to stop on the encountering the root service because lazy permits a circular dependencies.
            // See #449 for additional details
            var factory = serviceFactory ?? container.ResolveFactory(serviceRequest);
            if (factory != null)
                serviceRequest = serviceRequest.WithResolvedFactory(factory, skipRecursiveDependencyCheck: true);
            else if (container.Rules.GenerateResolutionCallForMissingDependency)
                generateResolutionCallForMissingDependency = true;
            else
                return null;
        }

        // creates: r => new Lazy(() => r.Resolve<X>(key))
        // or for singleton : r => new Lazy(() => r.Root.Resolve<X>(key))
        var serviceExpr = Resolver.CreateResolutionExpression(serviceRequest,
            stopRecursiveDependencyCheck: true,
            generateResolutionCallForMissingDependency: generateResolutionCallForMissingDependency);

        var funcType = typeof(Func<>).MakeGenericType(serviceType);
        var wrapperCtor = wrapperType.Constructor(funcType);
        return New(wrapperCtor, Lambda(funcType, serviceExpr, Empty<ParameterExpression>(), serviceType));
    }

    /// <summary>Exposing for creation of custom delegates #243</summary>
    public static Expression GetFuncOrActionExpressionOrDefault(Request request, Factory serviceFactory = null)
    {
        var wrapperType = request.ActualServiceType;
        var isAction = wrapperType == typeof(Action);
        if (!isAction)
        {
            var openGenericWrapperType = wrapperType.GetGenericDefinitionOrNull(); // cannot be null
            if (FuncTypes.IndexOf(openGenericWrapperType, default(RefEq<Type>)) == -1)
            {
                isAction = ActionTypes.IndexOf(openGenericWrapperType, default(RefEq<Type>)) != -1;
                Throw.If(!isAction); // todo: @feature add distinct error message
            }
        }

        var argTypes = wrapperType.GetGenericArguments();
        var argCount = isAction ? argTypes.Length : argTypes.Length - 1;
        var serviceType = isAction ? typeof(void) : argTypes[argCount];

        var container = request.Container;

        // Special case for the Factory delegate of Func<IResolverContext, ?>, 
        // so we may avoid using the InputArgs and use the result expression directly
        if (!isAction & argCount == 1 && argTypes[0] == typeof(IResolverContext))
        {
            serviceType = wrapperType == typeof(Func<IResolverContext, object>)
                ? request.RequiredServiceType.ThrowIfNull(Error.ResolutionNeedsRequiredServiceType, request)
                : request.RequiredServiceType ?? serviceType;

            request = request.PushServiceType(serviceType);
            var expr = request.Container.ResolveFactory(request)?.GetExpressionOrDefault(request);
            if (expr == null)
                return null;

            var useInterpretation = request.Container.Rules.UseInterpretation;
            if (wrapperType == typeof(Func<IResolverContext, object>))
            {
                if (useInterpretation)
                {
                    Func<IResolverContext, object> fac = r =>
                        Interpreter.TryInterpretNestedLambdaBodyAndUnwrapException(r, expr, FactoryDelegateCompiler.FactoryDelegateParamExprs, r, null);
                    return new ValueConstantExpression<Func<IResolverContext, object>>(fac);
                }

                return new ValueConstantExpression<Func<IResolverContext, object>>(expr.CompileOrInterpretFactoryDelegate(false));
            }

            if (useInterpretation)
            {
                Func<IResolverContext, object> fac = r =>
                    Interpreter.TryInterpretNestedLambdaBodyAndUnwrapException(r, expr, FactoryDelegateCompiler.FactoryDelegateParamExprs, r, null);
                var typedFacObj = Interpreter.ConvertFactoryDelegateMethod.MakeGenericMethod(serviceType).Invoke(null, new[] { fac });
                return new ValueConstantExpression(typedFacObj);
            }

            return new ValueConstantExpression(expr.CompileTypedResultFactoryDelegate(wrapperType, serviceType));
        }

        var argExprs = Empty<ParameterExpression>();
        if (argCount != 0)
        {
            argExprs = new ParameterExpression[argCount];
            for (var i = 0; i < argCount; ++i)
                // assign valid unique argument names for code generation
                argExprs[i] = Parameter(argTypes[i], argTypes[i].Name + "@" + i); // todo: optimize string allocations
            request = request.WithInputArgs(argExprs);
        }

        var serviceRequest = request.PushServiceType(serviceType,
            RequestFlags.IsWrappedInFunc | RequestFlags.IsDirectlyWrappedInFunc);

        Expression serviceExpr;
        if (!isAction && container.Rules.FuncAndLazyWithoutRegistration)
            serviceExpr = Resolver.CreateResolutionExpression(serviceRequest, openResolutionScope: false, stopRecursiveDependencyCheck: true);
        else if (serviceFactory == null)
        {
            serviceFactory = container.ResolveFactory(serviceRequest);
            if (serviceFactory == null && container.Rules.GenerateResolutionCallForMissingDependency)
                serviceExpr = Resolver.CreateResolutionExpression(serviceRequest, stopRecursiveDependencyCheck: true, generateResolutionCallForMissingDependency: true);
            else
            {
                serviceExpr = serviceFactory?.GetExpressionOrDefault(serviceRequest);
                if (serviceExpr == null)
                    return null;
            }
        }
        else
        {
            serviceFactory = serviceType == container.GetWrappedType(serviceType, request.RequiredServiceType)
                ? serviceRequest.MatchGeneratedFactoryByReuseAndConditionOrNull(serviceFactory)
                : container.ResolveFactory(serviceRequest.WithWrappedServiceFactory(serviceFactory));
            serviceExpr = serviceFactory?.GetExpressionOrDefault(serviceRequest);
            if (serviceExpr == null)
                return null;
        }
        return Lambda(wrapperType, serviceExpr, argExprs, serviceType);
    }

    /// <summary>Creating new array expression and then converting it ToDictionary of service -> service key pairs</summary>
    public static Expression GetDictionaryExpressionOrDefault(Request request)
    {
        var dictType = request.ActualServiceType;
        var keyValueTypes = dictType.GetGenericArguments();
        var keyValueType = typeof(KeyValuePair<,>).MakeGenericType(keyValueTypes);
        var arrType = keyValueType.MakeArrayType();
        var arrExpr = GetArrayExpression(request, arrType);
        var dictMethod = _wrapInDictionaryMethod.MakeGenericMethod(keyValueTypes);
        return Call(dictMethod, arrExpr);
    }

    /// <summary>The method converting collection to dictionary wrapper</summary>
    public static IDictionary<K, V> WrapInDictionary<K, V>(KeyValuePair<K, V>[] pairs)
    {
        var dict = new Dictionary<K, V>(pairs.Length);
        foreach (var pair in pairs)
            dict.Add(pair.Key, pair.Value);
        return dict;
    }

    private static readonly MethodInfo _wrapInDictionaryMethod = typeof(WrappersSupport).GetMethod(nameof(WrapInDictionary));

    private static Expression GetLambdaExpressionExpressionOrDefault(Request request)
    {
        request = request.PushServiceType(request.RequiredServiceType.ThrowIfNull(Error.ResolutionNeedsRequiredServiceType, request));
        var expr = request.Container.ResolveFactory(request)?.GetExpressionOrDefault(request);
        return expr == null ? null : ConstantOf<System.Linq.Expressions.LambdaExpression>(expr.WrapInFactoryExpression().ToLambdaExpression());
    }

    private static Expression GetFastExpressionCompilerLambdaExpressionExpressionOrDefault(Request request)
    {
        request = request.PushServiceType(request.RequiredServiceType.ThrowIfNull(Error.ResolutionNeedsRequiredServiceType, request));
        var expr = request.Container.ResolveFactory(request)?.GetExpressionOrDefault(request);
        return expr == null ? null : ConstantOf<FastExpressionCompiler.LightExpression.LambdaExpression>(expr.WrapInFactoryExpression());
    }

    private static Expression GetKeyValuePairExpressionOrDefault(Request request, Factory serviceFactory = null)
    {
        var wrapperType = request.ActualServiceType;
        var typeArgs = wrapperType.GetGenericArguments();
        var requiredServiceKeyType = typeArgs[0];
        var serviceKey = request.ServiceKey;

        var actualServiceKey = serviceKey is ServiceKeyAndRequiredOpenGenericType skt ? skt.ServiceKey : serviceKey;
        actualServiceKey = actualServiceKey is UniqueRegisteredServiceKey usk ? usk.ServiceKey : actualServiceKey;

        if (actualServiceKey == null && requiredServiceKeyType.IsValueType ||
            actualServiceKey != null && !requiredServiceKeyType.IsAssignableFrom(actualServiceKey.GetType()))
            return null;

        var serviceType = typeArgs[1];
        var serviceRequest = serviceKey == null
            ? request.PushServiceType(serviceType)
            : request.Push(serviceType, serviceKey);

        var container = request.Container;
        Factory factory;
        if (serviceFactory == null)
            factory = container.ResolveFactory(serviceRequest);
        else
            factory = serviceType == container.GetWrappedType(serviceType, request.RequiredServiceType)
                ? serviceRequest.MatchGeneratedFactoryByReuseAndConditionOrNull(serviceFactory)
                : container.ResolveFactory(serviceRequest.WithWrappedServiceFactory(serviceFactory));

        var serviceExpr = factory?.GetExpressionOrDefault(serviceRequest);
        if (serviceExpr == null)
            return null;

        var keyExpr = request.Container.GetConstantExpression(actualServiceKey, requiredServiceKeyType);
        return New(wrapperType.GetConstructors()[0], keyExpr, serviceExpr);
    }

    /// <summary>Discovers and combines service with its setup metadata.
    /// Works with any generic type with first Type arg - Service type and second Type arg - Metadata type,
    /// and constructor with Service and Metadata arguments respectively.
    /// - if service key is not specified in request then method will search for all
    /// registered factories with the same metadata type ignoring keys.
    /// - if metadata is IDictionary{string, object},
    ///  then the First value matching the TMetadata type will be returned.</summary>
    public static Expression GetMetaExpressionOrDefault(Request request, Factory serviceFactory = null)
    {
        var metaType = request.ActualServiceType;
        var typeArgs = metaType.GetGenericArguments();
        var metaCtor = metaType.GetConstructorOrNull(typeArgs).ThrowIfNull(Error.NotFoundMetaCtorWithTwoArgs, typeArgs, request);

        var metadataType = typeArgs[1];
        var serviceType = typeArgs[0];

        var details = request.GetServiceDetails();
        var serviceKey = details.ServiceKey;

        var container = request.Container;
        var requiredServiceType = container.GetWrappedType(serviceType, details.RequiredServiceType);

        // The factory is passed from the higher wrapper (collection or other).
        // It was already checked by the higher wrapper so no need to repeat the check here.
        if (serviceFactory != null)
        {
            // The check is only relevant to metadata, the higher wrappers know nothing about it.
            if (!serviceFactory.MatchMetadataType(metadataType))
                return null;
        }
        else
        {
            var factories = container.GetAllServiceFactoriesPlusForOpenGeneric(requiredServiceType);
            if (factories.Length == 0)
                return null;

            if (serviceKey != null)
            {
                factories = factories.Match(serviceKey, static (key, f) => key.MatchToNotNullRegisteredKey(f.Key));
                if (factories.Length == 0)
                    return null;
            }

            // if the service keys for some reason are not unique
            factories = factories.Match(metadataType, static (mType, f) => f.Value.MatchMetadataType(mType));
            if (factories.Length == 0)
                return null;

            // Prevent non-determinism when more than 1 factory is matching the metadata
            if (factories.Length > 1)
            {
                if (details.IfUnresolved == IfUnresolved.Throw)
                    Throw.It(Error.UnableToSelectFromManyRegistrationsWithMatchingMetadata, metadataType, factories, request);
                return null;
            }

            var keyedFactory = factories[0];
            if (keyedFactory == null)
                return null;

            // The key may be different in case of initial serviceKey was null.
            // It even may be a non-default key, see Should_resolve_any_named_service_with_corresponding_metadata_If_name_is_not_specified_in_resolve
            serviceKey = keyedFactory.Key;
            serviceFactory = keyedFactory.Value;
        }

        var serviceRequest = request.Push(ServiceInfo.Of(serviceType, serviceKey));

        // For the required service type (not a wrapper) we at least looking at the unwrapped type, so we may check that type factory condition,
        // or going to resolve the nested wrapper and Store the unwrapped factory in the request but did not check it until we down the wrappers chain with all available information
        var factory = requiredServiceType == serviceType
            ? serviceRequest.MatchGeneratedFactoryByReuseAndConditionOrNull(serviceFactory)
            : container.ResolveFactory(serviceRequest.WithWrappedServiceFactory(serviceFactory));

        var serviceExpr = factory?.GetExpressionOrDefault(serviceRequest);
        if (serviceExpr == null)
            return null;

        var resultMetadata = serviceFactory.Setup.GetMetadataValueMatchedByMetadataType(metadataType);
        var metadataExpr = container.GetConstantExpression(resultMetadata, metadataType);
        return New(metaCtor, serviceExpr, metadataExpr);
    }

    /// <summary>Find out if factory metadata is matches the passed metadata type</summary>
    public static bool MatchMetadataType(this Factory f, Type metadataType)
    {
        var metadata = f.Setup.Metadata;
        if (metadata == null)
            return false;

        if (metadataType == typeof(object))
            return true;

        if (metadata is IDictionary<string, object> metadataDict)
        {
            if (metadataType == typeof(IDictionary<string, object>))
                return true;
            foreach (var m in metadataDict)
                if (m.Value != null && metadataType.IsAssignableFrom(m.Value.GetType()))
                    return true;
            return false;
        }

        return metadataType.IsAssignableFrom(metadata.GetType());
    }
}

/// <summary>Represents info required for dynamic registration: service key, factory,
/// and <see cref="IfAlreadyRegistered"/> option how to combine dynamic with normal registrations.</summary>
public sealed class DynamicRegistration
{
    /// <summary>Factory</summary>
    public readonly Factory Factory;

    /// <summary>Optional: will be <see cref="DryIoc.IfAlreadyRegistered.AppendNotKeyed"/> by default.</summary>
    public readonly IfAlreadyRegistered IfAlreadyRegistered;

    /// <summary>Optional service key: if null the default <see cref="DefaultDynamicKey"/> will be used. </summary>
    public readonly object ServiceKey;

    /// <summary>Constructs the registration</summary>
    public DynamicRegistration(Factory factory,
        IfAlreadyRegistered ifAlreadyRegistered = IfAlreadyRegistered.AppendNotKeyed, object serviceKey = null)
    {
        Factory = factory.ThrowIfNull().DoNotCache();
        ServiceKey = serviceKey;
        IfAlreadyRegistered = ifAlreadyRegistered;
    }
}

/// <summary>The options for the single dynamic registration provider.
/// The dynamic Wrapper registration is not supported.</summary>
[Flags]
public enum DynamicRegistrationFlags : byte
{
    /// <summary>No flags - to use in `HasDynamicRegistrationProvider`</summary>
    NoFlags = 0,
    /// <summary>Use as AsFallback only</summary>
    AsFallback = 1,
    /// <summary>Provider may have the services provided</summary>
    Service = 1 << 1,
    /// <summary>Provider may have the decorators provided</summary>
    Decorator = 1 << 2,
    /// <summary>Specifies that provider should be asked for the `object` service type to get the decorator for the generic `T` service</summary>
    DecoratorOfAnyTypeViaObjectServiceType = 1 << 3,
}

internal sealed class UniqueRegisteredServiceKey : IPrintable, IConvertibleToExpression
{
    public readonly int Index;
    public readonly object ServiceKey;

    // A special constructor for the key resolved from the collection wrapper or ResolveMany, check the usages of it
    internal UniqueRegisteredServiceKey(object serviceKey)
    {
        Debug.Assert(serviceKey != null);
        ServiceKey = serviceKey;
    }

    public UniqueRegisteredServiceKey(object serviceKey, int index)
    {
        Debug.Assert(serviceKey != null);
        ServiceKey = serviceKey;
        Index = index;
    }

    /// <inheritdoc />
    public StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer) =>
        printer(s.Append("USK("), ServiceKey).Append(", ").Append(Index).Append(')');

    /// <summary>Creates a nice string view.</summary>
    public override string ToString() =>
        Print(new StringBuilder(), PrintTools.Print).ToString();

    /// <summary>Faster comparison all the way - no virtual calls</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Equals(UniqueRegisteredServiceKey key, object obj) =>
        obj is UniqueRegisteredServiceKey other && other.Index == key.Index &&
        (ReferenceEquals(other.ServiceKey, key.ServiceKey) || Equals(other.ServiceKey, key.ServiceKey));

    /// <summary>Returns true if both key and the index are equal.</summary>
    public override bool Equals(object obj) => Equals(this, obj);

    /// <summary>Combines key and index</summary>
    public override int GetHashCode() => Hasher.Combine(ServiceKey, Index);

    /// <inheritdoc />
    public Expression ToExpression<S>(S state, Func<S, object, Expression> fallbackConverter) =>
        New(_ctor, fallbackConverter(state, ServiceKey), ConstantInt(Index));

    // todo: @perf use UnsafeAccessAttribute to avoid reflection
    private static readonly ConstructorInfo _ctor = typeof(UniqueRegisteredServiceKey).GetConstructors()[0];

}

/// <summary>Enables de-duplication of service key by putting key into the pair with index of its paired service type.</summary>
public sealed class ServiceKeyToTypeIndex
{
    // Logically, it is a mapping of ServiceKey to the List of pairs of { ServiceType, Count of the ServiceType registration with this key }
    // Practically, it is the map where Key is ServiceKey and the Value is Type | string | (KV<object, int> where object is Type | String) | (object[] where object is one of the mentioned before) 
    private ImHashMap<object, object> _index = ImHashMap<object, object>.Empty;

    /// <summary>Stores the key with respective type in the index map, 
    /// incrementing type count for multiple registrations with same key and type.</summary>
    public object EnsureUniqueServiceKey(object serviceTypeOrName, object serviceKey) =>
        EnsureUniqueServiceKey(ref _index, serviceTypeOrName, serviceKey);

    /// <summary>Stores the key with respective type in the index map,
    /// incrementing type count for multiple registrations with same key and type.</summary>
    public static object EnsureUniqueServiceKey(ref ImHashMap<object, object> index, object serviceTypeOrName, object serviceKey)
    {
        Ref.Swap(ref index, ref serviceTypeOrName, ref serviceKey, UpdateMap);
        return serviceKey;

        static ImHashMap<object, object> UpdateMap(ImHashMap<object, object> m, ref object t, ref object k) =>
            m.AddOrUpdate(k, t, ref k, UpdateTypes);

        static object UpdateTypes(object originalKey, object oldTypeOrTypes, object newTypeOrName, ref object uniqueKey)
        {
            if (oldTypeOrTypes is Type || oldTypeOrTypes is string)
            {
                if (ReferenceEquals(oldTypeOrTypes, newTypeOrName) || Equals(oldTypeOrTypes, newTypeOrName))
                {
                    uniqueKey = new UniqueRegisteredServiceKey(originalKey, 1);
                    return KV.Of(oldTypeOrTypes, 2);
                }
                return new[] { oldTypeOrTypes, newTypeOrName };
            }
            else if (oldTypeOrTypes is KV<object, int> singleTypeWithCount)
            {
                var typeOrName = singleTypeWithCount.Key;
                if (ReferenceEquals(typeOrName, newTypeOrName) || Equals(typeOrName, newTypeOrName))
                {
                    uniqueKey = new UniqueRegisteredServiceKey(originalKey, singleTypeWithCount.Value);
                    return singleTypeWithCount.WithValue(singleTypeWithCount.Value + 1);
                }
                return new[] { oldTypeOrTypes, newTypeOrName };
            }
            else
            {
                var types = (object[])oldTypeOrTypes;
                Debug.Assert(types.Length > 1, "we use array only for 2 and more types/pairs with count");

                var foundTypeIndex = types.IndexOf(newTypeOrName,
                    static (nt, t) => ReferenceEquals(t, nt) || Equals(t, nt) ||
                        (t is KV<object, int> kv && (ReferenceEquals(kv.Key, nt) || Equals(kv.Key, nt))));

                if (foundTypeIndex != -1)
                {
                    var foundTypeOrTypeWithCount = types[foundTypeIndex];
                    if (foundTypeOrTypeWithCount is Type || foundTypeOrTypeWithCount is string)
                    {
                        uniqueKey = new UniqueRegisteredServiceKey(originalKey, 1);
                        return types.UpdateNonEmpty(KV.Of(foundTypeOrTypeWithCount, 2), foundTypeIndex);
                    }
                    else
                    {
                        var foundTypeWithCount = (KV<object, int>)foundTypeOrTypeWithCount;
                        var typeCount = foundTypeWithCount.Value;
                        uniqueKey = new UniqueRegisteredServiceKey(originalKey, typeCount);
                        return types.UpdateNonEmpty(foundTypeWithCount.WithValue(typeCount + 1), foundTypeIndex);
                    }
                }

                return types.AppendToNonEmpty(newTypeOrName);
            }
        }
    }

    /// <summary>Retrieves types and their count used with specified <paramref name="serviceKey"/>.</summary>
    /// <param name="serviceKey">Service key to get info.</param>
    /// <returns>Types and their count for the specified key, if key is not stored - returns null.</returns>
    [MethodImpl((MethodImplOptions)256)]
    public object GetServiceTypesOrDefault(object serviceKey) =>
        _index.GetValueOrDefault(serviceKey);
}

/// <summary> Defines resolution/registration rules associated with Container instance. They may be different for different containers.</summary>
public sealed class Rules
{
    private static Rules _default = new Rules();

    /// <summary>Default rules as a staring point.</summary>
    public static Rules Default => _default;

    /// <summary>For diagnostics and for the tests statically apply the setting.
    /// Ensure that you do that before creating the container with default rules, or the rules inherited from the default</summary>
    public static void UnsafeResetDefaultRulesToUseCompilationOnly() =>
        _default = _default.WithoutUseInterpretation();

    // Logically, it is a mapping of ServiceKey to the List of pairs of { ServiceType, Count of the ServiceType registration with this key }
    // Practically, it is the map where Key is ServiceKey and the Value is Type | string | (KV<object, int> where object is Type | String) | (object[] where object is one of the mentioned before) 
    private ImHashMap<object, object> _serviceKeyToTypeIndex;

    /// <summary>Mapping between service key and all the types registered with it.</summary>
    public ImHashMap<object, object> ServiceKeyToTypeIndex => _serviceKeyToTypeIndex;

    /// <summary>Stores the key with respective type in the index map,
    /// incrementing the type count for multiple registrations with same key and type.</summary>
    public object EnsureUniqueServiceKey(object serviceTypeOrName, object serviceKey) =>
        DryIoc.ServiceKeyToTypeIndex.EnsureUniqueServiceKey(ref _serviceKeyToTypeIndex, serviceTypeOrName, serviceKey);

    /// <summary>Retrieves types and their count used with specified <paramref name="serviceKey"/>.</summary>
    /// <param name="serviceKey">Service key to get info.</param>
    /// <returns>Types and their count for the specified key, if Type is only one then returns just the Type without count 
    /// if key is not stored - returns null.</returns>
    [MethodImpl((MethodImplOptions)256)]
    public object GetServiceTypesByServiceKeyOrDefault(object serviceKey) =>
        _serviceKeyToTypeIndex.GetValueOrDefault(serviceKey);

    private static Rules WithMicrosoftDependencyInjectionRules(Rules rules, ParameterSelector parameters)
    {
        var made = rules._made;
        var newMade = made.With(
            DryIoc.FactoryMethod.ConstructorWithResolvableArguments,
            made.Parameters.OverrideWith(parameters));

        var newRules = rules.With(newMade);

        newRules._settings = (rules._settings
            | Settings.TrackingDisposableTransients
            | Settings.SelectLastRegisteredFactory)
            & ~Settings.ThrowOnRegisteringDisposableTransient
            & ~Settings.VariantGenericTypesInResolvedCollection;

        newRules._serviceKeyToTypeIndex ??= ImHashMap<object, object>.Empty;

        newRules.FactorySelector = SelectLastRegisteredFactory;
        return newRules;
    }

    /// <summary>Returns the basic rules for the Microsoft.Extension.DependencyInjection 
    /// EXCEPT for ParameterSelector for the keyed services, which should be provided as parameter.
    /// That's why you should use the `DryIocAdapter.WithMicrosoftDependencyInjectionRules` instead.</summary>
    [Obsolete("Please use DryIoc.Microsoft.DependencyInjection.DryIocAdapter.MicrosoftDependencyInjectionRules")]
    public static readonly Rules MicrosoftDependencyInjectionRules = WithMicrosoftDependencyInjectionRules(Default, null);

    /// <summary>Checks if the rules "include" the same settings and conventions as the basic MicrosoftDependencyInjectionRules.
    /// It means that the rules may "include" other things, e.g. `WithConcreteTypeDynamicRegistrations`, etc.</summary>
    [Obsolete("Please use DryIoc.Microsoft.DependencyInjection.DryIocAdapter.HasMicrosoftDependencyInjectionRules")]
    public bool HasMicrosoftDependencyInjectionRules() => HasBaseMicrosoftDependencyInjectionRules(MicrosoftDependencyInjectionRules);

    /// <summary>Checks if the rules "include" the same settings and conventions as the basic MicrosoftDependencyInjectionRules.
    /// It means that the rules may "include" other things, e.g. `WithConcreteTypeDynamicRegistrations`, etc.</summary>
    public bool HasBaseMicrosoftDependencyInjectionRules(Rules exactRulesToCompare)
    {
        if (this == exactRulesToCompare)
            return true;

        var factoryMethod = _made.FactoryMethodOrSelector;
        var theRightFactoryMethod =
            ReferenceEquals(factoryMethod, DryIoc.FactoryMethod.ConstructorWithResolvableArguments) ||
            ReferenceEquals(factoryMethod, DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublic) ||
            ReferenceEquals(factoryMethod, DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublicWithoutSameTypeParam);

        return theRightFactoryMethod &&
            FactorySelector == SelectLastRegisteredFactory &&
            _serviceKeyToTypeIndex != null &&
            (_settings & Settings.SelectLastRegisteredFactory) != 0 &&
            (_settings & Settings.TrackingDisposableTransients) != 0 &&
            (_settings & Settings.ThrowOnRegisteringDisposableTransient) == 0 &&
            (_settings & Settings.VariantGenericTypesInResolvedCollection) == 0;
    }

    /// <summary>Create the basic rules for the Microsoft.Extension.DependencyInjection 
    /// EXCEPT for ParameterSelector for the keyed services, which should be provided as parameter.
    /// That's why you should use the `DryIocAdapter.WithMicrosoftDependencyInjectionRules` instead.</summary>
    [Obsolete("Please use DryIoc.Microsoft.DependencyInjection.DryIocAdapter.WithMicrosoftDependencyInjectionRules")]
    public Rules WithMicrosoftDependencyInjectionRules() =>
        WithBaseMicrosoftDependencyInjectionRules(null);

    /// <summary>Creates the rules for the Microsoft.Extension.DependencyInjection 
    /// together with the ParameterSelector for the keyed services, which should be provided as parameter</summary>
    public Rules WithBaseMicrosoftDependencyInjectionRules(ParameterSelector parameters) =>
        WithMicrosoftDependencyInjectionRules(this, parameters);

    /// <summary>By default the `IServiceProvider.GetService` is returning `null` if service is not resolved. 
    /// So you need to call the `GetRequiredService` extension method which in turn requires the implementation of `ISupportRequiredService` underneath.
    /// To help with this mess you may use this rule to force the `GetService` to throw an exception the same as calling `GetRequiredService`.
    /// This may help to diagnose the problems in debug or in tests, or in some custom setup.</summary>
    public Rules WithServiceProviderGetServiceShouldThrowIfUnresolved() =>
        WithSettings(_settings | Settings.ServiceProviderGetServiceShouldThrowIfUnresolved);

    /// <summary><see cref="WithServiceProviderGetServiceShouldThrowIfUnresolved"/></summary>
    public bool ServiceProviderGetServiceShouldThrowIfUnresolved =>
        (_settings & Settings.ServiceProviderGetServiceShouldThrowIfUnresolved) != 0;

    /// <summary>The default total dependency count - a expression tree node count to split the object graph</summary>
    public const int DefaultDependencyCountInLambdaToSplitBigObjectGraph = 1024;

    /// <summary>The total dependency count - the expression tree node count to split the object graph.
    /// That does not mean the graph can be always split at this number, consider the example graph and
    /// the dependency count threshold set to 3:
    ///
    /// `x = new X(new Y(A, new B(K), new C(new L(), new M())), new Z())`
    /// 
    /// The tree is resolved from the left to the right in the depth-first order:
    /// A; then K, B (at this point Y is already has 3 dependencies but is not fully resolved until C is resolved);
    /// then L, M, C (here Y is fully resolved with 6 dependencies) so we can split it only on 6 dependencies instead of 3.
    ///
    /// The split itself just wraps the node in `Func{T}` delegate making it a separate compilation unit.
    /// In our example it will be `Func{Y} f = () => new Y(A, new B(K), new C(new L(), new M()))` considering
    /// that everything is transient.
    /// </summary>
    public int DependencyCountInLambdaToSplitBigObjectGraph { get; private set; }

    /// <summary>Sets the <see cref="DependencyCountInLambdaToSplitBigObjectGraph"/></summary>
    public Rules WithDependencyCountInLambdaToSplitBigObjectGraph(int dependencyCount)
    {
        var rules = Clone();
        rules.DependencyCountInLambdaToSplitBigObjectGraph = dependencyCount < 1 ? 1 : dependencyCount;
        return rules;
    }

    /// <summary>Disables the <see cref="DependencyCountInLambdaToSplitBigObjectGraph"/> limitation.</summary>
    public Rules WithoutDependencyCountInLambdaToSplitBigObjectGraph() =>
        WithDependencyCountInLambdaToSplitBigObjectGraph(int.MaxValue);

    /// <summary>Shorthand to <see cref="Made.FactoryMethodOrSelector"/></summary>
    public object FactoryMethodOrSelector => _made.FactoryMethodOrSelector;

    /// <summary>Shorthand to <see cref="Made.Parameters"/></summary>
    public ParameterSelector Parameters => _made.Parameters;

    /// <summary>Shorthand to <see cref="Made.PropertiesAndFields"/></summary>
    public PropertiesAndFieldsSelector PropertiesAndFields => _made.PropertiesAndFields;

    /// <summary>Instructs to override per-registration made settings with these rules settings.</summary>
    public bool OverrideRegistrationMade =>
        (_settings & Settings.OverrideRegistrationMade) != 0;

    /// <summary>Returns the parameter selector based on <see cref="OverrideRegistrationMade"/></summary>
    public ParameterSelector TryGetParameterSelector(Made made) =>
        OverrideRegistrationMade ? made.Parameters.OverrideWith(Parameters) : Parameters.OverrideWith(made.Parameters);

    /// <summary>Returns the properties and fields selector based on <see cref="OverrideRegistrationMade"/></summary>
    public PropertiesAndFieldsSelector TryGetPropertiesAndFieldsSelector(Made made) =>
        OverrideRegistrationMade
            ? made.PropertiesAndFields.OverrideWith(PropertiesAndFields)
            : PropertiesAndFields.OverrideWith(made.PropertiesAndFields);

    /// <summary>Returns new instance of the rules new Made composed out of
    /// provided factory method, parameters, propertiesAndFields.</summary>
    public Rules With(
        FactoryMethodSelector factoryMethod = null,
        ParameterSelector parameters = null,
        PropertiesAndFieldsSelector propertiesAndFields = null) =>
        With(Made.Create(factoryMethod, parameters, propertiesAndFields, false));

    /// <summary>Returns new instance of the rules with specified <see cref="Made"/>.</summary>
    /// <param name="made">New Made.Of rules.</param>
    /// <param name="overrideRegistrationMade">Instructs to override registration level Made.Of</param>
    /// <returns>New rules.</returns>
    public Rules With(Made made, bool overrideRegistrationMade = false)
    {
        var rules = Clone();
        if (overrideRegistrationMade)
            rules._settings = _settings | Settings.OverrideRegistrationMade;
        rules._made = _made == Made.Default ? made :
            Made.Create( // todo: @bug @unclear should we replace it with override?
                made.FactoryMethodOrSelector ?? _made.FactoryMethodOrSelector,
                made.Parameters ?? _made.Parameters,
                made.PropertiesAndFields ?? _made.PropertiesAndFields,
                made.IsConditionalImplementation || _made.IsConditionalImplementation);
        return rules;
    }

    /// <summary>Service key to be used instead on `null` in registration.</summary>
    public object DefaultRegistrationServiceKey { get; private set; }

    /// <summary>Sets the <see cref="DefaultRegistrationServiceKey"/></summary>
    public Rules WithDefaultRegistrationServiceKey(object serviceKey)
    {
        if (serviceKey == null)
            return this;
        var rules = Clone();
        rules.DefaultRegistrationServiceKey = serviceKey;
        return rules;
    }

    /// <summary>Defines single factory selector delegate. 
    /// The only one of the passed parameters `singleDefaultFactory` or `orManyDefaultAndKeyedFactories` is not `null`</summary>
    /// <returns>Single selected factory or null if unable to select.</returns>
    public delegate Factory FactorySelectorRule(Request request, Factory singleDefaultFactory, KV<object, Factory>[] orManyDefaultAndKeyedFactories);

    /// <summary>Rules to select single matched factory default and keyed registered factory/factories.
    /// Selectors applied in specified array order, until first returns not null <see cref="Factory"/>.
    /// Default behavior is to throw on multiple registered default factories, cause it is not obvious what to use.</summary>
    public FactorySelectorRule FactorySelector { get; private set; }

    /// <summary>Sets <see cref="FactorySelector"/></summary>
    public Rules WithFactorySelector(FactorySelectorRule rule)
    {
        var rules = Clone();
        rules.FactorySelector = rule;
        rules._settings = rule == SelectLastRegisteredFactory
            ? (_settings | Settings.SelectLastRegisteredFactory)
            : (_settings & ~Settings.SelectLastRegisteredFactory);
        return rules;
    }

    /// <summary>Select last registered factory from the multiple default.</summary>
    public static FactorySelectorRule SelectLastRegisteredFactory() => SelectLastRegisteredFactory;
    private static Factory SelectLastRegisteredFactory(Request request, Factory singleDefaultFactory, KV<object, Factory>[] orManyDefaultAndKeyedFactories)
    {
        var serviceKey = request.ServiceKey;
        if (singleDefaultFactory != null)
            return serviceKey == null ? singleDefaultFactory : null;

        for (var i = orManyDefaultAndKeyedFactories.Length - 1; i >= 0; --i)
        {
            var factory = orManyDefaultAndKeyedFactories[i];
            var facKey = factory.Key;
            if (facKey.Equals(serviceKey))
                return factory.Value;
        }
        return null;
    }

    /// <summary>A commonly used rule, the flag is for optimization</summary>
    public bool IsSelectLastRegisteredFactory => (_settings & Settings.SelectLastRegisteredFactory) != 0;

    /// <summary>Tries to select a single factory based on the minimal reuse life-span ignoring the Transients</summary>
    public static FactorySelectorRule SelectFactoryWithTheMinReuseLifespan() => SelectLastRegisteredFactory;

    /// <summary>Tries either SelectFactoryWithTheMinReuseLifespan or SelectLastRegisteredFactory</summary>
    public static FactorySelectorRule SelectFactoryWithTheMinReuseLifespanOrLastRegistered() => (request, factory, factories) =>
        SelectFactoryWithTheMinReuseLifespan(request, factory, factories) ??
        SelectLastRegisteredFactory(request, factory, factories);

    /// <summary>Prefer specified service key (if found) over default key.
    /// Help to override default registrations in Open Scope scenarios:
    /// I may register service with key and resolve it as default in current scope.</summary>
    public static FactorySelectorRule SelectKeyedOverDefaultFactory(object serviceKey) =>
        (r, singleFac, keyedFacs) => singleFac // select a single default factory if it is the only one registered
            ?? keyedFacs.FindFirst(serviceKey, static (key, f) => key.MatchToNotNullRegisteredKey(f.Key))?.Value // or try to find the factory with equal key
            ?? keyedFacs.FindFirst(static f => f.Key == null || f.Key.Equals(null))?.Value;  // or try to find the factory with null/default key

    private static Factory SelectFactoryWithTheMinReuseLifespan(Request request, Factory singleDefaultFactory, KV<object, Factory>[] orManyDefaultAndKeyedFactories)
    {
        if (singleDefaultFactory != null)
            return singleDefaultFactory;

        var minLifespan = int.MaxValue;
        var multipleFactories = false;
        Factory minLifespanFactory = null;

        foreach (var factory in orManyDefaultAndKeyedFactories)
        {
            var reuse = factory.Value.Reuse;
            var lifespan = reuse == null | reuse == Reuse.Transient ? int.MaxValue : reuse.Lifespan;
            if (lifespan == minLifespan)
                multipleFactories = true;
            else if (lifespan < minLifespan)
            {
                minLifespan = lifespan;
                minLifespanFactory = factory.Value;
                multipleFactories = false;
            }
        }

        return !multipleFactories & minLifespanFactory != null ? minLifespanFactory : null;
    }

    /// <summary>Specify the method signature for returning multiple keyed factories.
    /// This is dynamic analog to the normal Container Registry.</summary>
    /// <param name="serviceType">Requested service type.</param>
    /// <param name="serviceKey">(optional) If <c>null</c> will request all factories of <paramref name="serviceType"/></param>
    /// <returns>Key-Factory pairs.</returns>
    public delegate IEnumerable<DynamicRegistration> DynamicRegistrationProvider(Type serviceType, object serviceKey);

    /// <summary>Providers for resolving multiple not-registered services. Null by default.</summary>
    public DynamicRegistrationProvider[] DynamicRegistrationProviders { get; private set; }

    /// <summary>Get the specific providers with the specified flags and without the flags or return `null` if nothing found</summary>
    public bool HasDynamicRegistrationProvider(DynamicRegistrationFlags withFlags,
        DynamicRegistrationFlags withoutFlags = DryIoc.DynamicRegistrationFlags.NoFlags)
    {
        var allFlags = DynamicRegistrationFlags;
        if (allFlags == null | allFlags.Length == 0)
            return false;

        for (var i = 0; i < allFlags.Length; ++i)
        {
            var f = allFlags[i];
            if ((f & withFlags) == withFlags & (f & withoutFlags) == 0)
                return true;
        }

        return false;
    }

    /// <summary>Returns the new rules with the passed dynamic registration rule appended.</summary>
    public Rules WithDynamicRegistration(DynamicRegistrationProvider provider,
        DynamicRegistrationFlags flags = DryIoc.DynamicRegistrationFlags.Service)
    {
        var newRules = Clone(cloneMade: false);
        newRules.DynamicRegistrationProviders = DynamicRegistrationProviders.Append(provider);
        newRules.DynamicRegistrationFlags = DynamicRegistrationFlags.Append(flags);
        return newRules;
    }

    /// <summary>Removes the dynamic registration provider</summary>
    public Rules WithoutDynamicRegistration(DynamicRegistrationProvider provider)
    {
        var ruleIndex = DynamicRegistrationProviders.IndexOf(provider);
        if (ruleIndex != -1)
        {
            var newRules = Clone(cloneMade: false);
            newRules.DynamicRegistrationProviders = DynamicRegistrationProviders.RemoveAt(ruleIndex);
            newRules.DynamicRegistrationFlags = DynamicRegistrationFlags.RemoveAt(ruleIndex);
            return newRules;
        }
        return this;
    }

    /// <summary>Returns a single dynamic registration made out of factory</summary>
    public static DynamicRegistrationProvider DynamicRegistrationOf(Func<Type, Factory> getFactoryOrNull) =>
        (serviceType, _) =>
        {
            var f = getFactoryOrNull(serviceType);
            return f == null ? null : new DynamicRegistration(f).One();
        };

    /// <summary>Add as single dynamic registration provider to the rules</summary>
    public Rules WithDynamicRegistration(Func<Type, Factory> getFactoryOrNull) =>
        WithDynamicRegistration(DynamicRegistrationOf(getFactoryOrNull));

    /// <summary>The flags per dynamic registration provider</summary>
    public DynamicRegistrationFlags[] DynamicRegistrationFlags { get; private set; }

    /// <summary>Returns the new rules with the passed dynamic registration rules appended.</summary>
    public Rules WithDynamicRegistrations(params DynamicRegistrationProvider[] rules) =>
        WithDynamicRegistrations(DefaultDynamicRegistrationFlags, rules);

    /// <summary>Only services and no decorators as it will greatly affect the performance, 
    /// calling the provider for every resolved service</summary>
    public static readonly DynamicRegistrationFlags DefaultDynamicRegistrationFlags = DryIoc.DynamicRegistrationFlags.Service;

    /// <summary>Returns the new rules with the passed dynamic registration rules appended. 
    /// The rules applied only when no normal registrations found!</summary>
    public Rules WithDynamicRegistrationsAsFallback(params DynamicRegistrationProvider[] rules) =>
        WithDynamicRegistrations(DefaultDynamicRegistrationFlags | DryIoc.DynamicRegistrationFlags.AsFallback, rules);

    /// <summary>Returns the new rules with the passed dynamic registration rules appended. 
    /// The rules applied only when no normal registrations found!</summary>
    public Rules WithDynamicRegistrations(DynamicRegistrationFlags flags, params DynamicRegistrationProvider[] rules)
    {
        var newRules = Clone();
        newRules.DynamicRegistrationProviders = DynamicRegistrationProviders.Append(rules);
        newRules.DynamicRegistrationFlags = WithDynamicRegistrationProviderFlags(rules?.Length ?? 0, flags);
        return newRules;
    }

    private DynamicRegistrationFlags[] WithDynamicRegistrationProviderFlags(int count, DynamicRegistrationFlags flags)
    {
        if (count == 0)
            return DynamicRegistrationFlags;

        if (count == 1)
            return DynamicRegistrationFlags.Append(flags);

        var newFlags = new DynamicRegistrationFlags[count];
        for (var i = 0; i < newFlags.Length; i++)
            newFlags[i] = flags;
        return DynamicRegistrationFlags.Append(newFlags);
    }

    /// <summary>Returns the new rules with the passed dynamic registration rules appended. 
    /// The rules applied only when no normal registrations found!</summary>
    public Rules WithDynamicRegistrationsAsFallback(DynamicRegistrationFlags flags, params DynamicRegistrationProvider[] rules) =>
        WithDynamicRegistrations(flags | DryIoc.DynamicRegistrationFlags.AsFallback, rules);

    /// <summary>Defines delegate to return factory for request not resolved by registered factories or prior rules.
    /// Applied in specified array order until return not null <see cref="Factory"/>.</summary>
    public delegate Factory UnknownServiceResolver(Request request);

    /// <summary>Gets rules for resolving not-registered services. Null by default.</summary>
    public UnknownServiceResolver[] UnknownServiceResolvers { get; private set; }

    /// <summary>Appends resolver to current unknown service resolvers.</summary>
    public Rules WithUnknownServiceResolvers(params UnknownServiceResolver[] rules)
    {
        var newRules = Clone();
        newRules.UnknownServiceResolvers = UnknownServiceResolvers.Append(rules);
        return newRules;
    }

    /// <summary>Removes specified resolver from unknown service resolvers, and returns new Rules.
    /// If no resolver was found then <see cref="UnknownServiceResolvers"/> will stay the same instance,
    /// so it could be check for remove success or fail.</summary>
    public Rules WithoutUnknownServiceResolver(UnknownServiceResolver rule)
    {
        var newRules = Clone();
        newRules.UnknownServiceResolvers = UnknownServiceResolvers.Remove(rule);
        return newRules;
    }

    /// <summary>Sugar on top of <see cref="WithUnknownServiceResolvers"/> to simplify setting the diagnostic action.
    /// Does not guard you from action throwing an exception. Actually can be used to throw your custom exception
    /// instead of <see cref="ContainerException"/>.</summary>
    public Rules WithUnknownServiceHandler(Action<Request> handler) =>
        WithUnknownServiceResolvers(request =>
        {
            handler(request);
            return null;
        });

    /// <summary>The alternative is ConcreteTypeDynamicRegistrations</summary>
    public static UnknownServiceResolver AutoResolveConcreteTypeRule(Func<Request, bool> condition = null) =>
        request =>
        {
            var concreteType = request.ActualServiceType;
            if (!concreteType.IsImplementationType() || concreteType.IsPrimitive() ||
                condition != null && !condition(request))
                return null;

            var openGenericServiceType = concreteType.GetGenericDefinitionOrNull();
            if (openGenericServiceType != null && WrappersSupport.Wrappers.GetValueOrDefault(openGenericServiceType) != null)
                return null;

            var factory = ReflectionFactory.Of(concreteType,
                made: DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublicWithoutSameTypeParam);

            // to enable fallback to other rules if unresolved try to resolve expression first and return null
            return factory.GetExpressionOrDefault(request.WithIfUnresolved(IfUnresolved.ReturnDefault)) != null ? factory : null;
        };

    // exclude concrete service types which are pre-defined DryIoc wrapper types
    private static IEnumerable<Type> GetConcreteServiceType(Type serviceType, object serviceKey) =>
        serviceType.IsAbstract || serviceType.IsOpenGeneric() ||
        serviceType.IsGenericType && WrappersSupport.Wrappers.GetValueOrDefault(serviceType.GetGenericTypeDefinition()) != null
        ? null : serviceType.One(); // use concrete service type as implementation type

    // exclude concrete service types which are pre-defined DryIoc wrapper types
    private static IEnumerable<Type> GetConcreteServiceType(Type serviceType, object serviceKey, Func<Type, object, bool> serviceCondition) =>
        serviceType.IsAbstract || serviceType.IsOpenGeneric() ||
        !serviceCondition(serviceType, serviceKey) ||
        serviceType.IsGenericType && WrappersSupport.Wrappers.GetValueOrDefault(serviceType.GetGenericTypeDefinition()) != null
        ? null : serviceType.One(); // use concrete service type as implementation type

    // by default the condition checks that factory is resolvable down to dependencies
    private static Factory GetConcreteTypeFactory(Type implType, IReuse reuse = null, IfUnresolved ifConcreteTypeIsUnresolved = IfUnresolved.Throw)
    {
        if (ifConcreteTypeIsUnresolved == IfUnresolved.Throw)
            return ReflectionFactory.Of(implType, reuse, DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublicWithoutSameTypeParam);
        ReflectionFactory factory = null;
        factory = ReflectionFactory.Of(implType, reuse,
            DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublicWithoutSameTypeParam,
            Setup.With(condition: req => factory?.GetExpressionOrDefault(req.WithIfUnresolved(ifConcreteTypeIsUnresolved)) != null));
        return factory;
    }

    /// <summary>Rule to automatically resolves non-registered service type which is: nor interface, nor abstract, nor registered wrapper type.
    /// For constructor selection we are using automatic constructor selection.</summary>
    /// <param name="condition">(optional) Condition for requested service type and key.</param>
    /// <param name="reuse">(optional) Reuse for concrete types.</param>
    /// <returns>New rule.</returns>
    public static DynamicRegistrationProvider ConcreteTypeDynamicRegistrations(
        Func<Type, object, bool> condition = null, IReuse reuse = null) =>
        AutoFallbackDynamicRegistrations(condition == null
            ? (Func<Type, object, IEnumerable<Type>>)((serviceType, serviceKey) => GetConcreteServiceType(serviceType, serviceKey))
            : (Func<Type, object, IEnumerable<Type>>)((serviceType, serviceKey) => GetConcreteServiceType(serviceType, serviceKey, condition)),
        implType => GetConcreteTypeFactory(implType, reuse, IfUnresolved.ReturnDefault));

    /// <summary>Rule to automatically resolves non-registered service type which is: nor interface, nor abstract, nor registered wrapper type.
    /// For constructor selection we are using automatic constructor selection.
    /// Pass `IfUnresolved.ReturnDefault` or `IfUnresolved.ReturnDefaultIfNotRegistered` to `ifConcreteTypeIsUnresolved` 
    /// to allow fallback to the next rule.</summary>
    public static DynamicRegistrationProvider ConcreteTypeDynamicRegistrations(
        IfUnresolved ifConcreteTypeIsUnresolved,
        Func<Type, object, bool> serviceCondition = null, IReuse reuse = null) =>
        AutoFallbackDynamicRegistrations(serviceCondition == null
            ? (Func<Type, object, IEnumerable<Type>>)((serviceType, serviceKey) => GetConcreteServiceType(serviceType, serviceKey))
            : (Func<Type, object, IEnumerable<Type>>)((serviceType, serviceKey) => GetConcreteServiceType(serviceType, serviceKey, serviceCondition)),
        implType => GetConcreteTypeFactory(implType, reuse, ifConcreteTypeIsUnresolved));

    /// <summary>Automatically resolves non-registered service type which is: nor interface, nor abstract.</summary>
    public Rules WithConcreteTypeDynamicRegistrations(Func<Type, object, bool> condition = null, IReuse reuse = null) =>
        WithDynamicRegistrationsAsFallback(ConcreteTypeDynamicRegistrations(condition, reuse));

    /// <summary>Automatically resolves non-registered service type which is: nor interface, nor abstract.
    /// Pass `IfUnresolved.ReturnDefault` or `IfUnresolved.ReturnDefaultIfNotRegistered` to `ifConcreteTypeIsUnresolved` 
    /// to allow fallback to the next rule.</summary>
    public Rules WithConcreteTypeDynamicRegistrations(IfUnresolved ifConcreteTypeIsUnresolved, Func<Type, object, bool> condition = null, IReuse reuse = null) =>
        WithDynamicRegistrationsAsFallback(ConcreteTypeDynamicRegistrations(ifConcreteTypeIsUnresolved, condition, reuse));

    /// [Obsolete("Replaced with `WithConcreteTypeDynamicRegistrations`")]
    public Rules WithAutoConcreteTypeResolution(Func<Request, bool> condition = null)
    {
        var newRules = Clone();
        newRules._settings = _settings | Settings.AutoConcreteTypeResolution;
        newRules.UnknownServiceResolvers = UnknownServiceResolvers.Append(AutoResolveConcreteTypeRule(condition));
        return newRules;
    }

    /// <summary>Creates dynamic fallback registrations for the requested service type
    /// with provided <paramref name="getImplementationTypes"/>.
    /// Fallback means that the dynamic registrations will be applied Only if no normal registrations
    /// exist for the requested service type, hence the "fallback".</summary>
    /// <param name="getImplementationTypes">Implementation types to select for service.</param>
    /// <param name="factory">(optional) Handler to customize the factory, e.g.
    /// specify reuse or setup. Handler should not return <c>null</c>.</param>
    /// <returns>Registration provider.</returns>
    public static DynamicRegistrationProvider AutoFallbackDynamicRegistrations(
        Func<Type, object, IEnumerable<Type>> getImplementationTypes,
        Func<Type, Factory> factory = null)
    {
        // cache factory for the implementation type! to cut on the number of dynamic lookups
        var factories = Ref.Of(ImHashMap<Type, Factory>.Empty);

        return (serviceType, serviceKey) =>
        {
            if (!serviceType.IsServiceType())
                return Enumerable.Empty<DynamicRegistration>();

            var implementationTypes = getImplementationTypes(serviceType, serviceKey);

            return implementationTypes.Match(factories, serviceType,
                static (fsRef, st, implType) => implType.IsImplementingServiceType(st),
                (fsRef, _, implType) =>
                {
                    var implTypeHash = RuntimeHelpers.GetHashCode(implType);
                    var implFactory = fsRef.Value.GetValueOrDefault(implTypeHash, implType);
                    if (implFactory == null)
                    {
                        if (factory == null)
                            fsRef.Swap(implType, implTypeHash,
                                (fs, it, ith) => (implFactory = fs.GetValueOrDefault(ith, it)) != null
                                    ? fs
                                    : fs.AddOrUpdate(ith, it, implFactory = ReflectionFactory.Of(it)));
                        else
                            fsRef.Swap(implType, implTypeHash,
                                (fs, it, ith) => (implFactory = fs.GetValueOrDefault(ith, it)) != null
                                    ? fs
                                    : fs.AddOrUpdate(ith, it, implFactory = factory.Invoke(it).ThrowIfNull()));
                    }

                    // We nullify default keys (usually passed by ResolveMany to resolve the specific factory in order)
                    // so that `CombineRegisteredWithDynamicFactories` may assign the key again.
                    // Given that the implementation types are unchanged then the new keys assignment will be the same the last one,
                    // so that the factory resolution will correctly match the required factory by key.
                    // e.g. bitbucket issue #396
                    return new DynamicRegistration(implFactory, IfAlreadyRegistered.Keep, serviceKey is DefaultDynamicKey ? null : serviceKey);
                });
        };
    }

    /// <summary>See <see cref="WithDefaultReuse"/></summary>
    public IReuse DefaultReuse { get; private set; }

    /// <summary>The reuse used in case if reuse is unspecified (null) in Register methods.</summary>
    public Rules WithDefaultReuse(IReuse reuse)
    {
        if (reuse == DefaultReuse)
            return this;
        var newRules = Clone();
        newRules.DefaultReuse = reuse ?? Reuse.Transient;
        return newRules;
    }

    /// <summary>Given item object and its type should return item "pure" expression presentation,
    /// without side-effects or external dependencies.
    /// e.g. for string "blah" <code lang="cs"><![CDATA[]]>Expression.Constant("blah", typeof(string))</code>.
    /// If unable to convert should return null.</summary>
    public delegate Expression ItemToExpressionConverterRule(object item, Type itemType);

    /// <summary><see cref="WithItemToExpressionConverter"/>.</summary>
    public ItemToExpressionConverterRule ItemToExpressionConverter { get; private set; }

    /// <summary>Specifies custom rule to convert non-primitive items to their expression representation.
    /// That may be required because DryIoc by default does not support non-primitive service keys and registration metadata.
    /// To enable non-primitive values support DryIoc need a way to recreate them as expression tree.</summary>
    public Rules WithItemToExpressionConverter(ItemToExpressionConverterRule itemToExpressionOrDefault)
    {
        var newRules = Clone();
        newRules.ItemToExpressionConverter = itemToExpressionOrDefault;
        return newRules;
    }

    /// <summary><see cref="WithoutThrowIfDependencyHasShorterReuseLifespan"/>.</summary>
    public bool ThrowIfDependencyHasShorterReuseLifespan =>
        (_settings & Settings.ThrowIfDependencyHasShorterReuseLifespan) != 0;

    /// <summary>Turns off throwing exception when dependency has shorter reuse lifespan than its parent or ancestor.</summary>
    /// <returns>New rules with new setting value.</returns>
    public Rules WithoutThrowIfDependencyHasShorterReuseLifespan() =>
        WithSettings(_settings & ~Settings.ThrowIfDependencyHasShorterReuseLifespan);

    /// <summary><see cref="WithThrowIfScopedOrSingletonHasTransientDependency"/>.</summary>
    public bool ThrowIfScopedOrSingletonHasTransientDependency =>
        (_settings & Settings.ThrowIfScopedOrSingletonHasTransientDependency) != 0;

    /// <summary>Turns On throwing the exception when Singleton or Scope service has a Transient dependency</summary>
    public Rules WithThrowIfScopedOrSingletonHasTransientDependency() =>
        WithSettings(_settings | Settings.ThrowIfScopedOrSingletonHasTransientDependency);

    /// <summary>Turns Off throwing the exception when Singleton or Scope service has a Transient dependency (the default)</summary>
    public Rules WithoutThrowIfScopedOrSingletonHasTransientDependency() =>
        WithSettings(_settings & ~Settings.ThrowIfScopedOrSingletonHasTransientDependency);

    /// <summary><see cref="WithoutThrowOnRegisteringDisposableTransient"/></summary>
    public bool ThrowOnRegisteringDisposableTransient =>
        (_settings & Settings.ThrowOnRegisteringDisposableTransient) != 0;

    /// <summary>Turns Off the rule <see cref="ThrowOnRegisteringDisposableTransient"/>.
    /// Allows to register disposable transient but it is up to you to handle their disposal.
    /// You can use <see cref="WithTrackingDisposableTransients"/> to actually track disposable transient in
    /// container, so that disposal will be handled by container.</summary>
    public Rules WithoutThrowOnRegisteringDisposableTransient() =>
        WithSettings(_settings & ~Settings.ThrowOnRegisteringDisposableTransient);

    /// <summary><see cref="WithTrackingDisposableTransients"/></summary>
    public bool TrackingDisposableTransients =>
        (_settings & Settings.TrackingDisposableTransients) != 0;

    /// <summary>
    /// Turns on the storing of disposable transients in the current scope or in the singleton scope if no scopes are opened.
    /// It is required to be able to Dispose the Transient at specific time when the scope is disposed or where container
    /// with singletons is disposed.
    ///
    /// The storing disposable transients in the singleton scope means that they won't be disposed until
    /// the whole container is disposed. That may pose a problem similar to the "memory leak" because more and more transients
    /// will be created and stored never disposed until whole container is disposed. Therefore you 
    /// need to think if you really need the disposable to be the Transient. Whatever, just be aware of it.
    /// </summary>
    public Rules WithTrackingDisposableTransients() =>
        WithSettings((_settings | Settings.TrackingDisposableTransients) & ~Settings.ThrowOnRegisteringDisposableTransient);

    /// <summary><see cref="WithoutEagerCachingSingletonForFasterAccess"/>.</summary>
    public bool EagerCachingSingletonForFasterAccess =>
        (_settings & Settings.EagerCachingSingletonForFasterAccess) != 0;

    /// <summary>
    /// The opposite of <see cref="WithTrackingDisposableTransients" /> removing the tracking, 
    /// which maybe helpful e.g. for undoing the rule from the Microsoft.DependencyInjection conforming rules.
    /// </summary>
    public Rules WithoutTrackingDisposableTransients() =>
        WithSettings(_settings & ~Settings.TrackingDisposableTransients);

    /// <summary>Turns off optimization: creating singletons during resolution of object graph.</summary>
    public Rules WithoutEagerCachingSingletonForFasterAccess() =>
        WithSettings(_settings & ~Settings.EagerCachingSingletonForFasterAccess);

    /// <summary><see cref="WithExpressionGeneration"/>.</summary>
    public Ref<ImHashMap<Request, Expression>> DependencyResolutionCallExprs { get; private set; }

    /// <summary>Indicates that container is used for generation purposes, so it should use less runtime state</summary>
    public bool UsedForExpressionGeneration => (_settings & Settings.UsedForExpressionGeneration) != 0;

    private Settings GetSettingsForExpressionGeneration(bool allowRuntimeState = false) =>
        _settings & ~Settings.EagerCachingSingletonForFasterAccess
                    & ~Settings.ImplicitCheckForReuseMatchingScope
                    & ~Settings.UseInterpretationForTheFirstResolution
                    & ~Settings.UseInterpretation
                    | Settings.GenerateResolutionCallForMissingDependency
                    | Settings.UsedForExpressionGeneration
                    | (allowRuntimeState ? 0 : Settings.ThrowIfRuntimeStateRequired);

    /// <summary>Specifies to generate ResolutionCall dependency creation expression and stores the result 
    /// in the-per rules collection.</summary>
    public Rules WithExpressionGeneration(bool allowRuntimeState = false)
    {
        var newRules = Clone();
        newRules._settings = GetSettingsForExpressionGeneration(allowRuntimeState);
        newRules.DependencyResolutionCallExprs = Ref.Of(ImHashMap<Request, Expression>.Empty);
        return newRules;
    }

    /// <summary>Removes runtime optimizations preventing an expression generation.</summary>
    public Rules WithExpressionGenerationSettingsOnly(bool allowRuntimeState = false) =>
        WithSettings(GetSettingsForExpressionGeneration(allowRuntimeState));

    /// <summary>Indicates that rules are used for the validation, e.g. the rules created in `Validate` method</summary>
    public bool UsedForValidation => (_settings & Settings.UsedForValidation) != 0;

    private Settings GetSettingsForValidation() =>
        _settings & ~Settings.EagerCachingSingletonForFasterAccess
                    & ~Settings.ImplicitCheckForReuseMatchingScope
                    | Settings.UsedForValidation;

    /// <summary>Set all the settings and rules required for the Validating container.</summary>
    public Rules ForValidate()
    {
        var newRules = Clone();
        newRules._settings = GetSettingsForValidation();
        newRules.DependencyCountInLambdaToSplitBigObjectGraph = int.MaxValue;
        newRules.DependencyResolutionCallExprs = null;
        return newRules;
    }

    /// <summary>The Rule filters out the factory without matching scope.</summary>
    public bool ImplicitCheckForReuseMatchingScope =>
        (_settings & Settings.ImplicitCheckForReuseMatchingScope) != 0;

    /// <summary>Removes <see cref="ImplicitCheckForReuseMatchingScope"/> rule and returns the new rules.</summary>
    public Rules WithoutImplicitCheckForReuseMatchingScope() =>
        WithSettings(_settings & ~Settings.ImplicitCheckForReuseMatchingScope);

    /// <summary><see cref="WithResolveIEnumerableAsLazyEnumerable"/>.</summary>
    public bool ResolveIEnumerableAsLazyEnumerable =>
        (_settings & Settings.ResolveIEnumerableAsLazyEnumerable) != 0;

    /// <summary>Specifies to resolve IEnumerable as LazyEnumerable.</summary>
    public Rules WithResolveIEnumerableAsLazyEnumerable() =>
        WithSettings(_settings | Settings.ResolveIEnumerableAsLazyEnumerable);

    /// <summary><see cref="WithVariantGenericTypesInResolvedCollection"/>.</summary>
    public bool VariantGenericTypesInResolvedCollection =>
        (_settings & Settings.VariantGenericTypesInResolvedCollection) != 0;

    /// <summary>Flag instructs to include covariant compatible types into the resolved collection.</summary>
    public Rules WithVariantGenericTypesInResolvedCollection() =>
        WithSettings(_settings | Settings.VariantGenericTypesInResolvedCollection);

    /// <summary>Flag instructs to exclude covariant compatible types into the resolved collection.</summary>
    public Rules WithoutVariantGenericTypesInResolvedCollection() =>
        WithSettings(_settings & ~Settings.VariantGenericTypesInResolvedCollection);

    /// <summary><see cref="WithVariantGenericTypesInResolve"/>.</summary>
    public bool VariantGenericTypesInResolve =>
        (_settings & Settings.VariantGenericTypesInResolve) != 0;

    /// <summary>Flag instructs to include covariant compatible types into the resolved generic.</summary>
    public Rules WithVariantGenericTypesInResolve() =>
        WithSettings(_settings | Settings.VariantGenericTypesInResolve);

    /// <summary>Flag instructs to exclude covariant compatible types into the resolved generic.</summary>
    public Rules WithoutVariantGenericTypesInResolve() =>
        WithSettings(_settings & ~Settings.VariantGenericTypesInResolve);

    /// <summary>Says if there a support the multiple same service keys for the same service type. 
    /// Note, that this setting will work even with <seealso cref="IfAlreadyRegistered.AppendNotKeyed"/>.</summary>
    public bool HasMultipleSameServiceKeyForTheServiceType =>
        _serviceKeyToTypeIndex != null;

    /// <summary>Adding support for the multiple same keys for the same type.
    /// It is not sensible to remove this setting, because the registry will be populated with the wrapped keys.</summary>
    public Rules WithMultipleSameServiceKeyForTheServiceType()
    {
        if (_serviceKeyToTypeIndex != null)
            return this;
        var newRules = Clone();
        newRules._serviceKeyToTypeIndex = ImHashMap<object, object>.Empty;
        return newRules;
    }

    /// <summary>If the dependency factory is not found (including the dynamic factories) generate the `Resolve` call for it, 
    /// so it may be resolved from the compile-time registrations</summary>
    public bool GenerateResolutionCallForMissingDependency =>
        (_settings & Settings.GenerateResolutionCallForMissingDependency) != 0;

    /// <summary>Sets the <see cref="GenerateResolutionCallForMissingDependency"/></summary>
    public Rules WithGenerateResolutionCallForMissingDependency() =>
        WithSettings(_settings | Settings.GenerateResolutionCallForMissingDependency);

    /// <summary>Un-sets the <see ref="GenerateResolutionCallForMissingDependency"/></summary>
    public Rules WithoutGenerateResolutionCallForMissingDependency() =>
        WithSettings(_settings & ~Settings.GenerateResolutionCallForMissingDependency);

    /// <summary><see cref="WithDefaultIfAlreadyRegistered"/>.</summary>
    public IfAlreadyRegistered DefaultIfAlreadyRegistered { get; private set; }

    /// <summary>Specifies default setting for container. By default is <see cref="IfAlreadyRegistered.AppendNotKeyed"/>.
    /// Example of use: specify Keep as a container default, then set AppendNonKeyed for explicit collection registrations.</summary>
    public Rules WithDefaultIfAlreadyRegistered(IfAlreadyRegistered rule)
    {
        if (rule == DefaultIfAlreadyRegistered)
            return this;
        var newRules = Clone();
        newRules.DefaultIfAlreadyRegistered = rule;
        return newRules;
    }

    /// <summary><see cref="WithThrowIfRuntimeStateRequired"/>.</summary>
    public bool ThrowIfRuntimeStateRequired =>
        (_settings & Settings.ThrowIfRuntimeStateRequired) != 0;

    /// <summary>The thing.</summary>
    public bool ConstantExpressionIsFine =>
        (_settings & (Settings.ThrowIfRuntimeStateRequired | Settings.UsedForExpressionGeneration)) == 0;

    /// <summary>Specifies to throw an exception in attempt to resolve service which require runtime state for resolution.
    /// Runtime state may be introduced by RegisterDelegate, RegisterInstance, or registering with non-primitive service key, or metadata.</summary>
    public Rules WithThrowIfRuntimeStateRequired() =>
        WithSettings(_settings | Settings.ThrowIfRuntimeStateRequired);

    /// <summary><see cref="WithCaptureContainerDisposeStackTrace"/>.</summary>
    public bool CaptureContainerDisposeStackTrace =>
        (_settings & Settings.CaptureContainerDisposeStackTrace) != 0;

    /// <summary>Instructs to capture Dispose stack-trace to include it later into <see cref="Error.ContainerIsDisposed"/>
    /// exception for easy diagnostics.</summary>
    public Rules WithCaptureContainerDisposeStackTrace() =>
        WithSettings(_settings | Settings.CaptureContainerDisposeStackTrace);

    /// <summary>Allows Func with args specify its own reuse (sharing) behavior.</summary>
    public bool IgnoringReuseForFuncWithArgs =>
        (_settings & Settings.IgnoringReuseForFuncWithArgs) != 0;

    /// <summary>Allows Func with args specify its own reuse (sharing) behavior.</summary>
    public Rules WithIgnoringReuseForFuncWithArgs() =>
        WithSettings(_settings | Settings.IgnoringReuseForFuncWithArgs);

    /// <summary>Allows Func of service to be resolved even without registered service.</summary>
    public bool FuncAndLazyWithoutRegistration =>
        (_settings & Settings.FuncAndLazyWithoutRegistration) != 0;

    /// <summary>Allows Func of service to be resolved even without registered service.</summary>
    public Rules WithFuncAndLazyWithoutRegistration() =>
        WithSettings(_settings | Settings.FuncAndLazyWithoutRegistration);

    /// <summary>Removes the rule `FuncAndLazyWithoutRegistration`.</summary>
    public Rules WithoutFuncAndLazyWithoutRegistration() =>
        WithSettings(_settings & ~Settings.FuncAndLazyWithoutRegistration);

    /// Subject-subject
    public bool UseInterpretationForTheFirstResolution =>
        (_settings & Settings.UseInterpretationForTheFirstResolution) != 0;

    ///<summary>Compile service expression on the first resolution. 
    /// By default the first resolution is interpreted to avoid time spend on the compilation process 
    /// (especially in case if you have only one resolution for the application lifetime).
    /// If you need more resolutions then it make sense to compile to trade for the faster resolution times.
    /// Note: un-setting this effectively means the same as `WithoutUseInterpretation`, 
    /// otherwise it would be strange to compile the first resolution but then throw it away and start interpreting the rest.</summary>
    public Rules WithoutInterpretationForTheFirstResolution() => WithoutUseInterpretation();

    /// Subject
    public bool UseInterpretation =>
        (_settings & Settings.UseInterpretation) != 0;

    /// <summary>Uses DryIoc own interpretation mechanism or is falling back to `Compile(preferInterpretation: true)`.</summary>
    public Rules WithUseInterpretation() =>
        WithSettings(_settings | Settings.UseInterpretationForTheFirstResolution | Settings.UseInterpretation);

    /// <summary>Un-setting this thing means that DryIoc will always use Compilation, even in the first resolution cycle, 
    /// so it means as well the `WithoutInterpretationForTheFirstResolution`.</summary>
    public Rules WithoutUseInterpretation() =>
        WithSettings(_settings & ~Settings.UseInterpretationForTheFirstResolution & ~Settings.UseInterpretation);

    /// <summary>If Decorator reuse is not set instructs to use `Decorator.SetupWith(useDecorateeReuse: true)`</summary>
    public bool UseDecorateeReuseForDecorators =>
        (_settings & Settings.UseDecorateeReuseForDecorators) != 0;

    /// <summary>If Decorator reuse is not set instructs to use `Decorator.SetupWith(useDecorateeReuse: true)`</summary>
    public Rules WithUseDecorateeReuseForDecorators() =>
        WithSettings(_settings | Settings.UseDecorateeReuseForDecorators);

    /// Outputs most notable non-default rules
    public override string ToString()
    {
        if (this == Default)
            return "Rules.Default";

        string s = "";
        if (_settings != DEFAULT_SETTINGS)
        {
            var addedSettings = _settings & ~DEFAULT_SETTINGS;
            if (addedSettings != 0)
                s = "Rules with {" + addedSettings + "}";
            var removedSettings = DEFAULT_SETTINGS & ~_settings;
            if (removedSettings != 0)
                s += (s != "" ? " and without {" : "Rules without {") + removedSettings + "}";
        }

        if (DependencyCountInLambdaToSplitBigObjectGraph != DefaultDependencyCountInLambdaToSplitBigObjectGraph)
            s += " with DependencyCountInLambdaToSplitBigObjectGraph=" + DependencyCountInLambdaToSplitBigObjectGraph;

        if (DefaultReuse != null && DefaultReuse != Reuse.Transient)
            s += (s != "" ? NewLine : "Rules ") + " with DefaultReuse=" + DefaultReuse;

        if (FactorySelector != null)
        {
            s += (s != "" ? NewLine : "Rules ") + " with FactorySelector=";
            if (FactorySelector == SelectLastRegisteredFactory)
                s += nameof(Rules.SelectLastRegisteredFactory);
            else
                s += "<custom>";
        }

        if (_made != Made.Default)
            s += (s != "" ? NewLine : "Rules ") + " with Made=" + _made;

        return s;
    }

    private Rules()
    {
        _made = Made.Default;
        _settings = DEFAULT_SETTINGS;
        DefaultReuse = Reuse.Transient;
        DefaultIfAlreadyRegistered = IfAlreadyRegistered.AppendNotKeyed;
        DependencyCountInLambdaToSplitBigObjectGraph = DefaultDependencyCountInLambdaToSplitBigObjectGraph;
    }

    private Rules(Settings settings,
        FactorySelectorRule factorySelector,
        IReuse defaultReuse,
        Made made,
        IfAlreadyRegistered defaultIfAlreadyRegistered,
        int dependencyCountInLambdaToSplitBigObjectGraph,
        Ref<ImHashMap<Request, Expression>> dependencyResolutionCallExprs,
        ItemToExpressionConverterRule itemToExpressionConverter,
        DynamicRegistrationProvider[] dynamicRegistrationProviders, DynamicRegistrationFlags[] dynamicRegistrationProvidersFlags,
        UnknownServiceResolver[] unknownServiceResolvers,
        object defaultRegistrationServiceKey,
        ImHashMap<object, object> serviceKeyToTypeIndex)
    {
        _settings = settings;
        _made = made;
        FactorySelector = factorySelector;
        DefaultReuse = defaultReuse;
        DefaultIfAlreadyRegistered = defaultIfAlreadyRegistered;
        DependencyCountInLambdaToSplitBigObjectGraph = dependencyCountInLambdaToSplitBigObjectGraph;
        DependencyResolutionCallExprs = dependencyResolutionCallExprs;
        ItemToExpressionConverter = itemToExpressionConverter;
        DynamicRegistrationProviders = dynamicRegistrationProviders;
        DynamicRegistrationFlags = dynamicRegistrationProvidersFlags;
        UnknownServiceResolvers = unknownServiceResolvers;
        DefaultRegistrationServiceKey = defaultRegistrationServiceKey;
        _serviceKeyToTypeIndex = serviceKeyToTypeIndex;
    }

    /// <summary>Clones the Rules with the new Made.</summary>
    public Rules With(Made newMade) =>
        new Rules(
            _settings, FactorySelector, DefaultReuse,
            newMade,
            DefaultIfAlreadyRegistered, DependencyCountInLambdaToSplitBigObjectGraph,
            DependencyResolutionCallExprs, ItemToExpressionConverter, DynamicRegistrationProviders,
            DynamicRegistrationFlags, UnknownServiceResolvers, DefaultRegistrationServiceKey,
            _serviceKeyToTypeIndex);

    /// <summary>Clones the Rules, with optionally cloning the `Made` part of the rules.</summary>
    public Rules Clone(bool cloneMade = false) => With(cloneMade ? _made.Clone() : _made);

    private Rules WithSettings(Settings newSettings)
    {
        var newRules = Clone();
        newRules._settings = newSettings;
        return newRules;
    }

    /// <summary>The optional compile-time (or any time) container implementation.</summary>
    public ICompileTimeContainer CompileTimeContainer { get; private set; }

    /// <summary>Sets the compile-time container to the implementation or un-sets it to `null`</summary>
    public Rules WithCompileTimeContainer(ICompileTimeContainer container)
    {
        if (CompileTimeContainer == container)
            return this;
        var newRules = Clone();
        newRules.CompileTimeContainer = container;
        return newRules;
    }

    internal Made _made;

    [Flags]
    internal enum Settings
    {
        Empty = 0,
        ThrowIfDependencyHasShorterReuseLifespan = 1 << 1,
        ThrowOnRegisteringDisposableTransient = 1 << 2,
        TrackingDisposableTransients = 1 << 3,
        ImplicitCheckForReuseMatchingScope = 1 << 4,
        VariantGenericTypesInResolvedCollection = 1 << 5,
        ResolveIEnumerableAsLazyEnumerable = 1 << 6,
        EagerCachingSingletonForFasterAccess = 1 << 7,
        ThrowIfRuntimeStateRequired = 1 << 8,
        CaptureContainerDisposeStackTrace = 1 << 9,
        UseDynamicRegistrationsAsFallbackOnly = 1 << 10, // todo: @obsolete there are individual flags per provider now
        IgnoringReuseForFuncWithArgs = 1 << 11,
        OverrideRegistrationMade = 1 << 12,
        FuncAndLazyWithoutRegistration = 1 << 13,
        AutoConcreteTypeResolution = 1 << 14, // informational flag // todo: @clarify consider for the obsoleting
        SelectLastRegisteredFactory = 1 << 15,// informational flag
        UsedForExpressionGeneration = 1 << 16,
        // UseFastExpressionCompilerIfPlatformSupported = 1 << 17, // todo: @wip @remove the default in V5 without opt-out because of complexity, but the System.Compile(preferInterpretation?) is still used as a fallback  
        UseInterpretationForTheFirstResolution = 1 << 18,
        UseInterpretation = 1 << 19,
        UseDecorateeReuseForDecorators = 1 << 20,
        UsedForValidation = 1 << 21, // informational flag, will appear in exceptions during validation
        ServiceProviderGetServiceShouldThrowIfUnresolved = 1 << 22,
        ThrowIfScopedOrSingletonHasTransientDependency = 1 << 23,
        VariantGenericTypesInResolve = 1 << 24,
        GenerateResolutionCallForMissingDependency = 1 << 25
    }

    internal const Settings DEFAULT_SETTINGS
        = Settings.ThrowIfDependencyHasShorterReuseLifespan
        | Settings.ThrowOnRegisteringDisposableTransient
        | Settings.ImplicitCheckForReuseMatchingScope
        | Settings.VariantGenericTypesInResolvedCollection
        | Settings.EagerCachingSingletonForFasterAccess
        | Settings.UseInterpretationForTheFirstResolution;

    internal Settings _settings;

    #endregion
}

internal interface IFuncInvokeExpression { }

sealed class FuncInvoke0Expression : NotNullMethodCallExpression, IFuncInvokeExpression
{
    public override Expression Object => Constant(Func.Target);
    public readonly Delegate Func;
    internal FuncInvoke0Expression(Delegate f, MethodInfo m) : base(m) => Func = f;
    public override bool IsIntrinsic => true;

    public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
        NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas)
    {
        closure.AddConstantOrIncrementUsageCount(Func.Target);
        return Result.OK;
    }

    public override bool TryEmit(
        CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
            EmittingVisitor.TryEmitNotNullConstant(true, Func.Target, il, ref closure) &&
            EmittingVisitor.EmitMethodCall(il, Method);
}

sealed class FuncInvoke1Expression : OneArgumentMethodCallExpression, IFuncInvokeExpression
{
    public override Expression Object => Constant(Func.Target);
    public readonly Delegate Func;
    internal FuncInvoke1Expression(Delegate f, object a0) : base(f.Method, a0) => Func = f;
    public override bool IsIntrinsic => true;

    public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
        NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas)
    {
        closure.AddConstantOrIncrementUsageCount(Func.Target);
        return ExpressionCompiler.TryCollectInfo(ref closure, Argument, paramExprs, nestedLambda, ref rootNestedLambdas, flags);
    }

    public override bool TryEmit(
        CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
            EmittingVisitor.TryEmitNotNullConstant(true, Func.Target, il, ref closure)
            && EmittingVisitor.TryEmit(Argument, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.EmitMethodCall(il, Method);
}

sealed class FuncInvoke2Expression : TwoArgumentsMethodCallExpression, IFuncInvokeExpression
{
    public override Expression Object => Constant(Func.Target);
    public readonly Delegate Func;
    internal FuncInvoke2Expression(Delegate f, object a0, object a1) : base(f.Method, a0, a1) => Func = f;
    public override bool IsIntrinsic => true;

    public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas)
    {
        closure.AddConstantOrIncrementUsageCount(Func.Target);
        var r = Result.OK;
        return (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument0, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : ExpressionCompiler.TryCollectInfo(ref closure, Argument1, paramExprs, nestedLambda, ref rootNestedLambdas, flags);
    }

    public override bool TryEmit(
        CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
        EmittingVisitor.TryEmitNotNullConstant(true, Func.Target, il, ref closure) &&
        EmittingVisitor.TryEmit(Argument0, paramExprs, il, ref closure, flags, parent) &&
        EmittingVisitor.TryEmit(Argument1, paramExprs, il, ref closure, flags, parent) &&
        EmittingVisitor.EmitMethodCall(il, Method);
}

sealed class FuncInvoke3Expression : ThreeArgumentsMethodCallExpression, IFuncInvokeExpression
{
    public override Expression Object => Constant(Func.Target);
    public readonly Delegate Func;
    internal FuncInvoke3Expression(Delegate f, object a0, object a1, object a2) : base(f.Method, a0, a1, a2) => Func = f;
    public override bool IsIntrinsic => true;

    public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas)
    {
        closure.AddConstantOrIncrementUsageCount(Func.Target);
        var r = Result.OK;
        return (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument0, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument1, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : ExpressionCompiler.TryCollectInfo(ref closure, Argument2, paramExprs, nestedLambda, ref rootNestedLambdas, flags);
    }

    public override bool TryEmit(
        CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
            EmittingVisitor.TryEmitNotNullConstant(true, Func.Target, il, ref closure)
            && EmittingVisitor.TryEmit(Argument0, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument1, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument2, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.EmitMethodCall(il, Method);
}

sealed class FuncInvoke4Expression : FourArgumentsMethodCallExpression, IFuncInvokeExpression
{
    public override Expression Object => Constant(Func.Target);
    public readonly Delegate Func;
    internal FuncInvoke4Expression(Delegate f, object a0, object a1, object a2, object a3) : base(f.Method, a0, a1, a2, a3) => Func = f;
    public override bool IsIntrinsic => true;

    public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas)
    {
        closure.AddConstantOrIncrementUsageCount(Func.Target);
        var r = Result.OK;
        return (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument0, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument1, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument2, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : ExpressionCompiler.TryCollectInfo(ref closure, Argument3, paramExprs, nestedLambda, ref rootNestedLambdas, flags);
    }

    public override bool TryEmit(
        CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
            EmittingVisitor.TryEmitNotNullConstant(true, Func.Target, il, ref closure)
            && EmittingVisitor.TryEmit(Argument0, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument1, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument2, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument3, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.EmitMethodCall(il, Method);
}

sealed class FuncInvoke5Expression : FiveArgumentsMethodCallExpression, IFuncInvokeExpression
{
    public override Expression Object => Constant(Func.Target);
    public readonly Delegate Func;
    internal FuncInvoke5Expression(Delegate f, object a0, object a1, object a2, object a3, object a4)
        : base(f.Method, a0, a1, a2, a3, a4) => Func = f;
    public override bool IsIntrinsic => true;

    public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas)
    {
        closure.AddConstantOrIncrementUsageCount(Func.Target);
        var r = Result.OK;
        return (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument0, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument1, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument2, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument3, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : ExpressionCompiler.TryCollectInfo(ref closure, Argument4, paramExprs, nestedLambda, ref rootNestedLambdas, flags);
    }

    public override bool TryEmit(
        CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
            EmittingVisitor.TryEmitNotNullConstant(true, Func.Target, il, ref closure) &&
            EmittingVisitor.TryEmit(Argument0, paramExprs, il, ref closure, config, parent) &&
            EmittingVisitor.TryEmit(Argument1, paramExprs, il, ref closure, config, parent) &&
            EmittingVisitor.TryEmit(Argument2, paramExprs, il, ref closure, config, parent) &&
            EmittingVisitor.TryEmit(Argument3, paramExprs, il, ref closure, config, parent) &&
            EmittingVisitor.TryEmit(Argument4, paramExprs, il, ref closure, config, parent) &&
            EmittingVisitor.EmitMethodCall(il, Method);
}

sealed class FuncInvoke6Expression : SixArgumentsMethodCallExpression, IFuncInvokeExpression
{
    public override Expression Object => Constant(Func.Target);
    public readonly Delegate Func;
    internal FuncInvoke6Expression(Delegate f, object a0, object a1, object a2, object a3, object a4, object a5)
        : base(f.Method, a0, a1, a2, a3, a4, a5) => Func = f;
    public override bool IsIntrinsic => true;

    public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
         NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas)
    {
        closure.AddConstantOrIncrementUsageCount(Func.Target);
        var r = Result.OK;
        return (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument0, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument1, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument2, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument3, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument4, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : ExpressionCompiler.TryCollectInfo(ref closure, Argument5, paramExprs, nestedLambda, ref rootNestedLambdas, flags);
    }

    public override bool TryEmit(
       CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
           EmittingVisitor.TryEmitNotNullConstant(true, Func.Target, il, ref closure)
           && EmittingVisitor.TryEmit(Argument0, paramExprs, il, ref closure, config, parent)
           && EmittingVisitor.TryEmit(Argument1, paramExprs, il, ref closure, config, parent)
           && EmittingVisitor.TryEmit(Argument2, paramExprs, il, ref closure, config, parent)
           && EmittingVisitor.TryEmit(Argument3, paramExprs, il, ref closure, config, parent)
           && EmittingVisitor.TryEmit(Argument4, paramExprs, il, ref closure, config, parent)
           && EmittingVisitor.TryEmit(Argument5, paramExprs, il, ref closure, config, parent)
           && EmittingVisitor.EmitMethodCall(il, Method);
}

sealed class FuncInvoke7Expression : SevenArgumentsMethodCallExpression, IFuncInvokeExpression
{
    public override Expression Object => Constant(Func.Target);
    public readonly Delegate Func;
    internal FuncInvoke7Expression(Delegate f, object a0, object a1, object a2, object a3, object a4, object a5, object a6)
        : base(f.Method, a0, a1, a2, a3, a4, a5, a6) => Func = f;
    public override bool IsIntrinsic => true;

    public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
         NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas)
    {
        closure.AddConstantOrIncrementUsageCount(Func.Target);
        var r = Result.OK;
        return (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument0, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument1, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument2, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument3, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument4, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : (r = ExpressionCompiler.TryCollectInfo(ref closure, Argument5, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
            : ExpressionCompiler.TryCollectInfo(ref closure, Argument6, paramExprs, nestedLambda, ref rootNestedLambdas, flags);
    }

    public override bool TryEmit(
        CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs, ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
            EmittingVisitor.TryEmitNotNullConstant(true, Func.Target, il, ref closure)
            && EmittingVisitor.TryEmit(Argument0, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument1, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument2, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument3, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument4, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument5, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.TryEmit(Argument6, paramExprs, il, ref closure, config, parent)
            && EmittingVisitor.EmitMethodCall(il, Method);
}

/// <summary>Wraps constructor or factory method optionally with factory instance to create service.</summary>
public class FactoryMethod
{
    /// <summary>Constructor or method to use for service creation.</summary>
    public readonly MemberInfo ConstructorOrMethodOrMember;

    /// <summary>Identifies factory service if factory method is instance member.</summary>
    public virtual ServiceInfo FactoryServiceInfo => null;

    /// Alternatively you may just provide an expression for factory
    public virtual Expression FactoryExpression => null;

    internal virtual Delegate FactoryFunc => null;

    ///<summary> Contains resolved parameter expressions found when looking for most resolvable constructor</summary> 
    internal virtual Expression[] ResolvedParameterExpressions => null;

    /// <summary>Just creates a thingy from the constructor</summary>
    public FactoryMethod(MemberInfo memberInfo) => ConstructorOrMethodOrMember = memberInfo;

    internal sealed class WithFactoryExpression : FactoryMethod
    {
        public override Expression FactoryExpression { get; }
        internal WithFactoryExpression(MemberInfo constructorOrMethodOrMember, Expression factoryExpression) : base(constructorOrMethodOrMember) =>
            FactoryExpression = factoryExpression;
    }

    internal sealed class WithFunc : FactoryMethod
    {
        internal override Delegate FactoryFunc { get; }
        internal WithFunc(MethodInfo invokeMethod, Delegate factoryFunc) : base(invokeMethod) =>
            FactoryFunc = factoryFunc;
    }

    internal sealed class WithFactoryServiceInfo : FactoryMethod
    {
        public override ServiceInfo FactoryServiceInfo { get; }
        internal WithFactoryServiceInfo(MemberInfo constructorOrMethodOrMember, ServiceInfo factoryServiceInfo) : base(constructorOrMethodOrMember) =>
            FactoryServiceInfo = factoryServiceInfo;
    }

    internal sealed class WithResolvedParameterExpressions : FactoryMethod
    {
        internal override Expression[] ResolvedParameterExpressions { get; }
        internal WithResolvedParameterExpressions(ConstructorInfo ctor, Expression[] resolvedParameterExpressions) : base(ctor) =>
            ResolvedParameterExpressions = resolvedParameterExpressions;
    }

    /// <summary>Constructs the factory method from the typed Invoke method to understand the type of dependencies,
    /// and the delegate with object parameters and result type.</summary>
    public static FactoryMethod OfFunc<D>(MethodInfo funcTypedInvokeMethod, D funcOfObjParamsAndResult) where D : Delegate =>
        new WithFunc(funcTypedInvokeMethod, funcOfObjParamsAndResult);

    /// <summary>Wraps method and factory instance.
    /// Where <paramref name="ctorOrMethodOrMember"/> is constructor, static or instance method, property or field.</summary>
    public static FactoryMethod Of(MemberInfo ctorOrMethodOrMember, ServiceInfo factoryInfo = null)
    {
        ctorOrMethodOrMember.ThrowIfNull(Error.PassedCtorOrMemberIsNull);

        if (ctorOrMethodOrMember is ConstructorInfo == false && !ctorOrMethodOrMember.IsStatic())
        {
            if (factoryInfo == null)
                Throw.It(Error.PassedMemberIsNotStaticButInstanceFactoryIsNull, ctorOrMethodOrMember);
            return new WithFactoryServiceInfo(ctorOrMethodOrMember, factoryInfo);
        }

        if (factoryInfo != null)
            Throw.It(Error.PassedMemberIsStaticButInstanceFactoryIsNotNull, ctorOrMethodOrMember, factoryInfo);
        return new FactoryMethod(ctorOrMethodOrMember);
    }

    /// <summary>Wraps method and factory instance.
    /// Where <paramref name="methodOrMember"/> is constructor, static or instance method, property or field.</summary>
    public static FactoryMethod Of(MemberInfo methodOrMember, object factoryInstance)
    {
        factoryInstance.ThrowIfNull();
        methodOrMember.ThrowIfNull(Error.PassedCtorOrMemberIsNull);
        if (methodOrMember.IsStatic())
            Throw.It(Error.PassedMemberIsStaticButInstanceFactoryIsNotNull, methodOrMember, factoryInstance);
        return new WithFactoryExpression(methodOrMember, Constant(factoryInstance));
    }

    internal static FactoryMethod OfFactory<F>(MemberInfo methodOrMember, F factory) =>
        new WithFactoryExpression(methodOrMember, ConstantOf<F>(factory));

    /// <summary>Discovers the static factory method or member by name in <typeparamref name="TFactory"/>.
    /// Should play nice with C# <see langword="nameof"/> operator.</summary>
    public static FactoryMethod Of<TFactory>(string methodOrMemberName) =>
        Of(typeof(TFactory).GetAllMembers().FindFirst(m => m.Name == methodOrMemberName).ThrowIfNull());

    /// <summary>Pretty prints wrapped method.</summary>
    public override string ToString()
    {
        var s = new StringBuilder("{")
            .Print(ConstructorOrMethodOrMember.DeclaringType)
            .Append('.').Append(ConstructorOrMethodOrMember);
        if (FactoryServiceInfo != null)
            s.Append(" of factory service ").Append(FactoryServiceInfo);
        if (FactoryExpression != null)
            s.Append(" of factory expression ").Append(FactoryExpression);
        return s.Append('}').ToString();
    }

    private struct CtorWithParameters
    {
        public ConstructorInfo Ctor;
        public ParameterInfo[] Params;
    }

    /// <summary>Easy way to specify non-public and most resolvable constructor.</summary>
    /// <param name="mostResolvable">(optional) Instructs to select constructor with max number of params which all are resolvable.</param>
    /// <param name="includeNonPublic">(optional) Consider the non-public constructors.</param>
    /// <returns>Constructor or null if not found.</returns>
    public static FactoryMethodSelector Constructor(bool mostResolvable = false, bool includeNonPublic = false)
    {
        if (mostResolvable)
            return includeNonPublic
                ? (static request => MostResolvableConstructor(request, BindingFlags.NonPublic))
                : (FactoryMethodSelector)(static request => MostResolvableConstructor(request));
        return includeNonPublic
            ? (static request => Constructor(request, BindingFlags.NonPublic))
            : (FactoryMethodSelector)(static request => Constructor(request));
    }

    private static FactoryMethod MostResolvableConstructor(Request request,
        BindingFlags additionalToPublicAndInstance = 0, Func<Type, ParameterInfo[], bool> condition = null)
    {
        var ctors = ((ReflectionFactory)request.Factory).GetConstructors(request, additionalToPublicAndInstance);
        if (ctors.Length != 0 & condition != null)
            ctors = ctors.Match(condition, static (cond, c) => cond(c.DeclaringType, c.GetParameters()));

        if (ctors.Length == 0)
            return null;

        var firstCtor = ctors[0];
        if (ctors.Length == 1)
            return new FactoryMethod(firstCtor);

        var container = request.Container;
        var paramSelector = container.Rules.TryGetParameterSelector(request.Made)(request);

        var throwIfCtorNotFound = request.IfUnresolved != IfUnresolved.ReturnDefault;
        if (throwIfCtorNotFound)
            request = request.WithIfUnresolved(IfUnresolved.ReturnDefault);

        // Consider the constructor with the maximum number of parameters first, 
        // If there are more than one constructor with the same number of parameters,
        // then we should consider the one with most of passed input arguments and custom values provided
        var firstCtorParams = firstCtor.GetParameters();
        var secondCtor = ctors[1];
        var secondCtorParams = secondCtor.GetParameters();
        var maxParamsCtor = firstCtorParams.Length > secondCtorParams.Length ? firstCtor : secondCtor;
        var maxParamsCtorParams = maxParamsCtor == firstCtor ? firstCtorParams : secondCtorParams;

        CtorWithParameters[] ctorsWithParams = null;
        var maxParamsCtorIndex = -1;
        var ctorCount = ctors.Length;
        if (ctorCount > 2)
        {
            // put the rest into the array (if required) to not allocate and spend time for all the GetParameters calls
            ctorsWithParams = new CtorWithParameters[ctorCount - 2];
            for (var i = 0; i < ctorCount - 2; ++i)
            {
                var ctor = ctors[i + 2];
                var ctorParams = ctor.GetParameters();
                if (ctorParams.Length > maxParamsCtorParams.Length)
                {
                    maxParamsCtor = ctor;
                    maxParamsCtorParams = ctorParams;
                    maxParamsCtorIndex = i;
                }

                ctorsWithParams[i].Ctor = ctor;
                ctorsWithParams[i].Params = ctorParams;
            }

            // nullify the constructor which is the max-one to exclude it from the sorting for the next time
            if (maxParamsCtor == firstCtor)
                firstCtor = null;
            else if (maxParamsCtor == secondCtor)
                secondCtor = null;
            else
                ctorsWithParams[maxParamsCtorIndex].Ctor = null;
        }

        var mostUsedArgCount = -1;
        ConstructorInfo resolvedCtor = null;
        Expression[] resolvedCtorParamExprs = null;
        for (var c = 0; c < ctorCount; ++c)
        {
            if (c > 0) // second and more tries to find the new max-param constructor
            {
                if (ctorCount == 2)
                {
                    maxParamsCtor = maxParamsCtor == firstCtor ? secondCtor : firstCtor;
                    maxParamsCtorParams = maxParamsCtor == firstCtor ? firstCtorParams : secondCtorParams;
                }
                else
                {
                    maxParamsCtor = null;
                    if (firstCtor != null)
                    {
                        maxParamsCtor = firstCtor;
                        maxParamsCtorParams = firstCtorParams;
                    }

                    if (secondCtor != null &&
                        (firstCtor == null || secondCtorParams.Length > firstCtorParams.Length))
                    {
                        maxParamsCtor = secondCtor;
                        maxParamsCtorParams = secondCtorParams;
                    }

                    maxParamsCtorIndex = -1;
                    for (var i = 0; i < ctorsWithParams.Length; ++i)
                    {
                        if (ctorsWithParams[i].Ctor != null &&
                            (maxParamsCtor == null || ctorsWithParams[i].Params.Length > maxParamsCtorParams.Length))
                        {
                            maxParamsCtor = ctorsWithParams[i].Ctor;
                            maxParamsCtorParams = ctorsWithParams[i].Params;
                            maxParamsCtorIndex = i;
                        }
                    }

                    if (maxParamsCtor == firstCtor)
                        firstCtor = null;
                    else if (maxParamsCtor == secondCtor)
                        secondCtor = null;
                    else
                        ctorsWithParams[maxParamsCtorIndex].Ctor = null;
                }
            }

            // Use already resolved constructor or the default one without parameters
            if (maxParamsCtorParams.Length == 0)
            {
                resolvedCtor = resolvedCtor ?? maxParamsCtor;
                break;
            }

            // If the resolved constructor is found and the next one has less parameters we're done
            if (resolvedCtorParamExprs != null &&
                resolvedCtorParamExprs.Length > maxParamsCtorParams.Length)
                break;

            // Otherwise for similar parameters count constructor we prefer the one with most used input args / custom values
            // Should count custom values provided via `Resolve(args)`, `Func<args..>`, `Parameter.Of...(_ -> arg)`, `container.Use(arg)`
            var usedInputArgOrUsedOrCustomValueCount = 0;
            var inputArgs = request.InputArgExprs;
            var argsUsedMask = 0;
            var paramExprs = new Expression[maxParamsCtorParams.Length]; // todo: @perf opportunity for reusing the array as it is dropped when constructor is unresolved

            for (var i = 0; i < maxParamsCtorParams.Length; i++)
            {
                var param = maxParamsCtorParams[i];
                if (inputArgs != null)
                {
                    var inputArgExpr = ReflectionFactory.TryGetExpressionFromInputArgs(param.ParameterType, inputArgs, ref argsUsedMask);
                    if (inputArgExpr != null)
                    {
                        ++usedInputArgOrUsedOrCustomValueCount;
                        paramExprs[i] = inputArgExpr;
                        continue;
                    }
                }

                Factory paramFactory = null;
                Request paramRequest = null;
                var paramDetails = ServiceDetails.Default;

                var paramServiceInfo = paramSelector(param);
                if (paramServiceInfo != ParameterServiceInfo.DefinitelyUnresolvedParameter)
                {
                    if (paramServiceInfo == null)
                        paramRequest = request.Push(param);
                    else
                    {
                        paramRequest = request.Push(paramServiceInfo);
                        paramDetails = paramServiceInfo.Details;
                    }

                    var usedOrCustomValExpr = ReflectionFactory.TryGetUsedInstanceOrCustomValueExpression(request, paramRequest, paramDetails);
                    if (usedOrCustomValExpr != null)
                    {
                        ++usedInputArgOrUsedOrCustomValueCount;
                        paramExprs[i] = usedOrCustomValExpr;
                        continue;
                    }

                    paramFactory = container.ResolveFactory(paramRequest);
                }

                var injectedExpr = paramFactory?.GetExpressionOrDefault(paramRequest);
                if (injectedExpr == null ||
                    // When param is an empty array / collection, then we may use a default value instead (#581)
                    paramDetails.DefaultValue != null && injectedExpr.NodeType == ExprType.NewArrayInit && ((NewArrayExpression)injectedExpr).ArgumentCount == 0)
                {
                    // Check if parameter dependency itself (without propagated parent details)
                    // does not allow default, then stop checking the rest of parameters.
                    if (paramDetails.IfUnresolved == IfUnresolved.Throw)
                    {
                        paramExprs = null;
                        break;
                    }

                    injectedExpr = paramDetails.DefaultValue != null
                        ? request.Container.GetConstantExpression(paramDetails.DefaultValue, paramRequest.ServiceType)
                        : paramRequest.ServiceType.GetDefaultValueExpression();
                }

                paramExprs[i] = injectedExpr;
            }

            if (paramExprs != null && usedInputArgOrUsedOrCustomValueCount > mostUsedArgCount)
            {
                mostUsedArgCount = usedInputArgOrUsedOrCustomValueCount;
                resolvedCtor = maxParamsCtor;
                resolvedCtorParamExprs = paramExprs;
            }
        }

        if (resolvedCtor == null)
            return Throw.For<FactoryMethod>(throwIfCtorNotFound, Error.UnableToFindCtorWithAllResolvableArgs, request.InputArgExprs, request);

        return new WithResolvedParameterExpressions(resolvedCtor, resolvedCtorParamExprs);
    }

    private static FactoryMethod Constructor(Request request, BindingFlags additionalToPublicAndInstance = 0)
    {
        var ctors = ((ReflectionFactory)request.Factory).GetConstructors(request, additionalToPublicAndInstance);
        return ctors.Length == 1 ? new FactoryMethod(ctors[0]) : null;
    }

    /// <summary>Easy way to specify default constructor to be used for resolution.</summary>
    public static FactoryMethodSelector DefaultConstructor(bool includeNonPublic = false) => request =>
        request.ImplementationType.ThrowIfNull(Error.ImplTypeIsNotSpecifiedForAutoCtorSelection, request)
            .GetConstructorOrNull(includeNonPublic, Empty<Type>())?.To(static ctor => new FactoryMethod(ctor));

    /// <summary>Searches for a single constructor excluding the ones with the same implementation type as parameter.
    /// Used by the AutoConcrete type resolution to avoid selection of recursive constructors like `Foo(Foo f)`</summary>
    public static readonly FactoryMethodSelector ConstructorWithResolvableArgumentsIncludingNonPublicWithoutSameTypeParam =
        static request => MostResolvableConstructor(request, BindingFlags.NonPublic,
            static (implType, ps) => ps.FindFirst(implType, static (t, p) => t == p.ParameterType) == null);

    /// <summary>Better be named `ConstructorWithMostResolvableArguments`.
    /// Searches for public constructor with most resolvable parameters or throws <see cref="ContainerException"/> if not found.
    /// Works both for resolving service and `Func{TArgs..., TService}`</summary>
    public static readonly FactoryMethodSelector ConstructorWithResolvableArguments = Constructor(mostResolvable: true);

    /// <summary>Searches for constructor (including non public ones) with most resolvable parameters or throws <see cref="ContainerException"/> if not found.
    /// Works both for resolving service and for Func{TArgs..., TService}</summary>
    public static readonly FactoryMethodSelector ConstructorWithResolvableArgumentsIncludingNonPublic = Constructor(mostResolvable: true, includeNonPublic: true);
}

/// <summary>Rules how to: <list type="bullet">
/// <item>Select constructor for creating service with <see cref="FactoryMethodOrSelector"/>.</item>
/// <item>Specify how to resolve constructor parameters with <see cref="Parameters"/>.</item>
/// <item>Specify what properties/fields to resolve and how with <see cref="PropertiesAndFields"/>.</item>
/// </list></summary>
public class Made
{
    /// <summary>The factory method or its selector based on the request.</summary>
    public object FactoryMethodOrSelector { get; internal set; }

    /// <summary>Return type of strongly-typed factory method expression.</summary>
    public virtual Type FactoryMethodKnownResultType => null;

    /// <summary>Specifies how constructor parameters should be resolved:
    /// parameter service key and type, throw or return default value if parameter is unresolved.</summary>
    public virtual ParameterSelector Parameters => null;

    /// <summary>Specifies what <see cref="ServiceInfo"/> should be used when resolving property or field.</summary>
    public virtual PropertiesAndFieldsSelector PropertiesAndFields => null;

    internal virtual MadeDetails _details => MadeDetails.NoConditionals;

    internal class WithFactoryMethodKnownResultType : Made
    {
        public override Type FactoryMethodKnownResultType { get; }
        internal WithFactoryMethodKnownResultType(object factoryMethodOrSelector, Type factoryReturnType)
            : base(factoryMethodOrSelector) => FactoryMethodKnownResultType = factoryReturnType;
        internal WithFactoryMethodKnownResultType(FactoryMethod factoryMethod, Type factoryReturnType)
            : base(factoryMethod) => FactoryMethodKnownResultType = factoryReturnType;
    }

    internal class WithFactoryMethodAndParameters : Made
    {
        public override ParameterSelector Parameters { get; }
        internal WithFactoryMethodAndParameters(FactoryMethod factoryMethod, ParameterSelector parameters)
            : base(factoryMethod) => Parameters = parameters;
    }

    internal sealed class WithDetails : WithFactoryMethodKnownResultType
    {
        public override ParameterSelector Parameters => _parameters;
        internal ParameterSelector _parameters;
        public override PropertiesAndFieldsSelector PropertiesAndFields { get; }
        internal override MadeDetails _details { get; }
        public WithDetails(object factoryMethodOrSelector, Type factoryMethodKnownResultType,
            ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields, MadeDetails details) :
            base(factoryMethodOrSelector, factoryMethodKnownResultType)
        {
            _details = details;
            _parameters = parameters;
            PropertiesAndFields = propertiesAndFields;
        }

        internal WithDetails(object factoryMethodOrSelector, Type factoryMethodKnownResultType = null,
            ParameterSelector parameters = null, PropertiesAndFieldsSelector propertiesAndFields = null,
            bool hasCustomValue = false, bool isConditionalImplementation = false, bool implMemberDependsOnRequest = false) :
            base(factoryMethodOrSelector, factoryMethodKnownResultType)
        {
            var details = default(MadeDetails);

            if (parameters != null | propertiesAndFields != null)
                details |= MadeDetails.ImplMemberDependsOnRequest;
            if (hasCustomValue)
                details |= MadeDetails.HasCustomDependencyValue;
            if (isConditionalImplementation)
                details |= MadeDetails.ImplTypeDependsOnRequest;
            if (implMemberDependsOnRequest)
                details |= MadeDetails.ImplMemberDependsOnRequest;

            _details = details;
            _parameters = parameters;
            PropertiesAndFields = propertiesAndFields;
        }
    }

    [Flags]
    internal enum MadeDetails : byte
    {
        NoConditionals = 0,
        ImplTypeDependsOnRequest = 1 << 1, // todo: @unclear I am not sure why I am using shift to 1 as first and then shift to 3
        ImplMemberDependsOnRequest = 1 << 3,
        HasCustomDependencyValue = 1 << 4
    }

    /// Has any conditional flags
    public bool IsConditional => _details != MadeDetails.NoConditionals;

    /// <summary>True if made has properties or parameters with custom value.
    /// That's mean the whole made become context based which affects caching.</summary>
    public bool HasCustomDependencyValue => (_details & MadeDetails.HasCustomDependencyValue) != 0;

    /// <summary>Indicates that the implementation type depends on request.</summary>
    public bool IsConditionalImplementation => (_details & MadeDetails.ImplTypeDependsOnRequest) != 0;

    /// Indicates that the member depends on request
    public bool IsImplMemberDependsOnRequest => (_details & MadeDetails.ImplMemberDependsOnRequest) != 0;

    /// <summary>Outputs whatever is possible (known) for Made</summary>
    public override string ToString()
    {
        if (this == Default)
            return "Made.Default";

        var s = "{";
        if (FactoryMethodOrSelector != null)
        {
            s += (s == "{" ? "" : ", ") + "FactoryMethod=";
            if (ReferenceEquals(FactoryMethodOrSelector, DryIoc.FactoryMethod.ConstructorWithResolvableArguments))
                s += nameof(DryIoc.FactoryMethod.ConstructorWithResolvableArguments);
            else if (ReferenceEquals(FactoryMethodOrSelector, DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublic))
                s += nameof(DryIoc.FactoryMethod.ConstructorWithResolvableArgumentsIncludingNonPublic);
            else
                s += "<custom>";
        }

        if (FactoryMethodKnownResultType != null)
            s += (s == "{" ? "" : ", ") + "FactoryMethodKnownResultType=typeof(" + FactoryMethodKnownResultType.Print() + ")";
        if (HasCustomDependencyValue)
            s += (s == "{" ? "" : ", ") + "HasCustomDependencyValue=true";
        if (PropertiesAndFields != null)
            s += (s == "{" ? "" : ", ") + "PropertiesAndFields=<custom>";
        if (Parameters != null)
            s += (s == "{" ? "" : ", ") + "ParameterSelector=<custom>";
        return s + "}";
    }

    /// <summary>Container will use some sensible defaults for service creation.</summary>
    public static readonly Made Default = new Made();

    /// <summary>Creates rules with only <see cref="FactoryMethodOrSelector"/> specified.</summary>
    public static implicit operator Made(FactoryMethodSelector factoryMethod) => new Made(factoryMethod);

    /// <summary>Creates rules with only <see cref="Parameters"/> specified.</summary>
    public static implicit operator Made(ParameterSelector parameters) => new WithDetails(null, null, parameters);

    /// <summary>Creates rules with only <see cref="PropertiesAndFields"/> specified.</summary>
    public static implicit operator Made(PropertiesAndFieldsSelector propertiesAndFields) => new WithDetails(null, null, null, propertiesAndFields);

    /// <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="Default"/> rules.</summary>
    public static Made Of(FactoryMethodSelector factoryMethodSelector = null,
        ParameterSelector parameters = null, PropertiesAndFieldsSelector propertiesAndFields = null, bool isConditionalImplementation = false) =>
        Create(factoryMethodSelector, parameters, propertiesAndFields, isConditionalImplementation);

    /// <summary>Specifies injections rules for FactoryMethod and Parameters.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static Made OfFactoryMethodAndParameters(FactoryMethod factoryMethod, ParameterSelector parameters) =>
        new Made.WithFactoryMethodAndParameters(factoryMethod, parameters);

    internal static Made Create(object factoryMethodOrSelector,
        ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields, bool isConditionalImplementation)
    {
        bool withDetails = parameters != null | propertiesAndFields != null | isConditionalImplementation;
        return factoryMethodOrSelector == null & !withDetails
            ? Default
            : !withDetails ? new Made(factoryMethodOrSelector)
            : new WithDetails(factoryMethodOrSelector, null, parameters, propertiesAndFields, isConditionalImplementation: isConditionalImplementation);
    }

    /// <summary>Adds the parameter selector to the mix</summary>
    public Made With(FactoryMethodSelector factoryMethod, ParameterSelector parameters) =>
        new WithDetails(factoryMethod, FactoryMethodKnownResultType, parameters, PropertiesAndFields);

    /// <summary>Specifies injections rules for Constructor, Parameters, Properties and Fields. If no rules specified returns <see cref="Default"/> rules.</summary>
    public static Made Of(FactoryMethod factoryMethod,
        ParameterSelector parameters = null, PropertiesAndFieldsSelector propertiesAndFields = null)
    {
        var methodReturnType = factoryMethod.ThrowIfNull().ConstructorOrMethodOrMember.GetReturnTypeOrDefault();

        // Normalizes open-generic type to open-generic definition,
        // because for base classes and return types it may not be the case (they may be partially closed).
        var methodReturnTypeIsDefined = methodReturnType != null & methodReturnType != typeof(object);
        if (methodReturnTypeIsDefined && methodReturnType.IsOpenGeneric())
            methodReturnType = methodReturnType.GetGenericTypeDefinition();

        return parameters == null & propertiesAndFields == null
            ? (!methodReturnTypeIsDefined ? new Made(factoryMethod)
            : new WithFactoryMethodKnownResultType(factoryMethod, methodReturnType))
            : new WithDetails(factoryMethod, methodReturnType, parameters, propertiesAndFields);
    }

    /// <summary>Creates factory method specification</summary>
    public static Made Of(MemberInfo factoryMethodOrMember, ServiceInfo factoryInfo = null,
        ParameterSelector parameters = null, PropertiesAndFieldsSelector propertiesAndFields = null) =>
        Of(DryIoc.FactoryMethod.Of(factoryMethodOrMember, factoryInfo), parameters, propertiesAndFields);

    /// <summary>Creates factory specification with implementation type, conditionally depending on request.</summary>
    public static Made Of(Func<Request, Type> getImplType, ParameterSelector parameters = null, PropertiesAndFieldsSelector propertiesAndFields = null) =>
        Of(r => DryIoc.FactoryMethod.Of(getImplType(r).SingleConstructor()), parameters, propertiesAndFields, isConditionalImplementation: true);

    /// <summary>Creates factory specification with method or member selector based on request.
    /// Where <paramref name="getMethodOrMember"/> is method, or constructor, or member selector.</summary>
    public static Made Of(Func<Request, MemberInfo> getMethodOrMember, ServiceInfo factoryInfo = null,
        ParameterSelector parameters = null, PropertiesAndFieldsSelector propertiesAndFields = null) =>
        new WithDetails((FactoryMethodSelector)(r => DryIoc.FactoryMethod.Of(getMethodOrMember(r), factoryInfo)), null,
            parameters, propertiesAndFields, implMemberDependsOnRequest: true);

    /// <summary>Creates factory specification with method or member selector based on request.
    /// Where <paramref name="getMethodOrMember"/>Method, or constructor, or member selector.</summary>
    public static Made Of(Func<Request, MemberInfo> getMethodOrMember, Func<Request, ServiceInfo> factoryInfo,
        ParameterSelector parameters = null, PropertiesAndFieldsSelector propertiesAndFields = null) =>
        new WithDetails((FactoryMethodSelector)(r => DryIoc.FactoryMethod.Of(getMethodOrMember(r), factoryInfo(r))), null,
            parameters, propertiesAndFields, implMemberDependsOnRequest: true);

    /// <summary>Defines how to select constructor from implementation type.
    /// Where <paramref name="getConstructor"/> is delegate taking implementation type as input 
    /// and returning selected constructor info.</summary>
    public static Made Of(Func<Type, ConstructorInfo> getConstructor,
        ParameterSelector parameters = null, PropertiesAndFieldsSelector propertiesAndFields = null) =>
        Create((FactoryMethodSelector)(
            r => DryIoc.FactoryMethod.Of(getConstructor(r.ImplementationType).ThrowIfNull(Error.GotNullConstructorFromFactoryMethod, r))),
            parameters, propertiesAndFields, false);

    // todo: @bug @wip @breaking @NET6 @remove or rename the overload as it's not compiled by .NET 6 compiler because it infers the type of lambda to object
    /// <summary>Defines factory method using expression of constructor call (with properties), or static method call.</summary>
    /// <typeparam name="TService">Type with constructor or static method.</typeparam>
    /// <param name="serviceReturningExpr">Expression tree with call to constructor with properties:
    /// <code lang="cs"><![CDATA[() => new Car(Arg.Of<IEngine>()) { Color = Arg.Of<Color>("CarColor") }]]></code>
    /// or static method call <code lang="cs"><![CDATA[() => Car.Create(Arg.Of<IEngine>())]]></code></param>
    /// <param name="argValues">(optional) Primitive custom values for dependencies.</param>
    /// <returns>New Made specification.</returns>
    public static TypedMade<TService> Of<TService>(
        System.Linq.Expressions.Expression<Func<TService>> serviceReturningExpr,
        params Func<Request, object>[] argValues) =>
        FromExpression<object, TService>(member => _ => DryIoc.FactoryMethod.Of(member), null, serviceReturningExpr, argValues);

    /// <summary>Defines creation info from factory method call Expression without using strings.
    /// You can supply any/default arguments to factory method, they won't be used, it is only to find the <see cref="MethodInfo"/>.</summary>
    /// <typeparam name="TFactory">Factory type.</typeparam> <typeparam name="TService">Factory product type.</typeparam>
    /// <param name="getFactoryInfo">Returns or resolves factory instance.</param>
    /// <param name="serviceReturningExpr">Method, property or field expression returning service.</param>
    /// <param name="argValues">(optional) Primitive custom values for dependencies.</param>
    /// <returns>New Made specification.</returns>
    public static TypedMade<TService> Of<TFactory, TService>(
        Func<Request, ServiceInfo.Typed<TFactory>> getFactoryInfo,
        System.Linq.Expressions.Expression<Func<TFactory, TService>> serviceReturningExpr,
        params Func<Request, object>[] argValues)
        where TFactory : class =>
        FromExpression<TFactory, TService>(null, getFactoryInfo.ThrowIfNull(), serviceReturningExpr, argValues);

    /// <summary>Composes Made.Of expression with known factory instance and expression to get a service</summary>
    public static TypedMade<TService> Of<TFactory, TService>(
        TFactory factoryInstance,
        System.Linq.Expressions.Expression<Func<TFactory, TService>> serviceReturningExpr,
        params Func<Request, object>[] argValues)
        where TFactory : class
    {
        factoryInstance.ThrowIfNull();
        return FromExpression<TFactory, TService>(
            member => request => DryIoc.FactoryMethod.Of(member, factoryInstance),
            null, serviceReturningExpr, argValues);
    }

    private static TypedMade<TService> FromExpression<TFactory, TService>(
        Func<MemberInfo, FactoryMethodSelector> eitherGetFactoryMethodSelector,
        Func<Request, ServiceInfo.Typed<TFactory>> orGetFactoryInfo,
        System.Linq.Expressions.LambdaExpression serviceReturningExpr,
        params Func<Request, object>[] argValues)
    {
        var callExpr = serviceReturningExpr.ThrowIfNull().Body;
        if (callExpr.NodeType == ExprType.Convert) // proceed without Cast expression.
            return FromExpression<TFactory, TService>(eitherGetFactoryMethodSelector, orGetFactoryInfo,
                System.Linq.Expressions.Expression.Lambda(((System.Linq.Expressions.UnaryExpression)callExpr).Operand,
                    Empty<System.Linq.Expressions.ParameterExpression>()),
                argValues);

        MemberInfo ctorOrMethodOrMember;
        IList<System.Linq.Expressions.Expression> argExprs = null;
        IList<System.Linq.Expressions.MemberBinding> memberBindingExprs = null;
        ParameterInfo[] parameters = null;

        if (callExpr.NodeType == ExprType.New ||
            callExpr.NodeType == ExprType.MemberInit)
        {
            var newExpr = callExpr as System.Linq.Expressions.NewExpression ?? ((System.Linq.Expressions.MemberInitExpression)callExpr).NewExpression;
            ctorOrMethodOrMember = newExpr.Constructor;
            parameters = newExpr.Constructor.GetParameters();
            argExprs = newExpr.Arguments;
            if (callExpr is System.Linq.Expressions.MemberInitExpression)
                memberBindingExprs = ((System.Linq.Expressions.MemberInitExpression)callExpr).Bindings;
        }
        else if (callExpr.NodeType == ExprType.Call)
        {
            var methodCallExpr = (System.Linq.Expressions.MethodCallExpression)callExpr;
            ctorOrMethodOrMember = methodCallExpr.Method;
            parameters = methodCallExpr.Method.GetParameters();
            argExprs = methodCallExpr.Arguments;
        }
        else if (callExpr.NodeType == ExprType.Invoke)
        {
            var invokeExpr = (System.Linq.Expressions.InvocationExpression)callExpr;
            var invokedDelegateExpr = invokeExpr.Expression;
            var invokeMethod = invokedDelegateExpr.Type.GetMethod(nameof(Action.Invoke));
            ctorOrMethodOrMember = invokeMethod;
            parameters = invokeMethod.GetParameters();
            argExprs = invokeExpr.Arguments;
        }

        else if (callExpr.NodeType == ExprType.MemberAccess)
        {
            var member = ((System.Linq.Expressions.MemberExpression)callExpr).Member;
            Throw.If(!(member is PropertyInfo) && !(member is FieldInfo),
                Error.UnexpectedFactoryMemberExpressionInMadeOf, member, serviceReturningExpr);
            ctorOrMethodOrMember = member;
        }
        else return Throw.For<TypedMade<TService>>(Error.NotSupportedMadeOfExpression, callExpr);

        var hasCustomValue = false;
        var hasUsedFactoryInfoForParameter = false;

        var parameterSelector = parameters.IsNullOrEmpty() ? null :
            ComposeParameterSelectorFromArgs(ref hasCustomValue, ref hasUsedFactoryInfoForParameter,
                orGetFactoryInfo, serviceReturningExpr, parameters, argExprs, argValues);

        var propertiesAndFieldsSelector = memberBindingExprs == null || memberBindingExprs.Count == 0 ? null :
            ComposePropertiesAndFieldsSelector(ref hasCustomValue, serviceReturningExpr, memberBindingExprs, argValues);

        var factoryMethodSelector =
            eitherGetFactoryMethodSelector != null
                ? eitherGetFactoryMethodSelector(ctorOrMethodOrMember) :
            hasUsedFactoryInfoForParameter
                ? (FactoryMethodSelector)(_ => DryIoc.FactoryMethod.Of(ctorOrMethodOrMember))
                : (FactoryMethodSelector)(r => DryIoc.FactoryMethod.Of(ctorOrMethodOrMember, orGetFactoryInfo(r)));

        if (!hasCustomValue & parameterSelector == null & propertiesAndFieldsSelector == null)
            return new TypedMade<TService>(factoryMethodSelector);
        return new WithDetails<TService>(factoryMethodSelector,
            parameterSelector, propertiesAndFieldsSelector, hasCustomValue);
    }

    /// <summary>Typed version of <see cref="Made"/> specified with statically typed expression tree.</summary>
    public class TypedMade<TService> : Made
    {
        /// <inheritdoc />
        public override Type FactoryMethodKnownResultType => typeof(TService);
        internal TypedMade(FactoryMethodSelector factoryMethodSelector) : base(factoryMethodSelector) { }
    }

    internal sealed class WithDetails<TService> : TypedMade<TService>
    {
        public override ParameterSelector Parameters { get; }
        public override PropertiesAndFieldsSelector PropertiesAndFields { get; }
        internal override MadeDetails _details { get; }
        public WithDetails(FactoryMethodSelector factoryMethod,
            ParameterSelector parameters, PropertiesAndFieldsSelector propertiesAndFields, bool hasCustomValue) : base(factoryMethod)
        {
            var details = default(MadeDetails);

            if (parameters != null || propertiesAndFields != null)
                details |= MadeDetails.ImplMemberDependsOnRequest;
            if (hasCustomValue)
                details |= MadeDetails.HasCustomDependencyValue;

            _details = details;
            Parameters = parameters;
            PropertiesAndFields = propertiesAndFields;
        }
    }

    internal Made(object factoryMethodOrSelector = null) => FactoryMethodOrSelector = factoryMethodOrSelector;

    internal Made(FactoryMethod factoryMethod) => FactoryMethodOrSelector = factoryMethod;

    // it does not return Default made as-is because the cloned result supposed to be mutated
    internal Made Clone()
    {
        var t = FactoryMethodKnownResultType;
        return _details == default
            ? t == null ? new Made(FactoryMethodOrSelector) : new WithFactoryMethodKnownResultType(FactoryMethodOrSelector, t)
            : new WithDetails(FactoryMethodOrSelector, t, Parameters, PropertiesAndFields, _details);
    }

    private static ParameterSelector ComposeParameterSelectorFromArgs<TFactory>(
        ref bool hasCustomValue, ref bool hasUsedFactoryInfoForParameter,
        Func<Request, ServiceInfo.Typed<TFactory>> nullOrGetFactoryInfo,
        System.Linq.Expressions.Expression wholeServiceExpr, ParameterInfo[] paramInfos,
        IList<System.Linq.Expressions.Expression> argExprs,
        params Func<Request, object>[] argValues)
    {
        var paramSelector = DryIoc.Parameters.Of;
        for (var i = 0; i < argExprs.Count; i++)
        {
            var paramInfo = paramInfos[i];
            var argExpr = argExprs[i];

            // If the parameter expression passed from the lambda argument, e.g. for the static and extension methods,
            // Then we will be using the argument factory info as a parameter info, 
            // so for the extension method `f => f.Create()` the factory info for the `f` will be used for the parameter `f` in `Exts.Create(f)`.
            if (argExpr is System.Linq.Expressions.ParameterExpression paramExpr)
            {
                if (nullOrGetFactoryInfo != null &&
                    typeof(TFactory).IsAssignableTo(paramExpr.Type))
                {
                    hasUsedFactoryInfoForParameter = true;
                    paramSelector = paramSelector.OverrideWith(req =>
                        p => p.Equals(paramInfo)
                            ? nullOrGetFactoryInfo(req)?.Details?.To(ParameterServiceInfo.Of(p).WithDetails)
                            : null);
                }
                else Throw.It(Error.MadeOfCallExpressionParameterDoesNotCorrespondToTheFactoryInfo, paramExpr, typeof(TFactory));
                continue;
            }

            if (argExpr is System.Linq.Expressions.MethodCallExpression methodCallExpr)
            {
                if (methodCallExpr.Method.DeclaringType != typeof(Arg))
                    Throw.It(Error.UnexpectedExpressionInsteadOfArgMethodInMadeOf, methodCallExpr, wholeServiceExpr);

                if (methodCallExpr.Method.Name == Arg.ArgIndexMethodName)
                {
                    var getArgValue = GetArgCustomValueProvider(wholeServiceExpr, methodCallExpr, argValues);
                    paramSelector = paramSelector.Details((r, p) => p.Equals(paramInfo) ? ServiceDetails.Of(getArgValue(r)) : null);
                    hasCustomValue = true;
                }
                else // handle service details
                {
                    var defaultValue = paramInfo.IsOptional ? paramInfo.DefaultValue : null;
                    var argDetails = GetArgServiceDetails(wholeServiceExpr,
                        methodCallExpr, paramInfo.ParameterType, IfUnresolved.Throw, defaultValue);
                    paramSelector = paramSelector.Details((r, p) => p.Equals(paramInfo) ? argDetails : null);
                }
            }
            else
            {
                var customValue = GetArgExpressionValueOrThrow(wholeServiceExpr, argExprs[i]);
                paramSelector = paramSelector.Details((r, p) => p.Equals(paramInfo) ? ServiceDetails.Of(customValue) : null);
            }
        }
        return paramSelector;
    }

    private static PropertiesAndFieldsSelector ComposePropertiesAndFieldsSelector(ref bool hasCustomValue,
        System.Linq.Expressions.Expression wholeServiceExpr, IList<System.Linq.Expressions.MemberBinding> memberBindings,
        params Func<Request, object>[] argValues)
    {
        var propertiesAndFields = DryIoc.PropertiesAndFields.Of;
        for (var i = 0; i < memberBindings.Count; i++)
        {
            var memberAssignment = (memberBindings[i] as System.Linq.Expressions.MemberAssignment).ThrowIfNull();
            var member = memberAssignment.Member;

            var methodCallExpr = memberAssignment.Expression as System.Linq.Expressions.MethodCallExpression;
            if (methodCallExpr == null) // not an Arg.Of: e.g. constant or variable
            {
                var customValue = GetArgExpressionValueOrThrow(wholeServiceExpr, memberAssignment.Expression);
                propertiesAndFields = propertiesAndFields.OverrideWith(r =>
                    PropertyOrFieldServiceInfo.Of(member).WithDetails(ServiceDetails.Of(customValue)).One());
            }
            else
            {
                Throw.If(methodCallExpr.Method.DeclaringType != typeof(Arg),
                    Error.UnexpectedExpressionInsteadOfArgMethodInMadeOf, methodCallExpr, wholeServiceExpr);

                if (methodCallExpr.Method.Name == Arg.ArgIndexMethodName) // handle custom value
                {
                    var getArgValue = GetArgCustomValueProvider(wholeServiceExpr, methodCallExpr, argValues);
                    propertiesAndFields = propertiesAndFields.OverrideWith(req =>
                        PropertyOrFieldServiceInfo.Of(member).WithDetails(ServiceDetails.Of(getArgValue(req))).One());
                    hasCustomValue = true;
                }
                else
                {
                    var memberType = member.GetReturnTypeOrDefault();
                    var argServiceDetails = GetArgServiceDetails(wholeServiceExpr, methodCallExpr, memberType, IfUnresolved.ReturnDefault, null);
                    propertiesAndFields = propertiesAndFields.OverrideWith(r =>
                        PropertyOrFieldServiceInfo.Of(member).WithDetails(argServiceDetails).One());
                }
            }
        }
        return propertiesAndFields;
    }

    private static Func<Request, object> GetArgCustomValueProvider(
        System.Linq.Expressions.Expression wholeServiceExpr,
        System.Linq.Expressions.MethodCallExpression methodCallExpr, Func<Request, object>[] argValues)
    {
        Throw.If(argValues.IsNullOrEmpty(), Error.ArgValueIndexIsProvidedButNoArgValues, wholeServiceExpr);

        var argIndex = (int)GetArgExpressionValueOrThrow(wholeServiceExpr, methodCallExpr.Arguments[0]);
        if (argIndex < 0 || argIndex >= argValues.Length)
            Throw.It(Error.ArgValueIndexIsOutOfProvidedArgValues, argIndex, argValues, wholeServiceExpr);

        return argValues[argIndex];
    }

    private static ServiceDetails GetArgServiceDetails(
        System.Linq.Expressions.Expression wholeServiceExpr,
        System.Linq.Expressions.MethodCallExpression methodCallExpr,
        Type dependencyType, IfUnresolved defaultIfUnresolved, object defaultValue)
    {
        var requiredServiceType = methodCallExpr.Method.GetGenericArguments().Last();
        if (requiredServiceType == dependencyType)
            requiredServiceType = null;

        var serviceKey = default(object);
        var metadataKey = default(string);
        var metadata = default(object);
        var ifUnresolved = defaultIfUnresolved;

        var hasPrevArg = false;

        var argExprs = methodCallExpr.Arguments;
        if (argExprs.Count == 2 &&
            argExprs[0].Type == typeof(string) &&
            argExprs[1].Type != typeof(IfUnresolved)) // matches the Of overload for metadata
        {
            metadataKey = (string)GetArgExpressionValueOrThrow(wholeServiceExpr, argExprs[0]);
            metadata = GetArgExpressionValueOrThrow(wholeServiceExpr, argExprs[1]);
        }
        else
        {
            for (var a = 0; a < argExprs.Count; a++)
            {
                var argValue = GetArgExpressionValueOrThrow(wholeServiceExpr, argExprs[a]);
                if (argValue != null)
                {
                    if (argValue is IfUnresolved)
                    {
                        ifUnresolved = (IfUnresolved)argValue;
                        if (hasPrevArg) // the only possible argument is default value.
                        {
                            defaultValue = serviceKey;
                            serviceKey = null;
                        }
                    }
                    else
                    {
                        serviceKey = argValue;
                        hasPrevArg = true;
                    }
                }
            }
        }

        return ServiceDetails.Of(requiredServiceType, serviceKey, ifUnresolved, defaultValue, metadataKey, metadata);
    }

    private static object GetArgExpressionValueOrThrow(
        System.Linq.Expressions.Expression wholeServiceExpr,
        System.Linq.Expressions.Expression argExpr)
    {
        var valueExpr = argExpr as System.Linq.Expressions.ConstantExpression;
        if (valueExpr != null)
            return valueExpr.Value;

        var convert = argExpr as System.Linq.Expressions.UnaryExpression; // e.g. (object)SomeEnum.Value
        if (convert != null && convert.NodeType == ExprType.Convert)
            return GetArgExpressionValueOrThrow(wholeServiceExpr,
                convert.Operand as System.Linq.Expressions.ConstantExpression);

        var member = argExpr as System.Linq.Expressions.MemberExpression;
        if (member != null)
        {
            var memberOwner = member.Expression as System.Linq.Expressions.ConstantExpression;
            if (memberOwner != null && memberOwner.Type.IsClosureType() && member.Member is FieldInfo)
                return ((FieldInfo)member.Member).GetValue(memberOwner.Value);
        }

        var newArrExpr = argExpr as System.Linq.Expressions.NewArrayExpression;
        if (newArrExpr != null)
        {
            var itemExprs = newArrExpr.Expressions;
            var items = new object[itemExprs.Count];
            for (var i = 0; i < itemExprs.Count; i++)
                items[i] = GetArgExpressionValueOrThrow(wholeServiceExpr, itemExprs[i]);

            return Converter.ConvertMany(items, newArrExpr.Type.GetElementType());
        }

        return Throw.For<object>(Error.UnexpectedExpressionInsteadOfConstantInMadeOf,
            argExpr, wholeServiceExpr);
    }
}

/// <summary>Class for defining parameters/properties/fields service info in <see cref="Made"/> expressions.
/// Arg methods are NOT actually called, they just used to reflect service info from call expression.</summary>
public static class Arg
{
    /// <summary>Specifies required service type of parameter or member. If required type is the same as parameter/member type,
    /// the method is just a placeholder to help detect constructor or factory method, and does not have additional meaning.</summary>
    public static TRequired Of<TRequired>() => default(TRequired);

    /// <summary>Specifies both service and required service types.</summary>
    public static TService Of<TService, TRequired>() => default(TService);

    /// <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy.</summary>
    public static TRequired Of<TRequired>(IfUnresolved ifUnresolved) => default(TRequired);

    /// <summary>Specifies both service and required service types.</summary>
    public static TService Of<TService, TRequired>(IfUnresolved ifUnresolved) => default(TService);

    /// <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
    public static TRequired Of<TRequired>(object serviceKey) => default(TRequired);

    /// <summary>Specifies both service and required service types.</summary>
    public static TService Of<TService, TRequired>(object serviceKey) => default(TService);

    /// <summary>Specifies required service type of parameter or member. Plus specifies service key.</summary>
    public static TRequired Of<TRequired>(string metadataKey, object metadata) => default(TRequired);

    /// <summary>Specifies both service and required service types.</summary>
    public static TService Of<TService, TRequired>(string metadataKey, object metadata) => default(TService);

    /// <summary>Specifies required service type of parameter or member. Plus specifies if-unresolved policy. Plus specifies service key.</summary>
    public static TRequired Of<TRequired>(IfUnresolved ifUnresolved, object serviceKey) => default(TRequired);

    /// <summary>Specifies both service and required service types.</summary>
    public static TService Of<TService, TRequired>(IfUnresolved ifUnresolved, object serviceKey) => default(TService);

    /// <summary>Specifies required service type, default value and <see cref="IfUnresolved.ReturnDefault"/>.</summary>
    public static TRequired Of<TRequired>(TRequired defaultValue, IfUnresolved ifUnresolved) => default(TRequired);

    /// <summary>Specifies required service type, default value and <see cref="IfUnresolved.ReturnDefault"/>.</summary>
    public static TRequired Of<TRequired>(TRequired defaultValue, IfUnresolved ifUnresolved, object serviceKey) => default(TRequired);

    /// <summary>Specifies argument index starting from 0 to use corresponding custom value factory,
    /// similar to String.Format <c>"{0}, {1}, etc"</c>.</summary>
    public static T Index<T>(int argIndex) => default(T);

    /// <summary>Name is close to method itself to not forget when renaming the method.</summary>
    public static string ArgIndexMethodName = "Index";
}

/// <summary>Contains <see cref="IRegistrator"/> extension methods to simplify general use cases.</summary>
public static class Registrator
{
    // todo: @feature We may need the paired DefaultKey to request/filter collections by default key, because AnyKey does not include DefaultKey
    /// <summary>When registered with it, the the service can be resolved any service key provided</summary>
    public static readonly object AnyKey = new AnyServiceKey();
    /// <summary>Wrap the resolution key</summary>
    public static object AnyKeyOfResolutionKey(object key) => new AnyServiceKey(key);

    // todo: @wip add IConvertibleToExpression impl
    /// <summary>Represents the **registered** key that you may resolve with any resolution service key</summary>
    public class AnyServiceKey
    {
        /// <summary>The resolution key supplied in the Resolve</summary>
        public readonly object ResolutionKey;
        internal AnyServiceKey(object resolutionKey = null) => ResolutionKey = resolutionKey;
        /// <inheritdoc />
        public override bool Equals(object obj) =>
            obj != null && obj is not DefaultKey && obj is not DefaultDynamicKey;
        /// <inheritdoc />
        public override int GetHashCode() => -1;
        /// <inheritdoc />
        public override string ToString() => ResolutionKey == null ? "AnyKey(*)" : $"AnyKey(resolutionKey: {ResolutionKey})";
    }

    /// <summary>Matches all combinations of the key wrappers.</summary>
    public static bool MatchToNotNullRegisteredKey(this object resolutionKey, object registeredKey)
    {
        Debug.Assert(registeredKey != null);

        // first try to unpack the key-required type pair
        if (resolutionKey is ServiceKeyAndRequiredOpenGenericType keyAndType)
            resolutionKey = keyAndType.ServiceKey;

        // check fore the default keys
        if (resolutionKey == null)
            return registeredKey is DefaultKey | registeredKey is DefaultDynamicKey;

        // now, the keys should match exactly for the resolution key already wrapped in the a... wrapper, 
        // which probably come here from the collection or other wrapper
        if (resolutionKey is UniqueRegisteredServiceKey resolutionUniqueKey)
        {
            // the Index == 0 is the special case for the wrapper of the first key from multiple
            if (resolutionUniqueKey.Index == 0)
                return registeredKey is not UniqueRegisteredServiceKey
                    && registeredKey.Equals(resolutionUniqueKey.ServiceKey);

            return registeredKey is UniqueRegisteredServiceKey regUniqueKey
                && UniqueRegisteredServiceKey.Equals(regUniqueKey, resolutionUniqueKey);
        }

        // next, unwrap the registered key if it is wrapped
        if (registeredKey is UniqueRegisteredServiceKey registeredUniqueKey)
            registeredKey = registeredUniqueKey.ServiceKey;

        if (resolutionKey is Registrator.AnyServiceKey anyResolutionKey)
        {
            // here is the resolution key wrapped in AnyKey in the collection wrapper, to propagate the resolution key further
            // it should be matched only with Any registered key and not with the arbitrary non-default key.
            if (anyResolutionKey.ResolutionKey != null)
                return registeredKey is Registrator.AnyServiceKey;

            // otherwise it's enough to be non-default to match with Any resolution key 
            return registeredKey is not DefaultKey & registeredKey is not DefaultDynamicKey;
        }

        return registeredKey.Equals(resolutionKey);
    }

    /// <summary>The base method for registering service with its implementation factory. Allows to specify all possible options.</summary>
    public static void Register(this IRegistrator registrator, Type serviceType, Factory factory,
        IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        registrator.Register(factory, serviceType, serviceKey, ifAlreadyRegistered, false);

    /// <summary>Registers service <paramref name="serviceType"/> with corresponding <paramref name="implementationType"/>.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static void Register(this IRegistrator registrator, Type serviceType, Type implementationType, IReuse reuse) =>
        registrator.Register(ReflectionFactory.Of(implementationType, reuse), serviceType, null, null, false);

    /// <summary>Registers service <paramref name="serviceType"/> with corresponding <paramref name="implementationType"/>.</summary>
    public static void Register(this IRegistrator registrator, Type serviceType, Type implementationType,
        IReuse reuse = null, Made made = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null,
        object serviceKey = null) =>
        registrator.Register(ReflectionFactory.Of(implementationType, reuse, made, setup),
            serviceType, serviceKey, ifAlreadyRegistered, false);

    /// <summary>Registers service of <paramref name="serviceAndMayBeImplementationType"/>.
    /// ServiceType may be the same as <paramref name="serviceAndMayBeImplementationType"/>.</summary>
    public static void Register(this IRegistrator registrator, Type serviceAndMayBeImplementationType,
        IReuse reuse = null, Made made = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null,
        object serviceKey = null) =>
        registrator.Register(ReflectionFactory.Of(serviceAndMayBeImplementationType, reuse, made, setup),
            serviceAndMayBeImplementationType, serviceKey, ifAlreadyRegistered, false);

    /// <summary>Registers service of <typeparamref name="TService"/> type
    /// implemented by <typeparamref name="TImplementation"/> type.</summary>
    public static void Register<TService, TImplementation>(this IRegistrator registrator,
        IReuse reuse = null, Made made = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null,
        object serviceKey = null)
        where TImplementation : TService =>
        registrator.Register(ReflectionFactory.Of(typeof(TImplementation), reuse, made, setup),
            typeof(TService), serviceKey, ifAlreadyRegistered, isStaticallyChecked: true);

    /// <summary>Registers implementation type <typeparamref name="TImplementation"/> with itself as service type.</summary>
    public static void Register<TImplementation>(this IRegistrator registrator,
        IReuse reuse = null, Made made = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null,
        object serviceKey = null) =>
        registrator.Register(ReflectionFactory.Of(typeof(TImplementation), reuse, made, setup),
            typeof(TImplementation), serviceKey, ifAlreadyRegistered, isStaticallyChecked: true);

    /// <summary>Registers service type returned by Made expression.</summary>
    public static void Register<TService, TMadeResult>(this IRegistrator registrator,
        Made.TypedMade<TMadeResult> made, IReuse reuse = null, Setup setup = null,
        IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) where TMadeResult : TService =>
        registrator.Register(ReflectionFactory.Of(default(Type), reuse, made, setup),
            typeof(TService), serviceKey, ifAlreadyRegistered, isStaticallyChecked: true);

    /// <summary>Registers service returned by Made expression.</summary>
    public static void Register<TService>(this IRegistrator registrator,
        Made.TypedMade<TService> made, IReuse reuse = null, Setup setup = null,
        IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        registrator.Register<TService, TService>(made, reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>
    /// Registers the instance creating a "normal" DryIoc registration so you can check it via `IsRegistered`, 
    /// apply wrappers and decorators, etc.
    /// Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
    /// Look at the `Use` method to put instance directly into current or singleton scope,
    /// though without ability to use decorators and wrappers on it.
    /// </summary>
    public static void RegisterInstance(this IRegistrator registrator, bool isChecked, Type serviceType, object instance,
        IfAlreadyRegistered? ifAlreadyRegistered = null, Setup setup = null, object serviceKey = null)
    {
        registrator.Register(InstanceFactory.Of(instance, setup),
            serviceType, serviceKey, ifAlreadyRegistered, isStaticallyChecked: isChecked);
        registrator.TrackDisposable(instance, setup);
    }

    /// <summary>Tracks the disposable instance in the singleton scope</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static void TrackDisposable(this IRegistrator registrator, object instance)
    {
        if (instance is IDisposable d)
            ((IResolverContext)registrator).SingletonScope.TrackDisposable(d);
    }

    /// <summary>Tracks the disposable instance in the singleton scope</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static void TrackDisposable(this IRegistrator registrator, object instance, Setup setup)
    {
        if (instance is IDisposable d && (setup == null || (!setup.PreventDisposal && !setup.WeaklyReferenced)))
            ((IResolverContext)registrator).SingletonScope.TrackDisposable(d);
    }

    /// <summary>
    /// Registers the instance creating a "normal" DryIoc registration so you can check it via `IsRegistered`, 
    /// apply wrappers and decorators, etc.
    /// Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
    /// Look at the `Use` method to put instance directly into current or singleton scope,
    /// though without ability to use decorators and wrappers on it.
    /// </summary>
    public static void RegisterInstance(this IRegistrator registrator, Type serviceType, object instance,
        IfAlreadyRegistered? ifAlreadyRegistered = null, Setup setup = null, object serviceKey = null) =>
        registrator.RegisterInstance(false, serviceType, instance, ifAlreadyRegistered, setup, serviceKey);

    /// <summary>
    /// Registers the instance creating a "normal" DryIoc registration so you can check it via `IsRegistered`, 
    /// apply wrappers and decorators, etc.
    /// Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
    /// Look at the `Use` method to put instance directly into current or singleton scope,
    /// though without ability to use decorators and wrappers on it.
    /// </summary>
    public static void RegisterInstance<T>(this IRegistrator registrator, T instance,
        IfAlreadyRegistered? ifAlreadyRegistered = null, Setup setup = null, object serviceKey = null) =>
        registrator.RegisterInstance(true, typeof(T), instance, ifAlreadyRegistered, setup, serviceKey);

    /// <summary>
    /// Registers the instance with possible multiple service types creating a "normal" DryIoc registration 
    /// so you can check it via `IsRegistered` for each service type, 
    /// apply wrappers and decorators, etc.
    /// Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
    /// Look at the `Use` method to put instance directly into current or singleton scope,
    /// though without ability to use decorators and wrappers on it.
    /// </summary>
    public static void RegisterInstanceMany(this IRegistrator registrator, Type implType, object instance,
        bool nonPublicServiceTypes = false, IfAlreadyRegistered? ifAlreadyRegistered = null, Setup setup = null, object serviceKey = null)
    {
        instance.ThrowIfNull();
        if (implType != null)
            instance.ThrowIfNotInstanceOf(implType);
        else
            implType = instance.GetType();

        var serviceTypes = implType.GetImplementedServiceTypes(nonPublicServiceTypes);

        if (serviceTypes.Length == 0)
            Throw.It(Error.NoServicesWereRegisteredByRegisterMany, implType.One());

        var factory = InstanceFactory.Of(instance, setup);
        foreach (var serviceType in serviceTypes)
            registrator.Register(factory, serviceType, serviceKey, ifAlreadyRegistered, isStaticallyChecked: true);

        if (instance is IDisposable d &&
            (setup == null || (!setup.PreventDisposal && !setup.WeaklyReferenced)))
            (registrator as IResolverContext)?.SingletonScope.TrackDisposable(d);
    }

    /// <summary>
    /// Registers the instance with possible multiple service types creating a "normal" DryIoc registration 
    /// so you can check it via `IsRegistered` for each service type, 
    /// apply wrappers and decorators, etc.
    /// Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
    /// Look at the `Use` method to put instance directly into current or singleton scope,
    /// though without ability to use decorators and wrappers on it.
    /// </summary>
    public static void RegisterInstanceMany<T>(this IRegistrator registrator, T instance,
        bool nonPublicServiceTypes = false,
        IfAlreadyRegistered? ifAlreadyRegistered = null, Setup setup = null, object serviceKey = null) =>
        registrator.RegisterInstanceMany(instance.GetType(), instance,
            nonPublicServiceTypes, ifAlreadyRegistered, setup, serviceKey);

    /// <summary>
    /// Registers the instance with possible multiple service types creating a "normal" DryIoc registration 
    /// so you can check it via `IsRegistered` for each service type, 
    /// apply wrappers and decorators, etc.
    /// Additionally, if instance is `IDisposable`, then it tracks it in a singleton scope.
    /// Look at the `Use` method to put instance directly into current or singleton scope,
    /// though without ability to use decorators and wrappers on it.
    /// </summary>
    public static void RegisterInstanceMany(this IRegistrator registrator, Type[] serviceTypes, object instance,
        IfAlreadyRegistered? ifAlreadyRegistered = null, Setup setup = null, object serviceKey = null)
    {
        var instanceType = instance.GetType();
        if (serviceTypes.IsNullOrEmpty())
            Throw.It(Error.NoServicesWereRegisteredByRegisterMany, instance);

        var factory = InstanceFactory.Of(instance, setup);

        foreach (var serviceType in serviceTypes)
        {
            serviceType.ThrowIfNotImplementedBy(instanceType);
            registrator.Register(factory, serviceType, serviceKey, ifAlreadyRegistered, isStaticallyChecked: true);
        }

        if (instance is IDisposable d &&
            (setup == null || (!setup.PreventDisposal && !setup.WeaklyReferenced)))
            (registrator as IResolverContext)?.SingletonScope.TrackDisposable(d);
    }

    /// <summary>Checks some common .NET types to exclude.</summary>
    public static bool IsExcludedGeneralPurposeServiceType(this Type type)
    {
        if (type == typeof(object))
            return true;
        if (type == typeof(string))
            return true;
        if (type == typeof(IDisposable))
            return true;
        if (type == typeof(IComparable))
            return true;
#if SUPPORTS_SERIALIZABLE
        if (type == typeof(System.Runtime.Serialization.ISerializable))
            return true;
#endif
#if SUPPORTS_ICLONEABLE
        if (type == typeof(ICloneable))
            return true;
#endif
        if (type.IsGenericType)
        {
            var genType = type.GetGenericTypeDefinition();
            if (genType == typeof(IEquatable<>))
                return true;
        }
        return false;
    }

    /// <summary>Checks that type can be used a service type.</summary>
    public static bool IsServiceType(this Type type) =>
        !type.IsPrimitive() && !type.IsExcludedGeneralPurposeServiceType() && !type.IsCompilerGenerated();

    /// <summary>Checks if type can be used as implementation type for reflection factory,
    /// and therefore registered to container. Usually used to discover implementation types from assembly.</summary>
    public static bool IsImplementationType(this Type type) =>
        type.IsClass && !type.IsAbstract && !type.IsCompilerGenerated();

    /// <summary>Returns only those types that could be used as service types of <paramref name="type"/>.
    /// It means that for open-generic <paramref name="type"/> its service type should supply all type arguments.</summary>
    public static Type[] GetImplementedServiceTypes(this Type type, bool nonPublicServiceTypes = false)
    {
        var implementedTypes = type.GetImplementedTypes(ReflectionTools.AsImplementedType.SourceType);

        var serviceTypes = nonPublicServiceTypes
            ? implementedTypes.Match(t => t.IsServiceType())
            : implementedTypes.Match(t => t.IsPublicOrNestedPublic() && t.IsServiceType());

        if (type.IsGenericTypeDefinition)
        {
            Type[] typeArgs = null;
            var serviceTypesCount = 0;
            for (var i = 0; i < serviceTypes.Length; ++i)
            {
                var serviceType = serviceTypes[i];
                // we don't need to check the source type, because it already matches itself
                if (serviceType != type)
                {
                    typeArgs ??= type.GetGenericArguments();
                    if (!serviceType.ContainsAllGenericTypeParameters(typeArgs))
                    {
                        serviceTypes[i] = null;
                        continue;
                    }
                }
                ++serviceTypesCount;
                serviceTypes[i] = serviceType.GetGenericTypeDefinition();
            }

            if (serviceTypesCount == 0)
                return ArrayTools.Empty<Type>();
            if (serviceTypesCount == serviceTypes.Length)
                return serviceTypes;
            var filteredServiceTypes = new Type[serviceTypesCount];
            var j = 0;
            foreach (var t in serviceTypes)
                if (t != null)
                    filteredServiceTypes[j++] = t;
            return filteredServiceTypes;
        }

        return serviceTypes;
    }

    // todo: @bug @perf why don't we just use IsAssignableFrom
    /// <summary>The same `GetImplementedServiceTypes` but instead of collecting the service types just check the <paramref name="serviceType"/> is implemented</summary>
    public static bool IsImplementingServiceType(this Type type, Type serviceType)
    {
        if (serviceType == type || serviceType == typeof(object))
            return true;

        if (!type.IsGenericTypeDefinition)
        {
            if (serviceType.IsInterface)
            {
                var array = type.GetInterfaces();
                for (var i = 0; i < array.Length; i++)
                {
                    var iface = array[i];
                    if (iface == serviceType)
                        return true;
                }
            }
            else
            {
                var baseType = type.BaseType;
                for (; baseType != null && baseType != typeof(object); baseType = baseType.BaseType)
                    if (serviceType == baseType)
                        return true;
            }
        }
        else if (serviceType.IsGenericTypeDefinition)
        {
            var implTypeParams = type.GetGenericArguments();
            if (serviceType.IsInterface)
            {
                foreach (var iface in type.GetInterfaces())
                    if (iface.IsGenericType && iface.GetGenericTypeDefinition() == serviceType &&
                        iface.ContainsAllGenericTypeParameters(implTypeParams))
                        return true;
            }
            else
            {
                var baseType = type.BaseType;
                for (; baseType != null && baseType != typeof(object); baseType = baseType.BaseType)
                    if (baseType.IsGenericType && baseType.GetGenericTypeDefinition() == serviceType &&
                        baseType.ContainsAllGenericTypeParameters(implTypeParams))
                        return true;
            }
        }

        return false;
    }

    /// <summary>Returns the sensible services automatically discovered for RegisterMany implementation type.
    /// Excludes the collection wrapper interfaces. The <paramref name="type"/> may be concrete, abstract or
    /// generic definition.</summary>
    public static Type[] GetRegisterManyImplementedServiceTypes(this Type type, bool nonPublicServiceTypes = false) =>
        GetImplementedServiceTypes(type, nonPublicServiceTypes)
            .Match(t => !t.IsGenericTypeDefinition || WrappersSupport.SupportedCollectionTypes.IndexOf(t, default(RefEq<Type>)) == -1);

    /// <summary>Returns the types suitable to be an implementation types for <see cref="ReflectionFactory"/>:
    /// actually a non abstract and not compiler generated classes.</summary>
    public static IEnumerable<Type> GetImplementationTypes(this Assembly assembly) =>
        Portable.GetAssemblyTypes(assembly).Where(IsImplementationType);

    /// <summary>Returns the types suitable to be an implementation types for <see cref="ReflectionFactory"/>:
    /// actually a non abstract and not compiler generated classes.</summary>
    public static IEnumerable<Type> GetImplementationTypes(this Assembly assembly, Func<Type, bool> condition) =>
        Portable.GetAssemblyTypes(assembly).Match(condition, static (cond, t) => cond(t) && t.IsImplementationType());

    /// <summary>Sugar, so you can say <code lang="cs"><![CDATA[r.RegisterMany<X>(Registrator.Interfaces)]]></code></summary>
    public static Func<Type, bool> Interfaces = x => x.IsInterface;

    /// <summary>Checks if <paramref name="type"/> implements a service type,
    /// along the checking if <paramref name="type"/> is a valid implementation type.</summary>
    public static bool ImplementsServiceType(this Type type, Type serviceType) =>
        type.IsImplementationType() && type.IsImplementingServiceType(serviceType);

    /// <summary>Checks if <paramref name="type"/> implements a service type,
    /// along the checking if <paramref name="type"/> and service type
    /// are valid implementation and service types.</summary>
    public static bool ImplementsServiceType<TService>(this Type type) =>
        type.ImplementsServiceType(typeof(TService));

    /// <summary>Wraps the implementation type in factory.</summary>
    public static ReflectionFactory ToFactory(this Type implType) =>
        ReflectionFactory.Of(implType);

    /// <summary>Wraps the implementation type in factory plus allow to provide factory parameters.</summary>
    public static ReflectionFactory ToFactory(this Type implType, IReuse reuse = null, Made made = null, Setup setup = null) =>
        ReflectionFactory.Of(implType, reuse, made, setup);

    /// <summary>
    /// Batch registering the implementations with possibly many service types,
    /// throwing the <see cref="Error.NoServicesWereRegisteredByRegisterMany" /> error when there are no services types to register.
    /// You may pass the predefined <see cref="GetRegisterManyImplementedServiceTypes"/> to <paramref name="getServiceTypes"/>.
    /// By default <paramref name="getImplFactory"/> uses the <see cref="ReflectionFactory"/> with the default reuse,
    /// or you may return the <see cref="ReflectionFactory"/> with the <see cref="Reuse"/> of your choice.
    /// </summary>
    public static void RegisterMany(this IRegistrator registrator,
        IEnumerable<Type> implTypes,
        Func<Type, Type[]> getServiceTypes,
        Func<Type, Factory> getImplFactory = null,
        Func<Type, Type, object> getServiceKey = null,
        IfAlreadyRegistered? ifAlreadyRegistered = null)
    {
        getImplFactory = getImplFactory ?? ToFactory;
        var rules = registrator.Rules;
        var isSomethingRegistered = false;
        var anyImplTypes = false;
        foreach (var implType in implTypes)
        {
            anyImplTypes = true;
            var serviceTypes = getServiceTypes(implType);
            if (!serviceTypes.IsNullOrEmpty())
            {
                var factory = getImplFactory(implType);
                for (var i = 0; i < serviceTypes.Length; i++)
                {
                    var t = serviceTypes[i];
                    var k = getServiceKey?.Invoke(implType, t);
                    if (factory.ValidateAndNormalizeRegistration(t, k, false, rules, false))
                    {
                        registrator.RegisterWithoutValidation(factory, t, k, ifAlreadyRegistered);
                        isSomethingRegistered = true;
                    }
                }
            }
        }
        if (anyImplTypes && !isSomethingRegistered)
            Throw.It(Error.NoServicesWereRegisteredByRegisterMany, implTypes);
    }

    // todo: @wip do we really need this method?
    /// <summary>
    /// Batch registering the implementations with possibly many service types,
    /// ignoring the case when there are no services types to register.
    /// You may pass the predefined <see cref="GetRegisterManyImplementedServiceTypes"/> to <paramref name="getServiceTypes"/>.
    /// By default <paramref name="getImplFactory"/> uses the <see cref="ReflectionFactory"/> with the default reuse,
    /// or you may return the <see cref="ReflectionFactory"/> with the <see cref="Reuse"/> of your choice.
    /// </summary>
    public static void RegisterManyIgnoreNoServicesWereRegistered(this IRegistrator registrator,
        IEnumerable<Type> implTypes,
        Func<Type, Type[]> getServiceTypes,
        Func<Type, Factory> getImplFactory = null,
        Func<Type, Type, object> getServiceKey = null,
        IfAlreadyRegistered? ifAlreadyRegistered = null)
    {
        getImplFactory = getImplFactory ?? ToFactory;
        foreach (var implType in implTypes)
        {
            var serviceTypes = getServiceTypes(implType);
            if (!serviceTypes.IsNullOrEmpty())
            {
                var factory = getImplFactory(implType);
                foreach (var st in serviceTypes)
                {
                    // todo: @wip do we need to validate the registration?
                    registrator.Register(st, factory, ifAlreadyRegistered, getServiceKey?.Invoke(implType, st));
                }
            }
        }
    }

    /// <summary>Batch registers implementation with possibly many service types.</summary>
    public static void RegisterMany(this IRegistrator registrator,
        Type[] serviceTypes, Type implType,
        IReuse reuse = null, Made made = null, Setup setup = null,
        IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null)
    {
        var rules = registrator.Rules;
        var isSomethingRegistered = false;
        if (!serviceTypes.IsNullOrEmpty())
        {
            var factory = implType.ToFactory(reuse, made, setup);
            foreach (var t in serviceTypes)
                if (factory.ValidateAndNormalizeRegistration(t, serviceKey, false, rules, false))
                {
                    registrator.RegisterWithoutValidation(factory, t, serviceKey, ifAlreadyRegistered);
                    isSomethingRegistered = true;
                }
        }
        if (!isSomethingRegistered)
            Throw.It(Error.NoServicesWereRegisteredByRegisterMany, implType);
    }

    /// <summary>Batch registers assemblies of implementation types with possibly many service types.
    /// The default factory is the <see cref="ReflectionFactory"/> with default reuse.</summary>
    public static void RegisterMany(this IRegistrator registrator,
        IEnumerable<Assembly> implTypeAssemblies, Func<Type, Type[]> getServiceTypes,
        Func<Type, Factory> getImplFactory = null, Func<Type, Type, object> getServiceKey = null,
        IfAlreadyRegistered? ifAlreadyRegistered = null) =>
        registrator.RegisterMany(implTypeAssemblies.ThrowIfNull().SelectMany(GetImplementationTypes),
            getServiceTypes, getImplFactory, getServiceKey, ifAlreadyRegistered);

    /// <summary>Registers many implementations with their auto-figured service types.</summary>
    public static void RegisterMany(this IRegistrator registrator,
        IEnumerable<Assembly> implTypeAssemblies, Func<Type, bool> serviceTypeCondition,
        IReuse reuse = null, Made made = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null,
        bool nonPublicServiceTypes = false, object serviceKey = null) =>
        registrator.RegisterMany(implTypeAssemblies.ThrowIfNull().SelectMany(GetImplementationTypes),
            reuse, made, setup, ifAlreadyRegistered, serviceTypeCondition, nonPublicServiceTypes, serviceKey);

    /// <summary>Registers many implementations with auto-figured service types.</summary>
    public static void RegisterMany(this IRegistrator registrator, IEnumerable<Type> implTypes,
        IReuse reuse = null, Made made = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null,
        Func<Type, bool> serviceTypeCondition = null, bool nonPublicServiceTypes = false,
        object serviceKey = null) =>
        registrator.RegisterMany(implTypes,
            t => t.GetRegisterManyImplementedServiceTypes(nonPublicServiceTypes).Match(serviceTypeCondition ?? Fun.Always),
            reuse == null && made == null && setup == null ? default(Func<Type, Factory>) : t => t.ToFactory(reuse, made, setup),
            serviceKey == null ? default(Func<Type, Type, object>) : (i, s) => serviceKey,
            ifAlreadyRegistered);

    /// <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
    public static void RegisterMany<TImplementation>(this IRegistrator registrator,
        IReuse reuse = null, Made made = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null,
        Func<Type, bool> serviceTypeCondition = null, bool nonPublicServiceTypes = false,
        object serviceKey = null) =>
        registrator.RegisterMany(typeof(TImplementation).One(),
            reuse, made, setup, ifAlreadyRegistered, serviceTypeCondition, nonPublicServiceTypes, serviceKey);

    /// <summary>Registers single registration for all implemented public interfaces and base classes.</summary>
    public static void RegisterMany<TMadeResult>(this IRegistrator registrator,
        Made.TypedMade<TMadeResult> made,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null,
        Func<Type, bool> serviceTypeCondition = null, bool nonPublicServiceTypes = false,
        object serviceKey = null) =>
        registrator.RegisterMany<TMadeResult>(reuse, made.ThrowIfNull(), setup,
            ifAlreadyRegistered, serviceTypeCondition, nonPublicServiceTypes, serviceKey);

    /// Minimizes the number of allocations when converting from Func to named delegate
    public static object ToFactoryDelegate<TService>(this Func<IResolverContext, TService> f, IResolverContext r) => f(r);

    /// Lifts the result to the factory delegate without allocations on capturing value in lambda closure
    public static object ToFactoryDelegate(this object result, IResolverContext _) => result;

    internal static object WeakRefObjToFactoryDelegate(this object weakRefObj, IResolverContext _) =>
        (weakRefObj as WeakReference)?.Target.WeakRefReuseWrapperGCed();

    /// <summary>Registers a factory delegate for creating an instance of <typeparamref name="TService"/>.
    /// Delegate can use resolver context parameter to resolve any required dependencies, e.g.:
    /// <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
    /// <remarks>The alternative to this method please consider using <see cref="Made"/> instead:
    /// <code lang="cs"><![CDATA[container.Register<ICar>(Made.Of(() => new Car(Arg.Of<IEngine>())))]]></code>.
    /// </remarks>
    public static void RegisterDelegate<TService>(this IRegistrator registrator,
        Func<IResolverContext, TService> factoryDelegate,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null,
        object serviceKey = null) =>
        registrator.Register(DelegateFactory.Of(factoryDelegate.ToFactoryDelegate, reuse, setup),
            typeof(TService), serviceKey, ifAlreadyRegistered, isStaticallyChecked: true);

    private const string InvokeMethodName = "Invoke";
    private static object ToFuncWithObjResult<TService>(this Func<TService> f) => f();

    private static object ToFuncWithObjParams<D1, TService>(this Func<D1, TService> f, object d1) => f((D1)d1);
    private static Func<object, object> GetCheckedFuncWithObjParams<D1>(this Func<D1, object> f, Type serviceType) =>
        d1 => f((D1)d1).ThrowIfNotInstanceOf(serviceType, Error.RegisteredDelegateResultIsNotOfServiceType);

    /// <summary>Exposed for the MS.DI DryIocAdapter</summary>
    public static object ToFuncWithObjParams<D1, D2, TService>(this Func<D1, D2, TService> f,
        object d1, object d2) => f((D1)d1, (D2)d2);
    private static Func<object, object, object> GetCheckedFuncWithObjParams<D1, D2>(this Func<D1, D2, object> f, Type serviceType) =>
        (d1, d2) => f((D1)d1, (D2)d2).ThrowIfNotInstanceOf(serviceType, Error.RegisteredDelegateResultIsNotOfServiceType);

    private static object ToFuncWithObjParams<D1, D2, D3, TService>(this Func<D1, D2, D3, TService> f,
        object d1, object d2, object d3) => f((D1)d1, (D2)d2, (D3)d3);
    private static Func<object, object, object, object> GetCheckedFuncWithObjParams<D1, D2, D3>(this Func<D1, D2, D3, object> f, Type serviceType) =>
        (d1, d2, d3) => f((D1)d1, (D2)d2, (D3)d3).ThrowIfNotInstanceOf(serviceType, Error.RegisteredDelegateResultIsNotOfServiceType);

    private static object ToFuncWithObjParams<D1, D2, D3, D4, TService>(this Func<D1, D2, D3, D4, TService> f,
        object d1, object d2, object d3, object d4) => f((D1)d1, (D2)d2, (D3)d3, (D4)d4);
    private static Func<object, object, object, object, object> GetCheckedFuncWithObjParams<D1, D2, D3, D4>(this Func<D1, D2, D3, D4, object> f, Type serviceType) =>
        (d1, d2, d3, d4) => f((D1)d1, (D2)d2, (D3)d3, (D4)d4).ThrowIfNotInstanceOf(serviceType, Error.RegisteredDelegateResultIsNotOfServiceType);

    private static object ToFuncWithObjParams<D1, D2, D3, D4, D5, TService>(this Func<D1, D2, D3, D4, D5, TService> f,
        object d1, object d2, object d3, object d4, object d5) => f((D1)d1, (D2)d2, (D3)d3, (D4)d4, (D5)d5);
    private static Func<object, object, object, object, object, object> GetCheckedFuncWithObjParams<D1, D2, D3, D4, D5>(this Func<D1, D2, D3, D4, D5, object> f, Type serviceType) =>
        (d1, d2, d3, d4, d5) => f((D1)d1, (D2)d2, (D3)d3, (D4)d4, (D5)d5).ThrowIfNotInstanceOf(serviceType, Error.RegisteredDelegateResultIsNotOfServiceType);

    private static object ToFuncWithObjParams<D1, D2, D3, D4, D5, D6, TService>(this Func<D1, D2, D3, D4, D5, D6, TService> f,
        object d1, object d2, object d3, object d4, object d5, object d6) => f((D1)d1, (D2)d2, (D3)d3, (D4)d4, (D5)d5, (D6)d6);
    private static Func<object, object, object, object, object, object, object> GetCheckedFuncWithObjParams<D1, D2, D3, D4, D5, D6>(this Func<D1, D2, D3, D4, D5, D6, object> f, Type serviceType) =>
        (d1, d2, d3, d4, d5, d6) => f((D1)d1, (D2)d2, (D3)d3, (D4)d4, (D5)d5, (D6)d6).ThrowIfNotInstanceOf(serviceType, Error.RegisteredDelegateResultIsNotOfServiceType);

    private static object ToFuncWithObjParams<D1, D2, D3, D4, D5, D6, D7, TService>(this Func<D1, D2, D3, D4, D5, D6, D7, TService> f,
        object d1, object d2, object d3, object d4, object d5, object d6, object d7) => f((D1)d1, (D2)d2, (D3)d3, (D4)d4, (D5)d5, (D6)d6, (D7)d7);
    private static Func<object, object, object, object, object, object, object, object> GetCheckedFuncWithObjParams<D1, D2, D3, D4, D5, D6, D7>(this Func<D1, D2, D3, D4, D5, D6, D7, object> f, Type serviceType) =>
        (d1, d2, d3, d4, d5, d6, d7) => f((D1)d1, (D2)d2, (D3)d3, (D4)d4, (D5)d5, (D6)d6, (D7)d7).ThrowIfNotInstanceOf(serviceType, Error.RegisteredDelegateResultIsNotOfServiceType);

    private static void RegisterFunc(this IRegistrator r,
        Type serviceType, MethodInfo sourceFuncMethod, Delegate funcWithObjParams,
        IReuse reuse, Setup setup, IfAlreadyRegistered? ifAlreadyRegistered, object serviceKey)
    {
        var made = new Made(FactoryMethod.OfFunc(sourceFuncMethod, funcWithObjParams));
        var factory = ReflectionFactory.OfConcreteTypeAndMadeNoValidation(serviceType, made, reuse, setup);
        r.Register(factory, serviceType, serviceKey, ifAlreadyRegistered, isStaticallyChecked: true);
    }

    /// <summary>Registers delegate to be injected by container avoiding the ServiceLocator anti-pattern</summary>
    public static void RegisterDelegate<TService>(
        this IRegistrator r, Func<TService> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(typeof(TService), factory.Method, (Func<object>)factory.ToFuncWithObjResult,
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
    public static void RegisterDelegate<TDep1, TService>(
        this IRegistrator r, Func<TDep1, TService> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(typeof(TService), factory.Method, (Func<object, object>)factory.ToFuncWithObjParams,
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container and with object return type known Only at runtime</summary>
    public static void RegisterDelegate<TDep1>(
        this IRegistrator r, Type serviceType, Func<TDep1, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(serviceType, factory.Method, factory.GetCheckedFuncWithObjParams<TDep1>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container.
    /// The delegate accepts the object parameters with the runtime known types</summary>
    public static void RegisterDelegate(
        this IRegistrator r, Type serviceType, Type depType, Func<object, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null)
    {
        var invokeMethod = typeof(Func<,>).MakeGenericType(depType, typeof(object)).GetMethod(InvokeMethodName);
        r.RegisterFunc(serviceType, invokeMethod, factory.GetCheckedFuncWithObjParams<object>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);
    }

    /// <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
    public static void RegisterDelegate<TDep1, TDep2, TService>(
        this IRegistrator r, Func<TDep1, TDep2, TService> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(typeof(TService), factory.Method, (Func<object, object, object>)factory.ToFuncWithObjParams,
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container with object return type known Only at runtime</summary>
    public static void RegisterDelegate<TDep1, TDep2>(
        this IRegistrator r, Type serviceType, Func<TDep1, TDep2, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(serviceType, factory.Method, factory.GetCheckedFuncWithObjParams<TDep1, TDep2>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container.
    /// The delegate accepts the object parameters with the runtime known types</summary>
    public static void RegisterDelegate(
        this IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Func<object, object, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null)
    {
        var invokeMethod = typeof(Func<,,>).MakeGenericType(dep1Type, dep2Type, typeof(object)).GetMethod(InvokeMethodName);
        r.RegisterFunc(serviceType, invokeMethod, factory.GetCheckedFuncWithObjParams<object, object>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);
    }

    /// <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
    public static void RegisterDelegate<TDep1, TDep2, TDep3, TService>(
        this IRegistrator r, Func<TDep1, TDep2, TDep3, TService> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(typeof(TService), factory.Method, (Func<object, object, object, object>)factory.ToFuncWithObjParams,
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container with object return type known Only at runtime</summary>
    public static void RegisterDelegate<TDep1, TDep2, TDep3>(
        this IRegistrator r, Type serviceType, Func<TDep1, TDep2, TDep3, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(serviceType, factory.Method, factory.GetCheckedFuncWithObjParams<TDep1, TDep2, TDep3>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container.
    /// The delegate accepts the object parameters with the runtime known types</summary>
    public static void RegisterDelegate(
        this IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Type dep3Type, Func<object, object, object, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null)
    {
        var invokeMethod = typeof(Func<,,,>).MakeGenericType(dep1Type, dep2Type, dep3Type, typeof(object)).GetMethod(InvokeMethodName);
        r.RegisterFunc(serviceType, invokeMethod, factory.GetCheckedFuncWithObjParams<object, object, object>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);
    }

    /// <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
    public static void RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TService>(
        this IRegistrator r, Func<TDep1, TDep2, TDep3, TDep4, TService> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(typeof(TService), factory.Method, (Func<object, object, object, object, object>)factory.ToFuncWithObjParams,
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container with object return type known Only at runtime</summary>
    public static void RegisterDelegate<TDep1, TDep2, TDep3, TDep4>(
        this IRegistrator r, Type serviceType, Func<TDep1, TDep2, TDep3, TDep4, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(serviceType, factory.Method, factory.GetCheckedFuncWithObjParams<TDep1, TDep2, TDep3, TDep4>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container.
    /// The delegate accepts the object parameters with the runtime known types</summary>
    public static void RegisterDelegate(
        this IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Type dep3Type, Type dep4Type,
        Func<object, object, object, object, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null)
    {
        var invokeMethod = typeof(Func<,,,,>).MakeGenericType(dep1Type, dep2Type, dep3Type, dep4Type, typeof(object)).GetMethod(InvokeMethodName);
        r.RegisterFunc(serviceType, invokeMethod, factory.GetCheckedFuncWithObjParams<object, object, object, object>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);
    }

    /// <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
    public static void RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TDep5, TService>(
        this IRegistrator r, Func<TDep1, TDep2, TDep3, TDep4, TDep5, TService> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(typeof(TService), factory.Method, (Func<object, object, object, object, object, object>)factory.ToFuncWithObjParams,
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container with object return type known Only at runtime</summary>
    public static void RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TDep5>(
        this IRegistrator r, Type serviceType, Func<TDep1, TDep2, TDep3, TDep4, TDep5, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(serviceType, factory.Method, factory.GetCheckedFuncWithObjParams<TDep1, TDep2, TDep3, TDep4, TDep5>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container.
    /// The delegate accepts the object parameters with the runtime known types</summary>
    public static void RegisterDelegate(
        this IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Type dep3Type, Type dep4Type, Type dep5Type,
        Func<object, object, object, object, object, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null)
    {
        var invokeMethod = typeof(Func<,,,,,>).MakeGenericType(dep1Type, dep2Type, dep3Type, dep4Type, dep5Type, typeof(object)).GetMethod(InvokeMethodName);
        r.RegisterFunc(serviceType, invokeMethod, factory.GetCheckedFuncWithObjParams<object, object, object, object, object>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);
    }

    /// <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
    public static void RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TService>(
        this IRegistrator r, Func<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TService> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(typeof(TService), factory.Method, (Func<object, object, object, object, object, object, object>)factory.ToFuncWithObjParams,
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container with object return type known Only at runtime</summary>
    public static void RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6>(
        this IRegistrator r, Type serviceType, Func<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(serviceType, factory.Method, factory.GetCheckedFuncWithObjParams<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container.
    /// The delegate accepts the object parameters with the runtime known types</summary>
    public static void RegisterDelegate(
        this IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Type dep3Type, Type dep4Type, Type dep5Type, Type dep6Type,
        Func<object, object, object, object, object, object, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null)
    {
        var invokeMethod = typeof(Func<,,,,,,>).MakeGenericType(dep1Type, dep2Type, dep3Type, dep4Type, dep5Type, dep6Type, typeof(object)).GetMethod(InvokeMethodName);
        r.RegisterFunc(serviceType, invokeMethod, factory.GetCheckedFuncWithObjParams<object, object, object, object, object, object>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);
    }

    /// <summary>Registers delegate with explicit arguments to be injected by container avoiding the ServiceLocator anti-pattern</summary>
    public static void RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TDep7, TService>(
        this IRegistrator r, Func<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TDep7, TService> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(typeof(TService), factory.Method,
            (Func<object, object, object, object, object, object, object, object>)factory.ToFuncWithObjParams,
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container with object return type known Only at runtime</summary>
    public static void RegisterDelegate<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TDep7>(
        this IRegistrator r, Type serviceType, Func<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TDep7, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        r.RegisterFunc(serviceType, factory.Method,
            factory.GetCheckedFuncWithObjParams<TDep1, TDep2, TDep3, TDep4, TDep5, TDep6, TDep7>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);

    /// <summary>Registers delegate with the explicit arguments to be injected by container.
    /// The delegate accepts the object parameters with the runtime known types</summary>
    public static void RegisterDelegate(
        this IRegistrator r, Type serviceType, Type dep1Type, Type dep2Type, Type dep3Type, Type dep4Type, Type dep5Type, Type dep6Type, Type dep7Type,
        Func<object, object, object, object, object, object, object, object> factory,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null)
    {
        var invokeMethod = typeof(Func<,,,,,,,>).MakeGenericType(dep1Type, dep2Type, dep3Type, dep4Type, dep5Type, dep6Type, dep7Type, typeof(object))
            .GetMethod(InvokeMethodName);
        r.RegisterFunc(serviceType, invokeMethod, factory.GetCheckedFuncWithObjParams<object, object, object, object, object, object, object>(serviceType),
            reuse, setup, ifAlreadyRegistered, serviceKey);
    }

    /// <summary>Registers a factory delegate for creating an instance of <paramref name="serviceType"/>.
    /// Delegate can use resolver context parameter to resolve any required dependencies, e.g.:
    /// <code lang="cs"><![CDATA[container.RegisterDelegate<ICar>(r => new Car(r.Resolve<IEngine>()))]]></code></summary>
    /// <remarks>IMPORTANT: The method should be used as the last resort only! Though powerful it is a black-box for container,
    /// which prevents diagnostics, plus it is easy to get memory leaks (due variables captured in delegate closure),
    /// and impossible to use in compile-time scenarios.
    /// Consider using <see cref="Made"/> instead:
    /// <code lang="cs"><![CDATA[container.Register<ICar>(Made.Of(() => new Car(Arg.Of<IEngine>())))]]></code>
    /// </remarks>
    public static void RegisterDelegate(this IRegistrator registrator,
        Type serviceType, Func<IResolverContext, object> factoryDelegate,
        IReuse reuse = null, Setup setup = null, IfAlreadyRegistered? ifAlreadyRegistered = null,
        object serviceKey = null)
    {
        if (serviceType.IsOpenGeneric())
            Throw.It(Error.ImpossibleToRegisterOpenGenericWithRegisterDelegate, serviceType);

        var factory = DelegateFactory.Of(CheckedFactoryDelegate, reuse, setup);
        registrator.Register(factory, serviceType, serviceKey, ifAlreadyRegistered, isStaticallyChecked: false);

        object CheckedFactoryDelegate(IResolverContext r) =>
            factoryDelegate(r).ThrowIfNotInstanceOf(serviceType, Error.RegisteredDelegateResultIsNotOfServiceType);
    }

    ///<summary>Obsolete("Replaced with RegisterDelegate{MyService, Dep1...Dep2, MyService}((service, d1, d2) => new MyServiceDecorator(service, d1, d2), setup: Setup.DecoratorWith(useDecorateeReuse: true, condition: optional))")</summary>
    [Obsolete("Replaced with RegisterDelegate{MyService, Dep1...Dep2, MyService}((service, d1, d2) => new MyServiceDecorator(service, d1, d2), setup: Setup.DecoratorWith(useDecorateeReuse: true, condition: optional))")]
    public static void RegisterDelegateDecorator<TService>(this IRegistrator registrator,
        Func<IResolverContext, Func<TService, TService>> getDecorator, Func<Request, bool> condition = null)
    {
        getDecorator.ThrowIfNull();
        registrator.RegisterDelegate<IResolverContext, TService, TService>(
            (r, service) => getDecorator(r)(service),
            setup: condition == null
                ? Setup.DecoratorWith(useDecorateeReuse: true)
                : Setup.DecoratorWith(condition, useDecorateeReuse: true));
    }

    /// <summary>Adding the factory directly to scope for resolution</summary> 
    public static void Use<TService>(this IResolverContext r, Func<IResolverContext, TService> factory) =>
        r.Use(typeof(TService), (Func<IResolverContext, object>)factory.ToFactoryDelegate);

    /// <summary>Adding the factory directly to the scope for resolution</summary>
    public static void Use(this IResolverContext r, Type serviceType, Func<IResolverContext, object> factory) =>
        r.Use(serviceType, factory);

    /// <summary>Adding the factory directly to the scope for resolution</summary>
    public static void Use<TService>(this IResolverContext r, Func<IResolverContext, object> factory) => r.Use(typeof(TService), factory);

    /// <summary>Adding the instance directly to the scope for resolution</summary>
    public static void Use(this IResolverContext r, Type serviceType, object instance) => r.Use(serviceType, instance);

    /// <summary>Adding the instance directly to the scope for resolution</summary> 
    public static void Use<TService>(this IResolverContext r, TService instance) => r.Use(typeof(TService), instance);

    /// <summary>Adding the factory directly to the scope for resolution</summary>
    public static void Use<TService>(this IRegistrator r, Func<IResolverContext, TService> factory) => r.Use(typeof(TService), factory);

    /// <summary>Adding the factory directly to the scope for resolution</summary>
    public static void Use<TService>(this IRegistrator r, Func<IResolverContext, object> factory) => r.Use(typeof(TService), factory);

    /// <summary>Adding the factory directly to the scope for resolution</summary>
    public static void Use(this IRegistrator r, Type serviceType, Func<IResolverContext, object> factory) => r.Use(serviceType, factory);

    /// <summary>Adding the instance directly to scope for resolution</summary>
    public static void Use(this IRegistrator r, Type serviceType, object instance) => r.Use(serviceType, instance);

    /// <summary>Adding the instance directly to scope for resolution</summary> 
    public static void Use<TService>(this IRegistrator r, TService instance) => r.Use(typeof(TService), instance);

    /// <summary>Adding the factory directly to scope for resolution</summary> 
    public static void Use<TService>(this IContainer c, Func<IResolverContext, TService> factory) =>
        ((IResolverContext)c).Use(typeof(TService), factory);

    /// <summary>Adding the factory directly to scope for resolution</summary> 
    public static void Use<TService>(this IContainer c, Func<IResolverContext, object> factory) =>
        ((IResolverContext)c).Use(typeof(TService), factory);

    /// <summary>Adding the factory directly to scope for resolution</summary> 
    public static void Use(this IContainer c, Type serviceType, Func<IResolverContext, object> factory) =>
        ((IResolverContext)c).Use(serviceType, factory);

    /// <summary>Adding the instance directly to scope for resolution</summary>
    public static void Use(this IContainer c, Type serviceType, object instance) =>
        ((IResolverContext)c).Use(serviceType, instance);

    /// <summary>Adding the instance directly to scope for resolution</summary>
    public static void Use<TService>(this IContainer c, TService instance) =>
        ((IResolverContext)c).Use(typeof(TService), instance);

    /// <summary>
    /// Registers initializing action that will be called after service is resolved 
    /// just before returning it to the caller. You can register multiple initializers for a single service.
    /// Or you can register initializer for the <see cref="Object"/> type to be applied 
    /// for all services and use <paramref name="condition"/> to specify the target services.
    /// Note: The initializer action has the same reuse as a initialized (decorated) service.
    /// </summary>
    public static void RegisterInitializer<TTarget>(this IRegistrator registrator,
        Action<TTarget, IResolverContext> initialize, Func<Request, bool> condition = null) =>
        registrator.RegisterInitializer<TTarget>(initialize, null, condition);

    /// <summary>
    /// Registers initializing action that will be called after service is resolved 
    /// just before returning it to the caller. You can register multiple initializers for a single service.
    /// Or you can register initializer for the <see cref="Object"/> type to be applied 
    /// for all services and use <paramref name="condition"/> to specify the target services.
    /// Note: You may specify a <paramref name="reuse"/> different from the initialized object enabling the
    /// <paramref name="initialize"/> action to run once (Singleton), run once-per-scope (Scoped), run always (Transient).
    /// Note2: By convention the initializer is not applied for wrappers (collections, Func, Lazy, etc.). If you need this you may directly use the decorator.
    /// </summary>
    public static void RegisterInitializer<TTarget>(this IRegistrator registrator,
        Action<TTarget, IResolverContext> initialize,
        IReuse reuse,
        Func<Request, bool> condition = null)
    {
        initialize.ThrowIfNull();

        registrator.Register<object>(
            reuse: reuse,
            made: Made.Of(
                static r => _initializerMethod.MakeGenericMethod(typeof(TTarget), r.ServiceType),
                parameters: Parameters.Of.Type(initialize.ToFunc<Request, Action<TTarget, IResolverContext>>)),
            setup: Setup.DecoratorWith(
                condition == null
                    ? static r => r.FactoryType != FactoryType.Wrapper && typeof(TTarget).IsAssignableFrom(r.ServiceType)
                    : r => r.FactoryType != FactoryType.Wrapper && typeof(TTarget).IsAssignableFrom(r.ServiceType) && condition(r),
                useDecorateeReuse: true, // issue BitBucket #230 - ensures the initialization to happen once on construction 
                preventDisposal: true)); // issue #215 - ensures that the initialized / decorated object does not added for the disposal twice
    }

    private static readonly MethodInfo _initializerMethod =
        typeof(Registrator).SingleMethod(nameof(Initializer), includeNonPublic: true);

    internal static TService Initializer<TTarget, TService>(
        TService service, IResolverContext resolver, Action<TTarget, IResolverContext> initialize) where TService : TTarget
    {
        initialize(service, resolver);
        return service;
    }

    /// <summary>Registers dispose action for reused target service.</summary>
    public static void RegisterDisposer<TService>(this IRegistrator registrator,
        Action<TService> dispose, Func<Request, bool> condition = null)
    {
        dispose.ThrowIfNull();

        var disposerKey = new object();

        registrator.RegisterDelegate(_ => new Disposer<TService>(dispose),
            serviceKey: disposerKey,
            // tracking instead of parent reuse, so that I can use one disposer for multiple services
            setup: Setup.With(trackDisposableTransient: true));

        var disposerType = typeof(Disposer<>).MakeGenericType(typeof(TService));
        registrator.Register<object>(
            made: Made.Of(
                r => disposerType.SingleMethod("TrackForDispose").MakeGenericMethod(r.ServiceType),
                ServiceInfo.Of(disposerType, serviceKey: disposerKey)),
            setup: Setup.DecoratorWith(
                condition == null
                ? static r => typeof(TService).IsAssignableFrom(r.ServiceType)
                : r => typeof(TService).IsAssignableFrom(r.ServiceType) && condition(r),
                useDecorateeReuse: true));
    }

    internal sealed class Disposer<T> : IDisposable
    {
        private readonly Action<T> _dispose;
        private int _state;
        private const int TRACKED = 1, DISPOSED = 2;
        private T _item;

        public Disposer(Action<T> dispose)
        {
            _dispose = dispose;
        }

        public S TrackForDispose<S>(S item) where S : T
        {
            if (Interlocked.CompareExchange(ref _state, TRACKED, 0) != 0)
                Throw.It(Error.DisposerTrackForDisposeError, _state == TRACKED ? " tracked" : "disposed");
            _item = item;
            return item;
        }

        public void Dispose()
        {
            if (Interlocked.CompareExchange(ref _state, DISPOSED, TRACKED) != TRACKED)
                return;
            var item = _item;
            if (item != null)
            {
                _dispose(item);
                _item = default(T);
            }
        }
    }

    /// <summary>Returns true if <paramref name="serviceType"/> is registered in container OR
    /// its open generic definition is registered in container.
    /// The additional implementation factory <paramref name="condition"/> may be specified to narrow the search.</summary>
    public static bool IsRegistered(this IRegistrator registrator, Type serviceType,
        object serviceKey = null, FactoryType factoryType = FactoryType.Service, Func<Factory, bool> condition = null) =>
        registrator.IsRegistered(serviceType, serviceKey, factoryType, condition);

    /// <summary>Returns true if <typeparamref name="TService"/> is registered in container OR
    /// its open generic definition is registered in container.
    /// The additional implementation factory <paramref name="condition"/> may be specified to narrow the search.</summary>
    public static bool IsRegistered<TService>(this IRegistrator registrator,
        object serviceKey = null, FactoryType factoryType = FactoryType.Service, Func<Factory, bool> condition = null) =>
        registrator.IsRegistered(typeof(TService), serviceKey, factoryType, condition);

    /// <summary>Removes specified registration from container.
    /// It also tries to remove the cached resolutions for the removed registration, But it may not work depending on context.
    /// Check the docs for more info: https://github.com/dadhi/DryIoc/blob/master/docs/DryIoc.Docs/UnregisterAndResolutionCache.md </summary>
    public static void Unregister(this IRegistrator registrator, Type serviceType,
        object serviceKey = null, FactoryType factoryType = FactoryType.Service, Func<Factory, bool> condition = null) =>
        registrator.Unregister(serviceType, serviceKey, factoryType, condition);

    /// <summary>Removes specified registration from container.
    /// It also tries to remove the cached resolutions for the removed registration, But it may not work depending on context.
    /// Check the docs for more info: https://github.com/dadhi/DryIoc/blob/master/docs/DryIoc.Docs/UnregisterAndResolutionCache.md </summary>
    public static void Unregister<TService>(this IRegistrator registrator,
        object serviceKey = null, FactoryType factoryType = FactoryType.Service, Func<Factory, bool> condition = null) =>
        registrator.Unregister(typeof(TService), serviceKey, factoryType, condition);

    /// <summary>Registers new service type with factory for registered service type.
    /// Throw if no such registered service type in container.</summary>
    /// <param name="registrator">Registrator</param> <param name="serviceType">New service type.</param>
    /// <param name="registeredServiceType">Existing registered service type.</param>
    /// <param name="ifAlreadyRegistered">The registration to overwrite or preserve the already registered service</param>
    /// <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
    /// <param name="factoryType">(optional) By default is <see cref="FactoryType.Service"/></param>
    public static void RegisterMapping(this IRegistrator registrator, Type serviceType, Type registeredServiceType,
        IfAlreadyRegistered? ifAlreadyRegistered, object serviceKey = null, object registeredServiceKey = null, FactoryType factoryType = FactoryType.Service)
    {
        var factories = registrator.GetRegisteredFactories(registeredServiceType, registeredServiceKey, factoryType);

        if (factories.IsNullOrEmpty())
            Throw.It(Error.RegisterMappingNotFoundRegisteredService, registeredServiceType, registeredServiceKey);

        if (factories.Length > 1)
            Throw.It(Error.RegisterMappingUnableToSelectFromMultipleFactories, serviceType, serviceKey, factories);

        registrator.Register(factories[0], serviceType, serviceKey, ifAlreadyRegistered, false);
    }

    /// <summary>Registers new service type with factory for registered service type.
    /// Throw if no such registered service type in container.</summary>
    public static void RegisterMapping(this IRegistrator registrator, Type serviceType, Type registeredServiceType,
        object serviceKey = null, object registeredServiceKey = null, FactoryType factoryType = FactoryType.Service) =>
        registrator.RegisterMapping(serviceType, registeredServiceType, null, serviceKey, registeredServiceKey, factoryType);

    /// <summary>Registers new service type with factory for registered service type.
    /// Throw if no such registered service type in container.</summary>
    /// <param name="registrator">Registrator</param>
    /// <typeparam name="TService">New service type.</typeparam>
    /// <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
    /// <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
    /// <param name="factoryType">(optional) By default is <see cref="FactoryType.Service"/></param>
    public static void RegisterMapping<TService, TRegisteredService>(this IRegistrator registrator,
        object serviceKey = null, object registeredServiceKey = null, FactoryType factoryType = FactoryType.Service) =>
        registrator.RegisterMapping(typeof(TService), typeof(TRegisteredService), null, serviceKey, registeredServiceKey, factoryType);

    /// <summary>Register a service without implementation which can be provided later in terms
    /// of normal registration with `IfAlreadyRegistered.Replace` parameter.
    /// When the implementation is still not provided when the placeholder service is accessed, then the exception will be thrown.
    /// This feature allows you to postpone the decision on implementation until it is later known.</summary>
    /// <remarks>Internally the empty factory is registered with the setup `asResolutionCall: true`.
    /// That means, instead of placing service instance into graph expression we put here redirecting call to
    /// container Resolve.</remarks>
    public static void RegisterPlaceholder(this IRegistrator registrator, Type serviceType,
        IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        registrator.Register(FactoryPlaceholder.Default, serviceType, serviceKey, ifAlreadyRegistered, true);

    /// <summary>Register a service without implementation which can be provided later in terms
    /// of normal registration with `IfAlreadyRegistered.Replace` parameter.
    /// When the implementation is still not provided when the placeholder service is accessed,then the exception will be thrown.
    /// This feature allows you to postpone decision on implementation until it is later known.</summary>
    /// <remarks>Internally the empty factory is registered with the setup `asResolutionCall: true`.
    /// That means, instead of placing service instance into graph expression we put here redirecting call to
    /// container Resolve.</remarks>
    public static void RegisterPlaceholder<TService>(this IRegistrator registrator,
        IfAlreadyRegistered? ifAlreadyRegistered = null, object serviceKey = null) =>
        registrator.RegisterPlaceholder(typeof(TService), ifAlreadyRegistered, serviceKey);

    /// <summary>Registers new service type with factory for registered service type.
    /// Throw if no such registered service type in container.</summary>
    /// <param name="container">Container</param>
    /// <typeparam name="TService">New service type.</typeparam>
    /// <typeparam name="TRegisteredService">Existing registered service type.</typeparam>
    /// <param name="ifAlreadyRegistered">The registration to overwrite or preserve the already registered service</param>
    /// <param name="serviceKey">(optional)</param> <param name="registeredServiceKey">(optional)</param>
    public static void RegisterMapping<TService, TRegisteredService>(this IContainer container,
        IfAlreadyRegistered ifAlreadyRegistered, object serviceKey = null, object registeredServiceKey = null) =>
        Registrator.RegisterMapping(container,
            typeof(TService), typeof(TRegisteredService), ifAlreadyRegistered, serviceKey, registeredServiceKey);
}

/// <summary>Extension methods for <see cref="IResolver"/>.</summary>
public static class Resolver
{
    internal static readonly MethodInfo ResolveFastMethod =
        typeof(IResolver).Method(nameof(IResolver.Resolve), typeof(Type), typeof(IfUnresolved));

    internal static readonly MethodInfo ResolveMethod =
        typeof(IResolver).Method(nameof(IResolver.Resolve), typeof(Type), typeof(object),
            typeof(IfUnresolved), typeof(Type), typeof(Request), typeof(object[]));

    internal static readonly MethodInfo ResolveManyMethod =
        typeof(IResolver).GetMethod(nameof(IResolver.ResolveMany));

    /// <summary>Resolves instance of service type from container. Throws exception if unable to resolve.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static object Resolve(this IResolver resolver, Type serviceType) =>
        resolver.Resolve(serviceType, IfUnresolved.Throw);

    /// <summary>Resolves instance of service type from container.</summary>
    public static object Resolve(this IResolver resolver, Type serviceType, IfUnresolved ifUnresolved) =>
        resolver.Resolve(serviceType, ifUnresolved);

    /// <summary>Resolves instance of type TService from container.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static TService Resolve<TService>(this IResolver resolver, IfUnresolved ifUnresolved = IfUnresolved.Throw) =>
        (TService)resolver.Resolve(typeof(TService), ifUnresolved);

    /// <summary>Tries to resolve instance of service type from container.</summary>
    public static object Resolve(this IResolver resolver, Type serviceType, bool ifUnresolvedReturnDefault) =>
        resolver.Resolve(serviceType, ifUnresolvedReturnDefault ? IfUnresolved.ReturnDefault : IfUnresolved.Throw);

    /// <summary>Tries to resolve instance of TService from container.</summary>
    public static object Resolve<TService>(this IResolver resolver, bool ifUnresolvedReturnDefault) =>
        resolver.Resolve(typeof(TService), ifUnresolvedReturnDefault);

    /// <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
    /// In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
    /// <paramref name="requiredServiceType"/> allow you to specify wrapped service type.</summary>
    /// <example><code lang="cs"><![CDATA[
    ///     container.Register<IService, Service>();
    ///     var services = container.Resolve(typeof(IEnumerable<object>), typeof(IService));
    /// ]]></code></example>
    public static object Resolve(this IResolver resolver, Type serviceType, Type requiredServiceType,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, object[] args = null, object serviceKey = null) =>
        resolver.Resolve(serviceType, serviceKey, ifUnresolved, requiredServiceType, Request.Empty, args);

    /// <summary>Returns instance of <typeparamref name="TService"/> searching for <paramref name="requiredServiceType"/>.
    /// In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
    /// <paramref name="requiredServiceType"/> allow you to specify wrapped service type.</summary>
    /// <example><code lang="cs"><![CDATA[
    ///     container.Register<IService, Service>();
    ///     var services = container.Resolve<IEnumerable<object>>(typeof(IService));
    /// ]]></code></example>
    [MethodImpl((MethodImplOptions)256)]
    public static TService Resolve<TService>(this IResolver resolver, Type requiredServiceType,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, object[] args = null, object serviceKey = null) =>
        (TService)resolver.Resolve(typeof(TService), serviceKey, ifUnresolved, requiredServiceType, Request.Empty, args);

    /// <summary>Returns instance of <typeparamref name="TService"/> searching for <typeparamref name="TRequiredService"/>.
    /// In case of <typeparamref name="TService"/> being generic wrapper like Func, Lazy, IEnumerable, etc. 
    /// <typeparamref name="TRequiredService"/> allow you to specify wrapped service type.</summary>
    /// <example><code lang="cs"><![CDATA[
    ///     container.Register<IService, Service>();
    ///     var services = container.Resolve<IEnumerable<object>, IService>();
    /// ]]></code></example>
    public static TService Resolve<TService, TRequiredService>(this IResolver resolver,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, object[] args = null, object serviceKey = null) =>
        (TService)resolver.Resolve(typeof(TService), serviceKey, ifUnresolved, typeof(TRequiredService), Request.Empty, args);

    /// <summary>Returns instance of <paramref name="serviceType"/> searching for <paramref name="requiredServiceType"/>.
    /// In case of <paramref name="serviceType"/> being generic wrapper like Func, Lazy, IEnumerable, etc., <paramref name="requiredServiceType"/>
    /// could specify wrapped service type.</summary>
    /// <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
    /// <example><code lang="cs"><![CDATA[
    ///     container.Register<IService, Service>();
    ///     var services = container.Resolve(typeof(Lazy<object>), "someKey", requiredServiceType: typeof(IService));
    /// ]]></code></example>
    [MethodImpl((MethodImplOptions)256)]
    public static object Resolve(this IResolver resolver, Type serviceType, object serviceKey,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, Type requiredServiceType = null,
        object[] args = null) =>
        resolver.Resolve(serviceType, serviceKey, ifUnresolved, requiredServiceType, Request.Empty, args);

    /// <summary>Returns instance of <typeparamref name="TService"/> type.</summary>
    /// <typeparam name="TService">The type of the requested service.</typeparam>
    /// <returns>The requested service instance.</returns>
    /// <remarks>Using <paramref name="requiredServiceType"/> implicitly support Covariance for generic wrappers even in .Net 3.5.</remarks>
    [MethodImpl((MethodImplOptions)256)]
    public static TService Resolve<TService>(this IResolver resolver, object serviceKey,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, Type requiredServiceType = null,
        object[] args = null) =>
        (TService)resolver.Resolve(typeof(TService), serviceKey, ifUnresolved, requiredServiceType, Request.Empty, args);

    /// <summary>Resolves the service supplying all or some of its dependencies 
    /// (including nested) with the <paramref name="args"/>. The rest of dependencies is injected from
    /// container.</summary>
    public static object Resolve(this IResolver resolver, Type serviceType, object[] args,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, Type requiredServiceType = null,
        object serviceKey = null) =>
        resolver.Resolve(serviceType, serviceKey, ifUnresolved, requiredServiceType, Request.Empty, args);

    /// <summary>Resolves the service supplying all or some of its dependencies 
    /// (including nested) with the <paramref name="args"/>. The rest of dependencies is injected from
    /// container.</summary>
    public static TService Resolve<TService>(this IResolver resolver, object[] args,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, Type requiredServiceType = null,
        object serviceKey = null) =>
        (TService)resolver.Resolve(typeof(TService), serviceKey, ifUnresolved, requiredServiceType, Request.Empty, args);

    /// <summary>Returns all registered services instances including all keyed and default registrations.
    /// Use <paramref name="behavior"/> to return either all registered services at the moment of resolve (dynamic fresh view) or
    /// the same services that were returned with first <see cref="ResolveMany{TService}"/> call (fixed view).</summary>
    /// <typeparam name="TService">Return collection item type. 
    /// It denotes registered service type if <paramref name="requiredServiceType"/> is not specified.</typeparam>
    /// <remarks>The same result could be achieved by directly calling:
    /// <code lang="cs"><![CDATA[
    ///     container.Resolve<LazyEnumerable<IService>>();  // for dynamic result - default behavior
    ///     container.Resolve<IService[]>();                // for fixed array
    ///     container.Resolve<IEnumerable<IService>>();     // same as fixed array
    /// ]]></code>
    /// </remarks>
    public static IEnumerable<TService> ResolveMany<TService>(this IResolver resolver,
        Type requiredServiceType = null, ResolveManyBehavior behavior = ResolveManyBehavior.AsLazyEnumerable,
        object[] args = null, object serviceKey = null) =>
        behavior == ResolveManyBehavior.AsLazyEnumerable
            ? resolver.ResolveMany(typeof(TService), serviceKey, requiredServiceType, Request.Empty, args).Cast<TService>()
            : resolver.Resolve<IEnumerable<TService>>(serviceKey, IfUnresolved.Throw, requiredServiceType, args);

    /// <summary>Returns all registered services as objects, including all keyed and default registrations.</summary>
    public static IEnumerable<object> ResolveMany(this IResolver resolver, Type serviceType,
        ResolveManyBehavior behavior = ResolveManyBehavior.AsLazyEnumerable,
        object[] args = null, object serviceKey = null) =>
        resolver.ResolveMany<object>(serviceType, behavior, args, serviceKey);

    /// <summary>Creates a service by injecting its parameters registered in the container but without registering the service itself in the container.</summary>
    public static object New(this IResolver resolver, Type concreteType, Made made = null,
        RegistrySharing registrySharing = RegistrySharing.CloneButKeepCache) =>
        resolver.Resolve<IContainer>().New(concreteType, setup: null, made, registrySharing);

    /// <summary>Creates a service by injecting its parameters registered in the container but without registering the service itself in the container.</summary>
    public static T New<T>(this IResolver resolver, Made made = null,
        RegistrySharing registrySharing = RegistrySharing.CloneButKeepCache) =>
        (T)resolver.New(typeof(T), made, registrySharing);

    /// <summary>Creates a service by injecting its parameters registered in the container but without registering the service itself in the container.</summary>
    public static T New<T>(this IResolver resolver, Made.TypedMade<T> made,
        RegistrySharing registrySharing = RegistrySharing.CloneButKeepCache) =>
        (T)resolver.New(typeof(T), made, registrySharing);

    internal static readonly ConstructorInfo ResolutionScopeNameCtor =
        typeof(ResolutionScopeName).GetConstructors(BindingFlags.Instance | BindingFlags.NonPublic)[0];

    /// <summary>Used for internal purposes to create the expression of Resolve method of the passed `request`</summary>
    public static Expression CreateResolutionExpression(Request request,
        bool openResolutionScope = false, bool stopRecursiveDependencyCheck = false, bool generateResolutionCallForMissingDependency = false)
    {
        if (request.Rules.DependencyResolutionCallExprs != null &&
            (generateResolutionCallForMissingDependency || request.Factory?.HasRuntimeState == false))
            ResolveAndPopulateDependencyResolutionCallExpressions(request, generateResolutionCallForMissingDependency);

        var container = request.Container;
        var serviceType = request.ServiceType;
        var serviceTypeExpr = ConstantOf<Type>(serviceType);
        var details = request.GetServiceDetails();
        var serviceKeyExpr = details.ServiceKey == null ? NullConstant : container.GetConstantExpression(details.ServiceKey, typeof(object));
        Expression resolverExpr;
        if (!openResolutionScope)
            resolverExpr = ResolverContext.GetRootOrSelfExpr(request);
        else
        {
            // Generates the code below. That means the service opening the scope is scoped to this scope.
            //
            // r => r.OpenScope(new ResolutionScopeName(serviceType, serviceKey), trackInParent: true)
            //       .Resolve(serviceType, serviceKey)
            //
            var scopeNameExpr = Expression.New(ResolutionScopeNameCtor, ConstantOf<Type>(request.ActualServiceType), serviceKeyExpr);
            var trackInParent = Constant(!request.Factory?.Setup.AvoidResolutionScopeTracking ?? true);
            resolverExpr = Call(ResolverContext.OpenScopeMethod, FactoryDelegateCompiler.ResolverContextParamExpr, scopeNameExpr, trackInParent);
        }

        var parentFlags = default(RequestFlags);
        if (openResolutionScope)
            parentFlags |= RequestFlags.OpensResolutionScope;
        if (stopRecursiveDependencyCheck | (request.Flags & RequestFlags.StopRecursiveDependencyCheck) != 0)
            parentFlags |= RequestFlags.StopRecursiveDependencyCheck;

        // Only parent is converted to be passed to Resolve.
        // The current request is formed by rest of Resolve parameters.
        var preResolveParentExpr = container.GetRequestExpression(request.DirectParent, parentFlags);

        var ifUnresolvedExpr = details.IfUnresolved.ToConstant();
        var requiredServiceTypeExpr = details.RequiredServiceType.ToConstant();

        var resolveCallExpr = Call(resolverExpr, ResolveMethod, serviceTypeExpr, serviceKeyExpr,
            ifUnresolvedExpr, requiredServiceTypeExpr, preResolveParentExpr, request.GetInputArgsExpr());
        return serviceType == typeof(object) ? resolveCallExpr : TryConvertIntrinsic(resolveCallExpr, serviceType);
    }

    private static void ResolveAndPopulateDependencyResolutionCallExpressions(Request request, bool generateResolutionCallForMissingDependency = false)
    {
        if (generateResolutionCallForMissingDependency)
        {
            // Store `null` as expression to indicate that the dependency resolution call is not generated, 
            // and the registration for the dependency should be provided. 
            // This information will help compile-time container to output message the the runtime registration is required.
            var requestCopy = request.IsolateRequestChain();
            request.Container.Rules.DependencyResolutionCallExprs.Swap(requestCopy, (x, req) => x.AddOrUpdate(req, null));
        }
        else
        {
            // Actually calls nested Resolve and stores produced expression in collection inside the container Rules.
            // Stops on recursive dependency, e.g. 
            // `new A(new Lazy<B>(r => r.Resolve<B>())` and `new B(new A())`
            for (var p = request.DirectParent; !p.IsEmpty; p = p.DirectParent)
                if (p.FactoryID == request.FactoryID)
                    return;

            var factory = request.Container.ResolveFactory(request);
            if (factory == null || factory is FactoryPlaceholder)
                return;

            // Prevents infinite recursion when generating the resolution dependency #579
            if ((request.Flags & RequestFlags.IsGeneratedResolutionDependencyExpression) != 0)
                return;

            request.Flags |= RequestFlags.IsGeneratedResolutionDependencyExpression;

            var factoryExpr = factory.GetExpressionOrDefault(request);
            if (factoryExpr == null)
                return;

            // we need to isolate request when stored in the key, 
            // otherwise it maybe reused and the key content will be overriden with the new request, leading to the soup pure! see GHIssue101
            var requestCopy = request.IsolateRequestChain();
            request.Container.Rules.DependencyResolutionCallExprs.Swap(
                requestCopy, factoryExpr, (x, req, facExpr) => x.AddOrUpdate(req, facExpr));
        }
    }
}

/// <summary>Specifies result of <see cref="Resolver.ResolveMany{TService}"/>: either dynamic(lazy) or fixed view.</summary>
public enum ResolveManyBehavior
{
    /// <summary>Lazy/dynamic item resolve.</summary>
    AsLazyEnumerable,
    /// <summary>Fixed array of item at time of resolve, newly registered/removed services won't be listed.</summary>
    AsFixedArray
}

/// <summary>Controls the registry change</summary>
public enum IsRegistryChangePermitted : byte
{
    /// <summary>Change is permitted - the default setting</summary>
    Permitted = 0,
    /// <summary>Throws the error for the new registration</summary>
    Error,
    /// <summary>Ignores the next registration</summary>
    Ignored
}

/// <summary>Provides optional service resolution details: service key, required service type, what return when service is unresolved,
/// default value if service is unresolved, custom service value.</summary>
public sealed class ServiceDetails
{
    /// Default details if not specified, use default setting values, e.g. <see cref="DryIoc.IfUnresolved.Throw"/>
    public static readonly ServiceDetails Default =
        new ServiceDetails(null, IfUnresolved.Throw, null, null, null, null, false);

    /// Default details with <see cref="DryIoc.IfUnresolved.ReturnDefault"/> option.
    public static readonly ServiceDetails IfUnresolvedReturnDefault =
        new ServiceDetails(null, IfUnresolved.ReturnDefault, null, null, null, null, false);

    /// Default details with <see cref="DryIoc.IfUnresolved.ReturnDefaultIfNotRegistered"/> option.
    public static readonly ServiceDetails IfUnresolvedReturnDefaultIfNotRegistered =
        new ServiceDetails(null, IfUnresolved.ReturnDefaultIfNotRegistered, null, null, null, null, false);

    /// <summary>Creates new details out of provided settings, or returns default if all settings have default value.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ServiceDetails Of(IfUnresolved ifUnresolved) =>
        ifUnresolved == IfUnresolved.Throw ? Default :
        ifUnresolved == IfUnresolved.ReturnDefault ? IfUnresolvedReturnDefault :
            IfUnresolvedReturnDefaultIfNotRegistered;

    /// <summary>Creates new details out of provided settings, or returns default if all settings have default value.</summary>
    public static ServiceDetails Of(Type requiredServiceType = null,
        object serviceKey = null, IfUnresolved ifUnresolved = IfUnresolved.Throw,
        object defaultValue = null, string metadataKey = null, object metadata = null)
    {
        if (defaultValue == null)
        {
            if (requiredServiceType == null & serviceKey == null & metadataKey == null & metadata == null)
                return Of(ifUnresolved);
        }
        else if (ifUnresolved == IfUnresolved.Throw) // IfUnresolved.Throw does not make sense when default value is provided, so normalizing it to ReturnDefault
            ifUnresolved = IfUnresolved.ReturnDefault;

        return new ServiceDetails(requiredServiceType, ifUnresolved,
            serviceKey, metadataKey, metadata, defaultValue, hasCustomValue: false);
    }

    /// <summary>Obsolete: please use <see cref="OfValue"/> instead.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ServiceDetails Of(object value) =>
        new ServiceDetails(null, IfUnresolved.Throw, null, null, null, value, hasCustomValue: true);

    /// <summary>Sets custom value for service. This setting is orthogonal to the rest of the details.
    /// Using default value with invalid ifUnresolved.Throw option to indicate custom value.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ServiceDetails OfValue(object value) =>
        new ServiceDetails(null, IfUnresolved.Throw, null, null, null, value, hasCustomValue: true);

    /// <summary>Sets the service key as a detials of the service resolution.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ServiceDetails OfServiceKey(object serviceKey) =>
        new ServiceDetails(null, IfUnresolved.Throw, serviceKey, null, null, null, hasCustomValue: false);

    /// <summary>Creates new details out of provided settings and not null `serviceKey`.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ServiceDetails WithServiceKey(ServiceDetails d, object serviceKey) =>
        new ServiceDetails(d.RequiredServiceType, d.IfUnresolved, serviceKey, d.MetadataKey, d.Metadata, d.DefaultValue, hasCustomValue: false);

    /// <summary>Service type to search in registry. Should be assignable to user requested service type.</summary>
    public readonly Type RequiredServiceType;

    /// <summary>Service key provided with registration.</summary>
    public readonly object ServiceKey;

    /// <summary>Metadata key to find in metadata dictionary in resolved service.</summary>
    public readonly string MetadataKey;

    /// <summary>Metadata value to find in resolved service.</summary>
    public readonly object Metadata;

    /// <summary>Indicates that the custom value is specified.</summary>
    public readonly bool HasCustomValue;

    /// <summary>Either default or custom value depending on <see cref="IfUnresolved"/> setting.</summary>
    private readonly object _value;

    /// <summary>Policy to deal with unresolved request.</summary>
    public readonly IfUnresolved IfUnresolved;

    /// <summary>Value to use in case <see cref="IfUnresolved"/> is set to not Throw.</summary>
    public object DefaultValue => IfUnresolved != IfUnresolved.Throw ? _value : null;

    /// <summary>Custom value specified for dependency. The IfUnresolved.Throw is the marker of custom value comparing to default value.</summary>
    public object CustomValue => IfUnresolved == IfUnresolved.Throw ? _value : null;

    /// <summary>Pretty prints service details to string for debugging and errors.</summary> <returns>Details string.</returns>
    public override string ToString()
    {
        var s = new StringBuilder();

        if (HasCustomValue)
            return s.Append("{CustomValue=").Print(CustomValue).Append("}").ToString();

        if (RequiredServiceType != null)
            s.Append("RequiredServiceType=typeof(").Print(RequiredServiceType).Append(')');
        if (ServiceKey != null)
            (s.Length == 0 ? s.Append('{') : s.Append(", ")).Append("ServiceKey=").Print(ServiceKey);
        if (MetadataKey != null || Metadata != null)
            (s.Length == 0 ? s.Append('{') : s.Append(", ")).Append("Metadata=").Append(MetadataKey.Pair(Metadata));
        if (IfUnresolved != IfUnresolved.Throw)
        {
            s = (s.Length == 0 ? s.Append('{') : s.Append(", ")).Print(IfUnresolved);
            s = _value == null ? s : s.Append(", DefaultValue=").Print(_value);
        }

        return (s.Length == 0 ? s : s.Append('}')).ToString();
    }

    internal ServiceDetails(Type requiredServiceType, IfUnresolved ifUnresolved,
        object serviceKey, string metadataKey, object metadata,
        object value, bool hasCustomValue)
    {
        RequiredServiceType = requiredServiceType;
        IfUnresolved = ifUnresolved;
        ServiceKey = serviceKey;
        MetadataKey = metadataKey;
        Metadata = metadata;
        _value = value;
        HasCustomValue = hasCustomValue;
    }

    /// <summary>Check all property for the equality</summary>
    public bool Equals(ServiceDetails d) =>
        d == Default && this == Default ||
        d == IfUnresolvedReturnDefault && this == IfUnresolvedReturnDefault ||
        d.RequiredServiceType == RequiredServiceType && d.IfUnresolved == IfUnresolved && d.HasCustomValue == HasCustomValue &&
        Equals(d.MetadataKey, MetadataKey) && Equals(d.Metadata, Metadata) && Equals(d._value, _value);
}

/// <summary>Contains tools for combining or propagating of <see cref="ServiceInfo"/> independent of its concrete implementations.</summary>
public static class ServiceInfoTools
{
    /// <summary>Creates service info with new type but keeping the details.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ServiceInfo WithType(this ServiceInfo source, Type serviceType) => source.Create(serviceType, source.Details);

    /// <summary>Creates new info with new IfUnresolved behavior or returns the original info if behavior is not different,
    /// or the passed info is not a <see cref="ServiceDetails.HasCustomValue"/>.</summary>
    public static ServiceInfo WithIfUnresolved(this ServiceInfo source, IfUnresolved ifUnresolved)
    {
        var details = source.Details;
        if (details.IfUnresolved == ifUnresolved || details.HasCustomValue)
            return source;

        if (details == ServiceDetails.Default)
            details = ifUnresolved == IfUnresolved.ReturnDefault
                ? ServiceDetails.IfUnresolvedReturnDefault
                : ServiceDetails.IfUnresolvedReturnDefaultIfNotRegistered;
        else
            details = ServiceDetails.Of(details.RequiredServiceType, details.ServiceKey,
                ifUnresolved, details.DefaultValue, details.MetadataKey, details.Metadata);

        return source.Create(source.ServiceType, details);
    }

    // todo: @naming Should be renamed or better to be removed, the whole operation should be hidden behind abstraction
    /// <summary>Combines service info with details. The main goal is to combine service and required service type.</summary>
    public static T WithDetails<T>(this T serviceInfo, ServiceDetails details) where T : ServiceInfo
    {
        if (details == null)
            return serviceInfo; // fixes #669

        var oldDetails = serviceInfo.Details;
        if (!details.HasCustomValue &&
            oldDetails != ServiceDetails.Default &&
            oldDetails != details)
        {
            var serviceKey = details.ServiceKey ?? oldDetails.ServiceKey;
            var metadataKey = details.MetadataKey ?? oldDetails.MetadataKey;
            var metadata = metadataKey == details.MetadataKey ? details.Metadata : oldDetails.Metadata;
            var defaultValue = details.DefaultValue ?? oldDetails.DefaultValue;

            details = ServiceDetails.Of(details.RequiredServiceType, serviceKey,
                details.IfUnresolved, defaultValue, metadataKey, metadata);
        }

        var serviceType = serviceInfo.ServiceType;
        var requiredServiceType = details.RequiredServiceType;

        if (requiredServiceType != null & requiredServiceType == serviceType)
            details = ServiceDetails.Of(null,
                details.ServiceKey, details.IfUnresolved, details.DefaultValue,
                details.MetadataKey, details.Metadata);

        // if details are absent or details are the same, then return the original info, otherwise create a new one
        return details == null | details == oldDetails
            ? serviceInfo
            : (T)serviceInfo.Create(serviceType, details);
    }

    /// <summary>Enables propagation/inheritance of info between dependency and its owner:
    /// for instance <see cref="ServiceDetails.RequiredServiceType"/> for wrappers.</summary>
    public static ServiceInfo InheritInfoFromDependencyOwner(this ServiceInfo dependency,
        Type ownerServiceType, ServiceDetails ownerDetails, IContainer container, FactoryType ownerType = FactoryType.Service)
    {
        var depDetails = dependency.Details;

        var ownerIfUnresolved = ownerDetails.IfUnresolved;
        var ifUnresolved = depDetails.IfUnresolved;
        if (ownerIfUnresolved == IfUnresolved.ReturnDefault) // ReturnDefault is always inherited
            ifUnresolved = ownerIfUnresolved;

        var serviceType = dependency.ServiceType;
        var requiredServiceType = depDetails.RequiredServiceType;
        var serviceKey = depDetails.ServiceKey;
        var metadataKey = depDetails.MetadataKey;
        var metadata = depDetails.Metadata;

        // Inherit some things through wrappers and decorators
        if (ownerType == FactoryType.Wrapper ||
            ownerType == FactoryType.Decorator &&
            ownerServiceType.IsAssignableFrom(container.GetWrappedType(serviceType, requiredServiceType)))
        {
            if (ownerIfUnresolved == IfUnresolved.ReturnDefaultIfNotRegistered)
                ifUnresolved = ownerIfUnresolved;

            if (serviceKey == null)
                serviceKey = ownerDetails.ServiceKey;

            if (metadataKey == null & metadata == null)
            {
                metadataKey = ownerDetails.MetadataKey;
                metadata = ownerDetails.Metadata;
            }
        }

        var ownerRequiredServiceType = ownerDetails.RequiredServiceType;
        if (ownerType != FactoryType.Service & ownerRequiredServiceType != null &
            requiredServiceType == null) // if only dependency does not have its own
            requiredServiceType = ownerRequiredServiceType;

        if (serviceKey == depDetails.ServiceKey && metadataKey == depDetails.MetadataKey && metadata == depDetails.Metadata && ifUnresolved == depDetails.IfUnresolved &&
            requiredServiceType == depDetails.RequiredServiceType)
            return dependency;

        if (serviceType == requiredServiceType)
            requiredServiceType = null;

        var serviceDetails = ServiceDetails.Of(requiredServiceType, serviceKey, ifUnresolved, depDetails.DefaultValue, metadataKey, metadata);
        return dependency.Create(serviceType, serviceDetails);
    }

    /// <summary>Enables propagation/inheritance of info between dependency and its owner:
    /// for instance <see cref="ServiceDetails.RequiredServiceType"/> for wrappers.</summary>
    public static object InheritInfoFromDependencyOwner(this Type serviceType,
        Type ownerServiceType, ServiceDetails ownerDetails, IContainer container, FactoryType ownerType = FactoryType.Service)
    {
        var ifUnresolved = IfUnresolved.Throw;
        var ownerIfUnresolved = ownerDetails.IfUnresolved;
        if (ownerIfUnresolved == IfUnresolved.ReturnDefault) // ReturnDefault is always inherited
            ifUnresolved = ownerIfUnresolved;

        object serviceKey = null;
        string metadataKey = null;
        object metadata = null;

        // Inherit some things from the wrappers and decorators
        if (ownerType == FactoryType.Wrapper ||
            ownerType == FactoryType.Decorator &&
            ownerServiceType.IsAssignableFrom(container.GetWrappedType(serviceType, null)))
        {
            if (ownerIfUnresolved == IfUnresolved.ReturnDefaultIfNotRegistered)
                ifUnresolved = ownerIfUnresolved;
            serviceKey = ownerDetails.ServiceKey;
            metadataKey = ownerDetails.MetadataKey;
            metadata = ownerDetails.Metadata;
        }

        Type requiredServiceType = null;
        var ownerRequiredServiceType = ownerDetails.RequiredServiceType;
        if (ownerType != FactoryType.Service & ownerRequiredServiceType != null) // if only dependency does not have its own
            requiredServiceType = ownerRequiredServiceType;

        if (serviceType == requiredServiceType)
            requiredServiceType = null;

        if (requiredServiceType == null & serviceKey == null & metadataKey == null & metadata == null & ifUnresolved == IfUnresolved.Throw)
            return serviceType;

        var details = new ServiceDetails(requiredServiceType, ifUnresolved, serviceKey, metadataKey, metadata, null, hasCustomValue: false);
        return ServiceInfo.Of(serviceType, details);
    }

    /// <summary>Returns required service type if it is specified and assignable to service type,
    /// otherwise returns service type.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static Type GetActualServiceType(this ServiceInfo info)
    {
        var t = info.Details.RequiredServiceType;
        return t != null && info.ServiceType.IsAssignableFrom(t) ? t : info.ServiceType;
    }

    /// <summary>Returns required service type if it is specified and assignable to service type,
    /// otherwise returns service type.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static Type GetActualServiceType(this ServiceDetails details, Type serviceType)
    {
        var t = details.RequiredServiceType;
        return t != null && serviceType.IsAssignableFrom(t) ? t : serviceType;
    }

    /// <summary>Appends info string representation into provided builder.</summary>
    public static StringBuilder Print(this StringBuilder s, ServiceInfo info)
    {
        s.Print(info.ServiceType);
        return info.Details == ServiceDetails.Default ? s : s.Append(' ').Append(info.Details);
    }
}

/// <summary>Represents custom or resolution root service info, there is separate representation for parameter,
/// property and field dependencies.</summary>
public abstract class ServiceInfo
{
    /// <summary>Creates info out of provided settings</summary>
    public static ServiceInfo OfServiceAndRequiredType(Type serviceType, Type requiredServiceType,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, object serviceKey = null,
        string metadataKey = null, object metadata = null) =>
        new WithDetails(serviceType, new ServiceDetails(requiredServiceType, ifUnresolved, serviceKey, metadataKey, metadata, null, false));

    /// <summary>Type of service, identifies the registered service in registry.</summary>
    public abstract Type ServiceType { get; }

    /// <summary>Additional settings. If not specified uses <see cref="ServiceDetails.Default"/>.</summary>
    public virtual ServiceDetails Details => ServiceDetails.Default;

    /// <summary>Service key provided with registration.</summary>
    public object ServiceKey => Details.ServiceKey;

    /// <summary>Creates info from service type and details.</summary>
    public virtual ServiceInfo Create(Type serviceType, ServiceDetails details) =>
        details == ServiceDetails.Default ? new Typed(serviceType) : new WithDetails(serviceType, details);

    /// <summary>Creates info out of provided settings</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ServiceInfo Of(Type serviceType) => new Typed(serviceType);

    /// <summary>Creates info out of provided settings</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ServiceInfo Of(Type serviceType, IfUnresolved ifUnresolved) =>
        ifUnresolved == IfUnresolved.Throw
            ? new Typed(serviceType) :
        ifUnresolved == IfUnresolved.ReturnDefault
            ? new TypedIfUnresolvedReturnDefault(serviceType)
            : new TypedIfUnresolvedReturnDefaultIfNotRegistered(serviceType);

    /// <summary>Creates info out of the provided settings</summary>
    public static ServiceInfo Of(Type serviceType, object serviceKey) =>
        serviceKey == null ? new Typed(serviceType) :
        new WithDetails(serviceType, ServiceDetails.Of(null, serviceKey, IfUnresolved.Throw, null, null, null)); // todo: @perf introduce details just with the key

    /// <summary>Creates info out of provided settings</summary>
    public static ServiceInfo Of(Type serviceType, ServiceDetails details) =>
        new WithDetails(serviceType, details);

    /// <summary>Creates info out of provided settings</summary>
    public static ServiceInfo Of(Type serviceType, IfUnresolved ifUnresolved, object serviceKey) =>
        serviceKey == null ? (ifUnresolved == IfUnresolved.Throw ? new Typed(serviceType)
            : ifUnresolved == IfUnresolved.ReturnDefault ? new WithDetails(serviceType, ServiceDetails.IfUnresolvedReturnDefault)
            : new WithDetails(serviceType, ServiceDetails.IfUnresolvedReturnDefaultIfNotRegistered))
            : new WithDetails(serviceType, ServiceDetails.Of(null, serviceKey, ifUnresolved, null, null, null));

    // todo: @perf @mem optimize for the `serviceType` and `requiredServiceType` only
    /// <summary>Creates info out of provided settings</summary>
    public static ServiceInfo Of(Type serviceType, Type requiredServiceType,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, object serviceKey = null, string metadataKey = null, object metadata = null) =>
        OrServiceType(serviceType, requiredServiceType, ifUnresolved, serviceKey, metadataKey, metadata) as ServiceInfo
            ?? new Typed(serviceType);

    internal static object OrServiceType(Type serviceType, Type requiredServiceType,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, object serviceKey = null, string metadataKey = null, object metadata = null)
    {
        (serviceType ?? requiredServiceType).ThrowIfNull();

        // remove unnecessary details if service and required type are the same
        if (serviceType == requiredServiceType)
            requiredServiceType = null;

        if (requiredServiceType == null & serviceKey == null & metadataKey == null & metadata == null)
            return ifUnresolved == IfUnresolved.Throw ? serviceType
                : ifUnresolved == IfUnresolved.ReturnDefault
                    ? new TypedIfUnresolvedReturnDefault(serviceType)
                    : new TypedIfUnresolvedReturnDefaultIfNotRegistered(serviceType);

        var details = new ServiceDetails(requiredServiceType, ifUnresolved, serviceKey, metadataKey, metadata, null, hasCustomValue: false);
        return new WithDetails(serviceType, details);
    }

    /// <summary>Typed service info</summary>
    public class Typed : ServiceInfo
    {
        /// <inheritdoc />
        public override Type ServiceType { get; }
        /// <summary>Creates the service info</summary>
        public Typed(Type serviceType) => ServiceType = serviceType.ThrowIfNull();
    }

    private sealed class TypedIfUnresolvedReturnDefault : Typed
    {
        public override ServiceDetails Details => ServiceDetails.IfUnresolvedReturnDefault;
        public TypedIfUnresolvedReturnDefault(Type serviceType) : base(serviceType) { }
    }

    private sealed class TypedIfUnresolvedReturnDefaultIfNotRegistered : Typed
    {
        public override ServiceDetails Details => ServiceDetails.IfUnresolvedReturnDefaultIfNotRegistered;
        public TypedIfUnresolvedReturnDefaultIfNotRegistered(Type serviceType) : base(serviceType) { }
    }

    /// <summary>Creates service info using typed <typeparamref name="TService"/>.</summary>
    public static Typed<TService> Of<TService>(IfUnresolved ifUnresolved = IfUnresolved.Throw, object serviceKey = null) =>
        serviceKey == null && ifUnresolved == IfUnresolved.Throw ? new Typed<TService>() :
            new TypedWithDetails<TService>(ServiceDetails.Of(null, serviceKey, ifUnresolved));

    /// <summary>Strongly-typed version of Service Info.</summary> <typeparam name="TService">Service type.</typeparam>
    public class Typed<TService> : ServiceInfo
    {
        /// <inheritdoc/>
        public override Type ServiceType => typeof(TService);
    }

    /// <summary>Prints info to string using <see cref="ServiceInfoTools.Print"/>.</summary> <returns>Printed string.</returns>
    public override string ToString() => new StringBuilder().Print(this).ToString();

    private sealed class WithDetails : Typed
    {
        public override ServiceDetails Details { get; }
        public WithDetails(Type serviceType, ServiceDetails details) : base(serviceType) => Details = details;
    }

    private sealed class TypedWithDetails<TService> : Typed<TService>
    {
        public override ServiceDetails Details { get; }
        public TypedWithDetails(ServiceDetails details) => Details = details;
    }
}

/// <summary>Provides <see cref="ServiceInfo"/> for parameter, by default using parameter type as <see cref="ServiceInfo.ServiceType"/>.</summary>
/// <remarks>For parameter default setting <see cref="ServiceDetails.IfUnresolved"/> is <see cref="IfUnresolved.Throw"/>.</remarks>
public class ParameterServiceInfo : ServiceInfo
{
    /// <inheritdoc/>
    public override Type ServiceType => Parameter.ParameterType;
    /// <summary>Parameter info.</summary>
    public readonly ParameterInfo Parameter;
    private ParameterServiceInfo(ParameterInfo p) => Parameter = p;

    // returns `null` if the parameter is enough to represent the service info
    internal static ParameterServiceInfo OrNull(ParameterInfo parameter)
    {
        var type = parameter.ParameterType;
        if (!parameter.IsOptional)
            return !type.IsByRef ? null : new Typed(parameter, type.GetElementType());
        var details = parameter.DefaultValue == null
            ? ServiceDetails.IfUnresolvedReturnDefault
            : ServiceDetails.Of(ifUnresolved: IfUnresolved.ReturnDefault, defaultValue: parameter.DefaultValue);
        return !type.IsByRef ? new WithDetails(parameter, details) : new Typed.WithDetails(parameter, type.GetElementType(), details);
    }

    /// <summary>Creates service info from parameter alone, setting service type to parameter type,
    /// and setting resolution policy to <see cref="IfUnresolved.ReturnDefault"/> if parameter is optional.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ParameterServiceInfo Of(ParameterInfo parameter) =>
        OrNull(parameter) ?? new ParameterServiceInfo(parameter);

    /// <summary>Creates service info from the parameter and the details</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ParameterServiceInfo Of(ParameterInfo parameter, ServiceDetails details) =>
        new WithDetails(parameter, details);

    /// <summary>Creates service info from the parameter, type and the details</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ParameterServiceInfo Of(ParameterInfo parameter, Type serviceType, ServiceDetails details) =>
        new Typed.WithDetails(parameter, serviceType, details);

    /// <summary>Represents the failing selector without the fallback, 
    /// in order to skip all further attempts to resolve the parameter, e.g. parameter is marked with attribute which does not match the correst resolution request</summary>
    public static readonly ParameterServiceInfo DefinitelyUnresolvedParameter =
        new ParameterServiceInfo(null);

    /// <summary>Creates info from service type and details.</summary>
    public override ServiceInfo Create(Type serviceType, ServiceDetails details) =>
        serviceType == ServiceType
            ? new WithDetails(Parameter, details)
            : new Typed.WithDetails(Parameter, serviceType, details);

    /// <summary>Prints info to string using <see cref="ServiceInfoTools.Print"/>.</summary> <returns>Printed string.</returns>
    public override string ToString() =>
        new StringBuilder().Print(this).Append(" as parameter ").Print(Parameter.Name).ToString();

    private new class Typed : ParameterServiceInfo
    {
        /// <inheritdoc/>
        public override Type ServiceType { get; }
        public Typed(ParameterInfo parameter, Type serviceType) : base(parameter) => ServiceType = serviceType;
        internal sealed new class WithDetails : Typed
        {
            public override ServiceDetails Details { get; }
            public WithDetails(ParameterInfo parameter, Type serviceType, ServiceDetails details) : base(parameter, serviceType) => Details = details;
        }

        /// <summary>Creates info from service type and details.</summary>
        public sealed override ServiceInfo Create(Type serviceType, ServiceDetails details) =>
            new Typed.WithDetails(Parameter, serviceType, details);
    }

    private sealed class WithDetails : ParameterServiceInfo
    {
        public override ServiceDetails Details { get; }
        public WithDetails(ParameterInfo parameter, ServiceDetails details) : base(parameter) => Details = details;
    }
}

/// <summary>Base class for property and field dependency info.</summary>
public abstract class PropertyOrFieldServiceInfo : ServiceInfo.Typed
{
    /// <summary>Creates the service info</summary>
    public PropertyOrFieldServiceInfo(Type serviceType) : base(serviceType) { }

    /// <summary>Optional details: service key, if-unresolved policy, required service type.</summary>
    public override ServiceDetails Details => ServiceDetails.IfUnresolvedReturnDefaultIfNotRegistered;

    /// <summary>Either <see cref="PropertyInfo"/> or <see cref="FieldInfo"/>.</summary>
    public abstract MemberInfo Member { get; }

    /// <summary>Sets property or field value on provided holder object.</summary>
    /// <param name="holder">Holder of property or field.</param> <param name="value">Value to set.</param>
    public abstract void SetValue(object holder, object value);

    /// <summary>Create property or field service info out of provided member.</summary>
    public static PropertyOrFieldServiceInfo Of(MemberInfo member) =>
        member.ThrowIfNull() is PropertyInfo ? new Property((PropertyInfo)member) : (PropertyOrFieldServiceInfo)new Field((FieldInfo)member);

    /// <summary>Create property service info out of provided property.</summary>
    public static PropertyOrFieldServiceInfo Of(PropertyInfo property) => new Property(property);

    /// <summary>Create property service info out of provided property with the details of `IfUnresolved.Throw`.</summary>
    public static PropertyOrFieldServiceInfo OfRequiredProperty(PropertyInfo property) => new Property.RequiredProperty(property);

    /// <summary>Create field service info out of provided property.</summary>
    public static PropertyOrFieldServiceInfo Of(FieldInfo field) => new Field(field);

    private class Property : PropertyOrFieldServiceInfo
    {
        public override MemberInfo Member => _property;
        private readonly PropertyInfo _property;

        public override void SetValue(object holder, object value) => _property.SetValue(holder, value, null);

        public Property(PropertyInfo property) : base(property.PropertyType) => _property = property;
        public Property(PropertyInfo property, Type serviceType) : base(serviceType) => _property = property;

        public override ServiceInfo Create(Type serviceType, ServiceDetails details) =>
            serviceType == ServiceType ? new WithDetails(_property, details) : new WithDetails(_property, serviceType, details);

        public override string ToString() =>
            new StringBuilder().Print(this).Append(" as property ").Print(_property.Name).ToString();

        private sealed class WithDetails : Property
        {
            public override ServiceDetails Details { get; }
            public WithDetails(PropertyInfo property, ServiceDetails details) : base(property) => Details = details;
            public WithDetails(PropertyInfo property, Type serviceType, ServiceDetails details) : base(property, serviceType) => Details = details;
        }

        internal sealed class RequiredProperty : Property
        {
            public override ServiceDetails Details => ServiceDetails.Default; // with IfUnresolved.Throw
            public RequiredProperty(PropertyInfo property) : base(property) { }
        }
    }

    private class Field : PropertyOrFieldServiceInfo
    {
        public override MemberInfo Member => _field;
        private readonly FieldInfo _field;

        public Field(FieldInfo field) : base(field.FieldType) => _field = field;
        public Field(FieldInfo field, Type serviceType) : base(serviceType) => _field = field;

        public override ServiceInfo Create(Type serviceType, ServiceDetails details) =>
            serviceType == null ? new WithDetails(_field, details) : new WithDetails(_field, serviceType, details);

        public override void SetValue(object holder, object value) => _field.SetValue(holder, value);

        public override string ToString() =>
            new StringBuilder().Print(this).Append(" as field ").Print(_field.Name).ToString();

        private sealed class WithDetails : Field
        {
            public override ServiceDetails Details { get; }
            public WithDetails(FieldInfo field, ServiceDetails details) : base(field) => Details = details;
            public WithDetails(FieldInfo field, Type serviceType, ServiceDetails details) : base(field, serviceType) => Details = details;
        }
    }
}

/// <summary>Stored check results of two kinds: inherited down dependency chain and not.</summary>
[Flags]
public enum RequestFlags : ushort
{
    /// <summary>Nothing is set</summary>
    Default = 0,
    /// <summary>Not inherited</summary>
    TracksTransientDisposable = 1,
    /// <summary>Inherited</summary>
    IsSingletonOrDependencyOfSingleton = 1 << 1,
    /// <summary>Inherited</summary>
    IsWrappedInFunc = 1 << 2,
    /// <summary>Indicates that the request is the one from Resolve call.</summary>
    IsResolutionCall = 1 << 3,
    /// <summary>Non inherited</summary>
    OpensResolutionScope = 1 << 4,
    /// <summary>Non inherited</summary>
    StopRecursiveDependencyCheck = 1 << 5,
    /// <summary>Non inherited. Marks the expression to be added to generated resolutions to prevent infinite recursion</summary>
    IsGeneratedResolutionDependencyExpression = 1 << 6,
    /// <summary>Non inherited. Indicates the root service inside the function.</summary>
    IsDirectlyWrappedInFunc = 1 << 7,
    /// <summary>Request is isolated/copied and should no be re-used via pooling</summary>
    DoNotPoolRequest = 1 << 8,
    /// <summary>Can be set by the container to indicate that the expression cannot be cached</summary>
    DoNotCacheExpression = 1 << 9
}

/// <summary>Helper extension methods to use on the bunch of factories instead of lambdas to minimize allocations</summary>
public static class RequestTools
{
    /// <summary>Matching factory condition if any and the metadata if any</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static bool MatchFactoryConditionAndMetadata(this Request request, ServiceDetails details, Factory factory)
    {
        var setup = factory.Setup;
        return (setup.Condition == null || setup.Condition(request.Isolate()))
            && (details.MetadataKey == null && details.Metadata == null ||
                setup.MatchesMetadata(details.MetadataKey, details.Metadata));
    }

    /// <summary>Matching things</summary>
    public static bool MatchFactoryReuse(this Request r, Factory f) => f.Reuse?.CanApply(r) ?? true;

    /// <summary>Matching things</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool MatchGeneratedFactory(this Request r, Factory f) =>
        f.GeneratedFactories == null || f.GetGeneratedFactoryOrDefault(r, ifErrorReturnDefault: true) != null;

    /// <summary>Matching the factory condition, reuse, and close-generic constraints</summary>
    public static Factory MatchGeneratedFactoryByReuseAndConditionOrNull(this Request req, Factory fac)
    {
        var reuse = fac.Reuse;
        if (!fac.Setup.OpenResolutionScope && !req.MatchFactoryReuse(fac))
            return null;

        var condition = fac.Setup.Condition;
        if (condition != null && !condition(req.Isolate()))
            return null;

        // make the closing of the open-generic as the last check because it is a perf hog and some items may be already filtered out by predecessor checks.
        return fac.GeneratedFactories == null ? fac
            : fac.GetGeneratedFactoryOrDefault(req, ifErrorReturnDefault: true);
    }
}

/// <summary>Tracks the requested service and resolved factory details in a chain of nested dependencies.</summary>
public sealed class Request : IEnumerable<Request>, IPrintable
{
    internal static readonly RequestFlags InheritedFlags
        = RequestFlags.IsSingletonOrDependencyOfSingleton
        | RequestFlags.IsWrappedInFunc;

    /// <summary>Empty terminal request.</summary>
    public static readonly Request Empty =
        new Request(null, null, 0, 0, null, default, null, null, null);

    internal static readonly Expression EmptyRequestExpr =
        Field(typeof(Request).GetField(nameof(Empty))); // todo: @perf UnsafeAccessAttribute, wrap this thing into a util method

    /// <summary>Empty request which opens resolution scope.</summary>
    public static readonly Request EmptyOpensResolutionScope =
        new Request(null, null, 0, 0, null, RequestFlags.OpensResolutionScope, null, null, null);

    internal static Request CreateForValidation(Container container, ServiceInfo serviceInfo, Request[] depRequestStack)
    {
        var req = RentRequestOrNull();
        return req == null
            ? new Request(container, Empty, 1, 0, depRequestStack, RequestFlags.IsResolutionCall, serviceInfo, serviceInfo.GetActualServiceType(), null)
            : req.SetServiceInfo(container, Empty, 1, 0, depRequestStack, RequestFlags.IsResolutionCall, serviceInfo, serviceInfo.GetActualServiceType(), null);
    }

    internal static Request CreateFromServiceType(Container container, Type serviceType,
        IfUnresolved ifUnresolved = IfUnresolved.Throw)
    {
        if (serviceType != null && serviceType.IsOpenGeneric())
            Throw.It(Error.ResolvingOpenGenericServiceTypeIsNotPossible, serviceType);

        object serviceInfo = ifUnresolved == IfUnresolved.Throw ? serviceType : ServiceDetails.Of(ifUnresolved);

        var req = RentRequestOrNull();
        return req == null
            ? new Request(container, Empty, 1, 0, null, RequestFlags.IsResolutionCall, serviceInfo, serviceType, null)
            : req.SetServiceInfo(container, Empty, 1, 0, null, RequestFlags.IsResolutionCall, serviceInfo, serviceType, null);
    }

    internal static Request CreateFromServiceTypeOrInfo(Container container, object serviceTypeOrInfo,
        Request preResolveParent = null, RequestFlags flags = default, object[] inputArgs = null)
    {
        var serviceType = serviceTypeOrInfo as Type;
        var serviceInfo = serviceTypeOrInfo as ServiceInfo;
        if ((serviceType ?? serviceInfo.ServiceType).IsOpenGeneric())
            Throw.It(Error.ResolvingOpenGenericServiceTypeIsNotPossible, serviceType ?? serviceInfo.ServiceType);

        flags |= RequestFlags.IsResolutionCall;

        preResolveParent ??= Empty;
        if (preResolveParent.IsEmpty)
            flags |= preResolveParent.Flags; // inherits the OpensResolutionScope flag
        else
        {
            var parentDetails = preResolveParent.GetServiceDetails();
            if (parentDetails != null & parentDetails != ServiceDetails.Default)
            {
                var parentServiceType = preResolveParent.ActualServiceType;
                var parentFactoryType = preResolveParent.FactoryType;
                serviceTypeOrInfo = serviceType != null
                    ? serviceType.InheritInfoFromDependencyOwner(parentServiceType, parentDetails, container, parentFactoryType)
                    : serviceInfo.InheritInfoFromDependencyOwner(parentServiceType, parentDetails, container, parentFactoryType);
            }
            flags |= (preResolveParent.Flags & InheritedFlags); // keep parent flags that should be inherited
        }

        var actualServiceType = serviceTypeOrInfo as Type ?? ((ServiceInfo)serviceTypeOrInfo).GetActualServiceType();
        var inputArgExprs = inputArgs?.Map(static a => Constant(a));

        var req = RentRequestOrNull();
        return req == null
            ? new Request(container, preResolveParent, 1, 0, null, flags, serviceTypeOrInfo, actualServiceType, inputArgExprs)
            : req.SetServiceInfo(container, preResolveParent, 1, 0, null, flags, serviceTypeOrInfo, actualServiceType, inputArgExprs);
    }

    /// <summary>Creates the Resolve request. The container initiated the Resolve is stored within request.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Request Create(Container container, ServiceInfo serviceInfo,
        Request preResolveParent = null, RequestFlags flags = default, object[] inputArgs = null) =>
        CreateFromServiceTypeOrInfo(container, serviceInfo, preResolveParent, flags, inputArgs);

    /// <summary>Creates the Resolve request. The container initiated the Resolve is stored within request.</summary>
    public static Request Create(Container container, Type serviceType,
        object serviceKey = null, IfUnresolved ifUnresolved = IfUnresolved.Throw, Type requiredServiceType = null,
        Request preResolveParent = null, RequestFlags flags = default, object[] inputArgs = null)
    {
        var serviceTypeOrInfo = ServiceInfo.OrServiceType(serviceType, requiredServiceType, ifUnresolved, serviceKey);
        return serviceTypeOrInfo is Type st &&
            preResolveParent == null & flags == default & inputArgs == null
            ? CreateFromServiceType(container, st)
            : CreateFromServiceTypeOrInfo(container, serviceTypeOrInfo, preResolveParent, flags, inputArgs);
    }

    /// <summary>Available in runtime only, provides access to container initiated the request.</summary>
    public Container Container { get; private set; }

    /// <summary>Request immediate parent.</summary>
    public Request DirectParent;

    internal Request[] DepRequestStack;

    // mutable because of RequestFlags.AddedToResolutionExpressions
    /// <summary>Persisted request conditions</summary>
    public RequestFlags Flags; // todo: @perf combine with the FactoryType or other numeric fields

    // The field is mutable so that the ServiceKey or IfUnresolved can be changed in place.
    internal object ServiceTypeOrInfo; // the Type or ServiceInfo or ServiceDetails or ParameterInfo

    /// <summary>Input arguments provided with `Resolve`</summary>
    internal Expression[] InputArgExprs;

    /// <summary>Runtime known resolve factory, otherwise is <c>null</c></summary>
    internal Factory Factory => _factoryOrImplType as Factory;

    /// <summary>Resolved factory ID, used to identify applied decorator.</summary>
    public int FactoryID { get; private set; }

    /// <summary>Constructor selected by the reflection factory</summary>
    public ConstructorInfo SelectedConstructor { get; internal set; }

    // based on the parent(s) and current request FactoryID
    private int _hashCode; // todo: @perf do we need to calculate and store the hash code if it is not used 

    /// <summary>Type of factory: Service, Wrapper, or Decorator.</summary>
    public FactoryType FactoryType { get; private set; }

    internal int GetCombinedDecoratorAndFactoryID() =>
        FactoryType == FactoryType.Decorator ? (FactoryID | (DecoratedFactoryID << 16)) : FactoryID;

    /// <summary>Service implementation type if known.</summary>
    public Type ImplementationType => _factoryOrImplType as Type ?? Factory?.ImplementationType;
    internal object _factoryOrImplType;

    /// <summary>Sets the service factory already resolved by the wrapper to save for the future factory resolution</summary>
    public Request WithWrappedServiceFactory(Factory f)
    {
        _factoryOrImplType = f;
        return this;
    }

    /// <summary>Service reuse.</summary>
    public IReuse Reuse { get; private set; }

    /// <summary>ID of decorated factory in case of decorator factory type</summary>
    public int DecoratedFactoryID { get; private set; } // todo: @perf can we remove or combine it with the other fields?

    /// <summary>Number of nested dependencies. Set with each new Push.</summary>
    public int DependencyDepth; // todo: @perf @mem we may not need it at all because it is used only for pooling the requests

    /// <summary>The total dependency count</summary>
    public int DependencyCount; // todo: @perf combine with the DependencyDepth or other fields

    internal void DecreaseTrackedDependencyCountForParents()
    {
        var dependencyCount = DependencyCount;
        for (var p = DirectParent; !p.IsEmpty; p = p.DirectParent)
            p.DependencyCount -= dependencyCount;
    }
    internal void IncreaseTrackedDependencyCountForParents(int dependencyCount)
    {
        for (var p = DirectParent; !p.IsEmpty; p = p.DirectParent)
            p.DependencyCount += dependencyCount;
    }

    /// <summary>Indicates that request is empty initial request.</summary>
    public bool IsEmpty => DirectParent == null;

    /// <summary>Returns true if request is First in First Resolve call.</summary>
    public bool IsResolutionRoot => DirectParent != null && DirectParent.DirectParent == null;

    // todo: @simplify use it for checking the can cacheExpression
    internal bool AvoidExpressionCaching =>
        DirectParent != null && DirectParent.DirectParent == null ||// IsResolutionRoot
        (Flags & RequestFlags.IsDirectlyWrappedInFunc) != 0 | //IsDirectlyWrappedInFunc()
        InputArgExprs != null; // IsWrappedInFuncWithArgs()

    /// <summary>Returns true if request is First in Resolve call.</summary>
    public bool IsResolutionCall => (Flags & RequestFlags.IsResolutionCall) != 0;

    /// <summary>Not the root resolution call.</summary>
    public bool IsNestedResolutionCall => (Flags & RequestFlags.IsResolutionCall) != 0 && DirectParent?.DirectParent != null;

    /// <summary>Despite its name, returns true if request is first dependency in a service opening the scope</summary>
    public bool OpensResolutionScope => DirectParent != null && (DirectParent.Flags & RequestFlags.OpensResolutionScope) != 0;

    /// <summary>Checks if the request Or its parent is wrapped in Func. Use `IsDirectlyWrappedInFunc` for the direct Func wrapper.</summary>
    public bool IsWrappedInFunc() => (Flags & RequestFlags.IsWrappedInFunc) != 0;

    /// <summary>Checks if the request is directly wrapped in Func</summary>
    public bool IsDirectlyWrappedInFunc() => (Flags & RequestFlags.IsDirectlyWrappedInFunc) != 0;

    /// <summary>Checks if request has parent with service type of Func with arguments.</summary>
    public bool IsWrappedInFuncWithArgs() => InputArgExprs != null;

    /// <summary>Returns expression for func arguments.</summary>
    public Expression GetInputArgsExpr() =>
        InputArgExprs == null
            ? ConstantNull(typeof(object[]))
            : NewArrayInit(typeof(object), InputArgExprs.Map(static x => x.Type.IsValueType ? Convert<object>(x) : x)); // todo: @perf optimize Convert to object

    /// <summary>Indicates that requested service is transient disposable that should be tracked.</summary>
    public bool TracksTransientDisposable => (Flags & RequestFlags.TracksTransientDisposable) != 0;

    /// <summary>Indicates the request is singleton or has singleton upper in dependency chain.</summary>
    public bool IsSingletonOrDependencyOfSingleton => (Flags & RequestFlags.IsSingletonOrDependencyOfSingleton) != 0;

    /// <summary>Current scope</summary>
    public IScope CurrentScope => Container.CurrentScope;

    /// <summary>Singletons</summary>
    public IScope SingletonScope => Container.SingletonScope;

    /// <summary>Shortcut to issued container rules.</summary>
    public Rules Rules => Container.Rules;

    /// <summary>(optional) Made spec used for resolving request.</summary>
    public Made Made => Factory?.Made;

    /// <summary>Returns service parent skipping wrapper if any. To get direct parent use <see cref="DirectParent"/>.</summary>
    public Request Parent
    {
        get
        {
            var p = DirectParent;
            if (p != null)
                while (p.DirectParent != null && p.FactoryType == FactoryType.Wrapper)
                    p = p.DirectParent;
            return p;
        }
    }

    /// <summary>Requested service type.</summary>
    public Type ServiceType => ServiceTypeOrInfo is ServiceInfo i ? i.ServiceType : ActualServiceType;

    /// <summary>The required service type when assignable to service type, or service type otherwise.</summary>
    public Type ActualServiceType { get; private set; }

    /// <summary>Get the details</summary>
    public ServiceDetails GetServiceDetails() =>
        ServiceTypeOrInfo is ServiceInfo i ? i.Details :
        ServiceTypeOrInfo is ServiceDetails d ? d :
        ServiceDetails.Default; // is is default for ServiceType and ParameterInfo

    /// <summary>Optional service key to identify service of the same type.</summary>
    public object ServiceKey => GetServiceDetails().ServiceKey;

    /// <summary>Policy to deal with unresolved service.</summary>
    public IfUnresolved IfUnresolved => GetServiceDetails().IfUnresolved;

    /// <summary>Required service type if specified.</summary>
    public Type RequiredServiceType => GetServiceDetails().RequiredServiceType;

    /// <summary>Relative number representing reuse lifespan.</summary>
    public int ReuseLifespan => Reuse?.Lifespan ?? 0;

    /// <summary>Known implementation, or otherwise actual service type.</summary>
    public Type GetKnownImplementationOrServiceType() => _factoryOrImplType as Type ?? Factory?.ImplementationType ?? ActualServiceType;

    private const int _depRequestStackDefaultCapacity = 4;
    private ref Request GetOrPushDepRequestStack(int depDepth)
    {
        Debug.Assert(depDepth > 0);
        // Get advantage of the fact that we never reusing root request, because it always a single one for the graph.
        // So the depDepth is always starting from 1, and we can put its request into 0 index.
        var index = depDepth - 1;
        if (DepRequestStack != null)
        {
            // ensure that the index is in range by resizing the requests array
            if (index >= DepRequestStack.Length)
            {
                var newCount = DepRequestStack.Length << 1;
                while (index >= newCount)
                    newCount <<= 1;
                Array.Resize(ref DepRequestStack, newCount);
                // set the resized stack to the parents
                for (var p = DirectParent; p != null; p = p.DirectParent)
                {
                    if ((p.Flags & RequestFlags.IsResolutionCall) != 0)
                        break;
                    p.DepRequestStack = DepRequestStack;
                }
            }
        }
        else
        {
            var capacity = _depRequestStackDefaultCapacity;
            while (index >= capacity)
                capacity <<= 1;
            DepRequestStack = new Request[capacity];
            for (var p = DirectParent; p != null; p = p.DirectParent)
            {
                if ((p.Flags & RequestFlags.IsResolutionCall) != 0)
                    break;
                p.DepRequestStack = DepRequestStack;
            }
        }
        return ref DepRequestStack[index];
    }

    /// <summary>Creates new request with provided info, and links current request as a parent.
    /// Allows to set some additional flags. Existing/parent request should be resolved to 
    /// factory via `WithResolvedFactory` before pushing info into it.</summary>
    public Request Push(ServiceInfo info, RequestFlags additionalFlags = default)
    {
        if (FactoryID == 0)
            Throw.It(Error.PushingToRequestWithoutFactory, info, this);

        var details = GetServiceDetails();
        if (details != null & details != ServiceDetails.Default)
            info = info.InheritInfoFromDependencyOwner(ActualServiceType, details, Container, FactoryType);

        var flags = Flags & InheritedFlags | additionalFlags;
        ref var req = ref GetOrPushDepRequestStack(DependencyDepth);
        return req == null
            ? req = new Request(Container, this, DependencyDepth + 1, 0, DepRequestStack, flags, info, info.GetActualServiceType(), InputArgExprs)
            : req.SetServiceInfo(Container, this, DependencyDepth + 1, 0, DepRequestStack, flags, info, info.GetActualServiceType(), InputArgExprs);
    }

    /// <summary>Creates new request with provided parameter info, and links the current request as a parent.
    /// Allows to set some additional flags. Existing/parent request should be resolved to 
    /// factory via `WithResolvedFactory` before pushing info into it.</summary>
    public Request Push(ParameterInfo parameter, RequestFlags additionalFlags = default)
    {
        if (FactoryID == 0)
            Throw.It(Error.PushingToRequestWithoutFactory, ParameterServiceInfo.Of(parameter), this);

        object info = parameter;
        var actualServiceType = parameter.ParameterType;

        // todo: @perf so in case where we have just a different IfUnresolved, then we have a non default ServiceDetails, which means a whole lot of additional logic being executed with not actual need, right?
        var details = GetServiceDetails();
        if (details != null && details != ServiceDetails.Default)
        {
            info = actualServiceType.InheritInfoFromDependencyOwner(ActualServiceType, details, Container, FactoryType);
            if (info is ServiceInfo i)
                actualServiceType = i.GetActualServiceType();
        }

        var flags = Flags & InheritedFlags | additionalFlags;
        ref var req = ref GetOrPushDepRequestStack(DependencyDepth);
        return req == null
            ? req = new Request(Container, this, DependencyDepth + 1, 0, DepRequestStack, flags, info, actualServiceType, InputArgExprs)
            : req.SetServiceInfo(Container, this, DependencyDepth + 1, 0, DepRequestStack, flags, info, actualServiceType, InputArgExprs);
    }

    /// <summary>Creates new request with provided info, and links current request as a parent.
    /// Allows to set some additional flags. Existing/parent request should be resolved to 
    /// factory via `WithResolvedFactory` before pushing info into it.</summary>
    public Request PushServiceType(Type serviceType, RequestFlags additionalFlags = default)
    {
        object serviceTypeOrInfo = serviceType;
        // todo: @perf so in case where we have just a different IfUnresolved, then we have a non default ServiceDetails, which means a whole lot of additional logic being executed with not actual need, right?
        var details = GetServiceDetails();
        if (details != null & details != ServiceDetails.Default)
        {
            serviceTypeOrInfo = serviceType.InheritInfoFromDependencyOwner(ActualServiceType, details, Container, FactoryType);
            serviceType = serviceTypeOrInfo as Type ?? ((ServiceInfo)serviceTypeOrInfo).GetActualServiceType();
        }

        var flags = Flags & InheritedFlags | additionalFlags;
        ref var req = ref GetOrPushDepRequestStack(DependencyDepth);
        return req == null
            ? req = new Request(Container, this, DependencyDepth + 1, 0, DepRequestStack, flags, serviceTypeOrInfo, serviceType, InputArgExprs)
            : req.SetServiceInfo(Container, this, DependencyDepth + 1, 0, DepRequestStack, flags, serviceTypeOrInfo, serviceType, InputArgExprs);
    }

    /// <summary>Composes service description into <see cref="ServiceInfo"/> and Pushes the new request.</summary>
    public Request Push(Type serviceType, object serviceKey = null,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, Type requiredServiceType = null, RequestFlags flags = default) =>
        Push(ServiceInfo.Of(serviceType.ThrowIfNull().ThrowIf(serviceType.IsOpenGeneric(), Error.ResolvingOpenGenericServiceTypeIsNotPossible),
            requiredServiceType, ifUnresolved, serviceKey), flags);

    #region Used in generated expression

    /// <summary>Creates info by supplying the properties and chaining it with current (parent) info.</summary>
    public Request Push(Type serviceType, int factoryID, Type implementationType, IReuse reuse) =>
        Push(serviceType, null, null, null, null, IfUnresolved.Throw,
            factoryID, FactoryType.Service, implementationType, reuse, default, 0);

    internal static readonly Lazy<MethodInfo> PushMethodWith4Args = Lazy.Of(() =>
        typeof(Request).Method("Push", typeof(Type), typeof(int), typeof(Type), typeof(IReuse)));

    /// <summary>Creates info by supplying the properties and chaining it with current (parent) info.</summary>
    public Request Push(Type serviceType, int factoryID, Type implementationType, IReuse reuse, RequestFlags flags) =>
        Push(serviceType, null, null, null, null, IfUnresolved.Throw,
            factoryID, FactoryType.Service, implementationType, reuse, flags, 0);

    internal static readonly Lazy<MethodInfo> PushMethodWith5Args = Lazy.Of(() =>
        typeof(Request).Method("Push", typeof(Type), typeof(int), typeof(Type), typeof(IReuse), typeof(RequestFlags)));

    /// <summary>Creates info by supplying the properties and chaining it with current (parent) info.</summary>
    public Request Push(Type serviceType, Type requiredServiceType, object serviceKey,
        int factoryID, FactoryType factoryType, Type implementationType, IReuse reuse, RequestFlags flags) =>
        Push(serviceType, requiredServiceType, serviceKey, null, null, IfUnresolved.Throw,
            factoryID, factoryType, implementationType, reuse, flags, 0);

    internal static readonly Lazy<MethodInfo> PushMethodWith8Args = Lazy.Of(() =>
        typeof(Request).Method("Push", typeof(Type), typeof(Type), typeof(object),
            typeof(int), typeof(FactoryType), typeof(Type), typeof(IReuse), typeof(RequestFlags)));

    /// <summary>Creates info by supplying the properties and chaining it with current (parent) info.</summary>
    public Request Push(Type serviceType, Type requiredServiceType, object serviceKey, IfUnresolved ifUnresolved,
        int factoryID, FactoryType factoryType, Type implementationType, IReuse reuse, RequestFlags flags,
        int decoratedFactoryID) =>
        Push(serviceType, requiredServiceType, serviceKey, null, null, ifUnresolved,
            factoryID, factoryType, implementationType, reuse, flags, decoratedFactoryID);

    internal static readonly Lazy<MethodInfo> PushMethodWith10Args = Lazy.Of(() =>
        typeof(Request).Method("Push",
            typeof(Type), typeof(Type), typeof(object), typeof(IfUnresolved),
            typeof(int), typeof(FactoryType), typeof(Type), typeof(IReuse), typeof(RequestFlags), typeof(int)));

    /// <summary>Creates info by supplying all the properties and chaining it with current (parent) info.</summary>
    public Request Push(
        Type serviceType, Type requiredServiceType, object serviceKey, string metadataKey, object metadata, IfUnresolved ifUnresolved,
        int factoryID, FactoryType factoryType, Type implementationType, IReuse reuse, RequestFlags flags, int decoratedFactoryID)
    {
        // var serviceInfo = ServiceInfo.Of(serviceType, requiredServiceType, ifUnresolved, serviceKey, metadataKey, metadata);
        var serviceInfoOrType = ServiceInfo.OrServiceType(serviceType, requiredServiceType, ifUnresolved, serviceKey, metadataKey, metadata);
        var actualServiceType = serviceInfoOrType as Type ?? ((ServiceInfo)serviceInfoOrType).GetActualServiceType();
        return new Request(Container, this, DependencyDepth + 1, 0, null, flags, serviceInfoOrType, actualServiceType,
            InputArgExprs, implementationType, factoryID, factoryType, reuse, decoratedFactoryID);
    }

    internal static readonly Lazy<MethodInfo> PushMethodWith12Args = Lazy.Of(() =>
        typeof(Request).Method("Push",
        typeof(Type), typeof(Type), typeof(object), typeof(string), typeof(object), typeof(IfUnresolved),
        typeof(int), typeof(FactoryType), typeof(Type), typeof(IReuse), typeof(RequestFlags), typeof(int)));

    #endregion

    /// <summary>Allow to switch current service info to the new one, e.g. in decorators</summary>
    public Request WithChangedType<S>(S state, Func<Type, S, Type> getInfo)
    {
        var oldServiceType = ServiceType;
        var newServiceType = getInfo(oldServiceType, state);
        if (newServiceType == oldServiceType)
            return this;
        object serviceInfo =
            ServiceTypeOrInfo is ParameterInfo p ? ParameterServiceInfo.Of(p, newServiceType, ServiceDetails.Default) :
            ServiceTypeOrInfo is ServiceInfo i ? i.WithType(newServiceType) :
            newServiceType;
        var actualServiceType = serviceInfo is Type t ? t : ((ServiceInfo)serviceInfo).GetActualServiceType();
        return new Request(Container, DirectParent, DependencyDepth, DependencyCount,
            DepRequestStack, Flags, serviceInfo, actualServiceType, InputArgExprs,
            _factoryOrImplType, FactoryID, FactoryType, Reuse, DecoratedFactoryID);
    }

    /// Produces the new request with the changed `ifUnresolved` or returns original request otherwise
    public Request WithIfUnresolved(IfUnresolved ifUnresolved)
    {
        ServiceInfo newServiceInfo = null;
        var oldServiceInfo = ServiceTypeOrInfo;
        if (oldServiceInfo is ServiceInfo i)
        {
            if (i.Details.IfUnresolved == ifUnresolved ||
                (newServiceInfo = i.WithIfUnresolved(ifUnresolved)) == i)
                return this;
        }
        else
        {
            if (ifUnresolved == IfUnresolved.Throw)
                return this;
            newServiceInfo = oldServiceInfo is ParameterInfo pi
                ? ParameterServiceInfo.Of(pi, ActualServiceType, ServiceDetails.Of(ifUnresolved))
                : ServiceInfo.Of(ActualServiceType, ifUnresolved);
        }

        return new Request(Container, DirectParent, DependencyDepth, DependencyCount,
            DepRequestStack, Flags, newServiceInfo, newServiceInfo.GetActualServiceType(), InputArgExprs,
            _factoryOrImplType, FactoryID, FactoryType, Reuse, DecoratedFactoryID);
    }

    /// <summary>Updates the flags</summary>
    public Request WithFlags(RequestFlags newFlags) =>
        new Request(Container, DirectParent, DependencyDepth, DependencyCount,
            DepRequestStack, newFlags, ServiceTypeOrInfo, ActualServiceType, InputArgExprs,
            _factoryOrImplType, FactoryID, FactoryType, Reuse, DecoratedFactoryID);

    // note: Mutates the request, required for the proper caching
    /// <summary>Sets service key to the passed value. Required for multiple default services to change null key to
    /// actual <see cref="DefaultKey"/></summary>
    public void ChangeServiceKey(object serviceKey) =>
        ServiceTypeOrInfo
        = ServiceTypeOrInfo is ServiceInfo i
            ? i.Create(i.ServiceType, ServiceDetails.WithServiceKey(i.Details, serviceKey)) // todo: @unclear check for the custom value
        : ServiceTypeOrInfo is ParameterInfo pi
            ? ParameterServiceInfo.Of(pi, ActualServiceType, ServiceDetails.WithServiceKey(ServiceDetails.Default, serviceKey))
        : ServiceInfo.Of(ActualServiceType, serviceKey);

    /// <summary>Prepends input arguments to existing arguments in request. It is done because the
    /// nested Func/Action input argument has a priority over outer argument.
    /// The arguments are provided by Func and Action wrappers, or by `args` parameter in Resolve call.</summary>
    public Request WithInputArgs(Expression[] inputArgs) =>
        new Request(Container, DirectParent, DependencyDepth, DependencyCount,
            DepRequestStack, Flags, ServiceTypeOrInfo, ActualServiceType, inputArgs.Append(InputArgExprs),
            _factoryOrImplType, FactoryID, FactoryType, Reuse, DecoratedFactoryID);

    /// <summary>Returns new request with set implementation details.</summary>
    /// <param name="factory">Factory to which request is resolved.</param>
    /// <param name="skipRecursiveDependencyCheck">(optional) does not check for recursive dependency.
    /// Use with caution. Make sense for Resolution expression.</param>
    /// <param name="skipCaptiveDependencyCheck">(optional) allows to skip reuse mismatch aka captive dependency check.</param>
    /// <param name="copyRequest">Make a defensive copy of request.</param>
    /// <returns>New request with set factory.</returns>
    public Request WithResolvedFactory(Factory factory,
        bool skipRecursiveDependencyCheck = false, bool skipCaptiveDependencyCheck = false, bool copyRequest = false)
    {
        // resolving the factory for the second time, usually happens in decorators, FactoryID is 0 for factory resolved for collection item
        var factoryId = factory.FactoryID;
        var decoratedFactoryID = 0;
        if (Factory != null & FactoryID != 0)
        {
            if (FactoryID == factoryId)
                return this; // stop resolving to the same factory twice
            if (FactoryType != FactoryType.Decorator && factory.FactoryType == FactoryType.Decorator)
                decoratedFactoryID = FactoryID;
        }

        // it is required to nullify the TD tracking when factory is resolved multiple times, e.g. for decorator
        var flags = Flags & ~RequestFlags.TracksTransientDisposable;
        if (skipRecursiveDependencyCheck)
            flags |= RequestFlags.StopRecursiveDependencyCheck;

        var setup = factory.Setup;

        var reuse =
            InputArgExprs != null && Rules.IgnoringReuseForFuncWithArgs ? DryIoc.Reuse.Transient :
            factory.Reuse != null ? factory.Reuse :
            setup.UseParentReuse ? (DirectParent.IsEmpty ? Rules.DefaultReuse : null) : // the `null` here signals to find the parent reuse
            factory.FactoryType == FactoryType.Decorator && (setup.UseDecorateeReuse | Rules.UseDecorateeReuseForDecorators) ? Reuse : // already resolved decoratee reuse
            factory.FactoryType == FactoryType.Wrapper ? DryIoc.Reuse.Transient :
            Rules.DefaultReuse;

        IReuse firstParentNonTransientReuseOrNull = null;
        if (!DirectParent.IsEmpty)
        {
            var checkRecursiveDependency = !skipRecursiveDependencyCheck &
                factory.FactoryType == FactoryType.Service;

            var reuseLifespan = reuse?.Lifespan ?? 0;

            var checkCaptiveDependency = !skipCaptiveDependencyCheck && !IsDirectlyWrappedInFunc() && !factory.Setup.OpenResolutionScope &&
                (Rules.ThrowIfDependencyHasShorterReuseLifespan && reuseLifespan > 0 ||
                    Rules.ThrowIfScopedOrSingletonHasTransientDependency && reuseLifespan == 0);

            var scopedOrSingleton = checkCaptiveDependency &&
                (reuse as CurrentScopeReuse)?.ScopedOrSingleton == true;

            // Means we are incrementing the count when resolving the Factory for the first time,
            // and not twice for the decorators (for the decorator the Factory would be not null and set to the Decorator factory)
            var dependencyCountIncrement = Factory == null ? 1 : 0;

            for (var p = DirectParent; !p.IsEmpty; p = p.DirectParent)
            {
                if (checkRecursiveDependency)
                {
                    if ((p.Flags & RequestFlags.StopRecursiveDependencyCheck) != 0)
                        checkRecursiveDependency = false; // stop the check
                    else if (p.FactoryID == factoryId)
                        Throw.It(Error.RecursiveDependencyDetected, PrintRequest(factoryId));
                }

                if (checkCaptiveDependency)
                {
                    if (p.OpensResolutionScope ||
                        scopedOrSingleton && p.Reuse is SingletonReuse ||
                        p.FactoryType == FactoryType.Wrapper && p.ActualServiceType.IsFunc())
                        checkCaptiveDependency = false; // stop the check
                    else if (p.FactoryType != FactoryType.Wrapper && p.ReuseLifespan > reuseLifespan)
                        Throw.It(Error.DependencyHasShorterReuseLifespan, PrintCurrent(), reuse, p);
                }

                if (firstParentNonTransientReuseOrNull == null)
                {
                    if (p.FactoryType != FactoryType.Wrapper)
                    {
                        if (p.Reuse != DryIoc.Reuse.Transient)
                            firstParentNonTransientReuseOrNull = p.Reuse;
                    }
                    else if (p.ActualServiceType.IsFunc())
                        firstParentNonTransientReuseOrNull = Rules.DefaultReuse;
                }

                p.DependencyCount += dependencyCountIncrement;
            }

            if (reuse == null) // for the `setup.UseParentReuse`
                reuse = firstParentNonTransientReuseOrNull ?? Rules.DefaultReuse;
        }

        if (reuse == DryIoc.Reuse.Singleton)
        {
            flags |= RequestFlags.IsSingletonOrDependencyOfSingleton;
        }
        else if (reuse == DryIoc.Reuse.Transient && !setup.PreventDisposal &&
            (setup.TrackDisposableTransient || !setup.AllowDisposableTransient && Rules.TrackingDisposableTransients) &&
            typeof(IDisposable).IsAssignableFrom(factory.ImplementationType ?? ActualServiceType))
        {
            if (firstParentNonTransientReuseOrNull != null)
            {
                reuse = firstParentNonTransientReuseOrNull;
                flags |= RequestFlags.TracksTransientDisposable;
            }
            else if (!IsWrappedInFunc())
            {
                reuse = DryIoc.Reuse.ScopedOrSingleton;
                flags |= RequestFlags.TracksTransientDisposable;
            }
        }

        if (copyRequest)
        {
            IsolateRequestChain();
            return new Request(Container, DirectParent, DependencyDepth, DependencyCount, null, flags, ServiceTypeOrInfo, ActualServiceType, InputArgExprs,
                factory, factoryId, factory.FactoryType, reuse, decoratedFactoryID);
        }

        Flags = flags;
        SetResolvedFactory(factory, factoryId, factory.FactoryType, reuse, decoratedFactoryID);
        return this;
    }

    internal Request WithResolvedFactoryUnsafe(Factory factory)
    {
        // resolving the factory for the second time, usually happens in decorators, FactoryID is 0 for factory resolved for collection item
        var decoratedFactoryID = 0;
        if (Factory != null && FactoryID != 0)
        {
            if (FactoryID == factory.FactoryID)
                return this; // stop resolving to the same factory twice
            if (FactoryType != FactoryType.Decorator && factory.FactoryType == FactoryType.Decorator)
                decoratedFactoryID = FactoryID;
        }

        Flags &= ~RequestFlags.TracksTransientDisposable;
        SetResolvedFactory(factory, factory.FactoryID, factory.FactoryType, factory.Reuse, decoratedFactoryID);
        return this;
    }

    /// <summary>Check for the first recursive parent in the up-chain.</summary>
    public bool HasRecursiveParent(int factoryID)
    {
        for (var p = DirectParent; !p.IsEmpty; p = p.DirectParent)
        {
            if ((p.Flags & RequestFlags.StopRecursiveDependencyCheck) != 0)
                break; // stops the further upward checking
            if (p.FactoryID == factoryID)
                return true;
        }
        return false;
    }

    /// <summary>Check for the parents until very end.</summary>
    public bool HasRecursiveParentUntilResolutionRoot(int factoryID)
    {
        for (var p = DirectParent; !p.IsEmpty; p = p.DirectParent)
            if (p.FactoryID == factoryID)
                return true;
        return false;
    }

    /// <summary>If request corresponds to dependency injected into parameter,
    /// then method calls <paramref name="parameter"/> handling and returns its result.
    /// If request corresponds to property or field, then method calls respective handler.
    /// If request does not correspond to dependency, then calls <paramref name="root"/> handler.</summary>
    public TResult Is<TResult>(
        Func<TResult> root = null,
        Func<ParameterInfo, TResult> parameter = null,
        Func<PropertyInfo, TResult> property = null,
        Func<FieldInfo, TResult> field = null)
    {
        var info = ServiceTypeOrInfo;
        if (info is ParameterServiceInfo par)
        {
            if (parameter != null)
                return parameter(par.Parameter);
        }
        else if (info is PropertyOrFieldServiceInfo propOrField)
        {
            if (propOrField.Member is PropertyInfo propertyInfo)
            {
                if (property != null)
                    return property(propertyInfo);
            }
            else if (field != null)
                return field((FieldInfo)propOrField.Member);
        }
        else if (root != null)
            return root();

        return default(TResult);
    }

    /// <summary>Enumerates self and all request stack parents.</summary>
    public IEnumerator<Request> GetEnumerator()
    {
        for (var r = this; !r.IsEmpty; r = r.DirectParent)
            yield return r;
    }

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>Prints current request info only (no parents printed) to provided builder.</summary>
    public StringBuilder PrintCurrent(StringBuilder s = null)
    {
        s ??= new StringBuilder();

        if (IsEmpty)
            return s.Append("<empty request>");

        var isResolutionCall = false;
        if (isResolutionCall = IsNestedResolutionCall)
            s.Append("resolution call dependency ");
        else if (isResolutionCall = IsResolutionRoot)
            s.Append("resolution root ");

        if (FactoryID != 0) // request is with resolved factory
        {
            if (Reuse != DryIoc.Reuse.Transient)
                s.Append(Reuse).Append(' ');

            if (FactoryType != FactoryType.Service)
                s.Append(FactoryType.ToString().ToLower()).Append(' ');

            var implType = ImplementationType;
            if (implType != null && implType != ServiceType)
                s.Print(implType).Append(": ");
        }

        if (ServiceTypeOrInfo is ParameterInfo pi)
            s.Append(ParameterServiceInfo.Of(pi));
        else
            s.Print(ServiceTypeOrInfo);

        if (FactoryID != 0)
            s.Append(" FactoryID=").Append(FactoryID);

        if (DecoratedFactoryID != 0)
            s.Append(" DecoratedFactoryId=").Append(DecoratedFactoryID);

        if (!InputArgExprs.IsNullOrEmpty())
            s.Append(" with passed arguments: ").Print(InputArgExprs);

        // avoid the non-relevant noise in the Flags output
        var flags = Flags;
        if (isResolutionCall)
            flags &= ~RequestFlags.IsResolutionCall;
        flags &= ~RequestFlags.DoNotPoolRequest;
        if ((flags & RequestFlags.IsDirectlyWrappedInFunc) != 0)
            flags &= ~RequestFlags.IsWrappedInFunc;
        if (Reuse is SingletonReuse)
            flags &= ~RequestFlags.IsSingletonOrDependencyOfSingleton;
        if (flags != default(RequestFlags))
            s.Append(" Flags=").Print(flags);

        return s;
    }

    /// <summary>Prints full stack of requests starting from current one using <see cref="PrintCurrent"/>.</summary>
    public StringBuilder PrintRequest(int recursiveFactoryID = 0)
    {
        if (IsEmpty)
            return new StringBuilder("<empty request>");

        var s = PrintCurrent(new StringBuilder());

        s = recursiveFactoryID == 0 ? s : s.Append(" <--recursive");
        foreach (var parent in DirectParent)
        {
            s = parent.PrintCurrent(s.AppendLine().Append("  in "));
            if (parent.FactoryID == recursiveFactoryID)
                s = s.Append(" <--recursive");
        }

        if (Container != null)
            s.AppendLine().Append("  from ").Append(Container);

        return s;
    }

    /// <summary>Prints whole request chain.</summary>
    public override string ToString() => PrintRequest().ToString();

    /// <inheritdoc/>
    public StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer) =>
        s.Append(PrintRequest());

    /// <summary>Returns true if request info and passed object are equal, and their parents recursively are equal.</summary>
    public override bool Equals(object obj) => Equals(obj as Request);

    /// <summary>Returns true if request info and passed info are equal, and their parents recursively are equal.</summary>
    public bool Equals(Request other) =>
        other != null && EqualsWithoutParent(other)
            && (DirectParent == null && other.DirectParent == null
            || (DirectParent != null && DirectParent.EqualsWithoutParent(other.DirectParent)));

    // todo: Seems like Equals and GetHashCode are not used anymore - can we remove them
    // todo: Should we include InputArgs and DecoratedFactoryID and what about flags? 
    // todo: Should we add and rely on Equals of ServiceInfo and Reuse?
    // todo: The equals calculated differently comparing to HashCode, may be we can use FactoryID for Equals as well?
    /// <summary>Compares self properties but not the parents.</summary>
    public bool EqualsWithoutParent(Request other) =>
        other.ServiceType == ServiceType &&
        other.FactoryType == FactoryType &&
        other.ImplementationType == ImplementationType &&
        other.GetServiceDetails().Equals(GetServiceDetails())

        // todo: Move to Reuse?
        && other.Reuse?.GetType() == Reuse?.GetType()
        && other.Reuse?.Lifespan == Reuse?.Lifespan
        && Equals(other.Reuse?.Name, Reuse?.Name);

    /// <summary>Calculates the combined hash code based on factory IDs.</summary>
    public override int GetHashCode() => _hashCode;

    // Initial request without the factory info
    internal Request(Container container, Request parent, int dependencyDepth, int dependencyCount,
            Request[] depRequestStack, RequestFlags flags, object serviceInfo, Type actualServiceType, Expression[] inputArgExprs)
    {
        Container = container;
        DirectParent = parent;
        DependencyCount = dependencyCount;
        DependencyDepth = dependencyDepth;
        DepRequestStack = depRequestStack;
        Flags = flags;
        ServiceTypeOrInfo = serviceInfo;
        ActualServiceType = actualServiceType;
        InputArgExprs = inputArgExprs;
    }

    // Request with resolved factory state
    private Request(Container container,
        Request parent, int dependencyDepth, int dependencyCount, Request[] depRequestStack,
        RequestFlags flags, object serviceInfo, Type actualServiceType, Expression[] inputArgExprs,
        object factoryOrImplType, int factoryID, FactoryType factoryType, IReuse reuse, int decoratedFactoryID)
        : this(container, parent, dependencyDepth, dependencyCount, depRequestStack, flags, serviceInfo, actualServiceType, inputArgExprs) =>
        SetResolvedFactory(factoryOrImplType, factoryID, factoryType, reuse, decoratedFactoryID);

    internal Request Isolate()
    {
        Flags |= RequestFlags.DoNotPoolRequest;
        return this;
    }

    [MethodImpl((MethodImplOptions)256)]
    internal bool CanCache() =>
        (Flags & RequestFlags.DoNotCacheExpression) == 0;

    /// Severe the connection with the request pool up to the parent so that no one can change the Request state
    internal Request IsolateRequestChain()
    {
        Request r = this;
        while (r.DirectParent != null)
        {
            if (r.DepRequestStack != null)
            {
                // severe the requests links with the stack starting from the parent
                var reqs = r.DepRequestStack;
                for (var i = 0; (uint)i < reqs.Length; ++i)
                    if (reqs[i] == r)
                    {
                        reqs[i] = null;
                        break;
                    }
                r.DepRequestStack = null;
            }
            if ((r.Flags & RequestFlags.IsResolutionCall) != 0)
            {
                r.Isolate();
                break;
            }
            r = r.DirectParent;
        }
        return this;
    }

    private static Request _pooledRequest;
    internal static Request RentRequestOrNull() => Interlocked.Exchange(ref _pooledRequest, null);
    internal void ReturnToPool()
    {
        if (_pooledRequest == null & (Flags & RequestFlags.DoNotPoolRequest) == 0)
            _pooledRequest = CleanBeforePool();
    }

    internal Request CleanBeforePool()
    {
        // be sure and double check that it is cleaning all request fields
        DirectParent = default;
        DepRequestStack = default;
        ServiceTypeOrInfo = default;
        ActualServiceType = default;
        InputArgExprs = default;
        Container = default;
        DependencyDepth = default;
        DependencyCount = default;
        Flags = default;
        _factoryOrImplType = default;
        Reuse = default;
        FactoryID = default;
        DecoratedFactoryID = default;
        _hashCode = default;
        FactoryType = default;
        return this;
    }

    internal Request SetServiceInfo(Container container, Request parent, int dependencyDepth, int dependencyCount,
        Request[] depRequestStack, RequestFlags flags, object serviceTypeOrInfo, Type actualServiceType, Expression[] inputArgExprs)
    {
        Container = container;
        DirectParent = parent;
        DependencyDepth = dependencyDepth;
        DependencyCount = dependencyCount;
        DepRequestStack = depRequestStack;
        Flags = flags;
        ServiceTypeOrInfo = serviceTypeOrInfo;
        ActualServiceType = actualServiceType;
        InputArgExprs = inputArgExprs;
        // resets the factory info:
        _factoryOrImplType = null;
        SelectedConstructor = null;
        Reuse = null;
        FactoryID = 0;
        DecoratedFactoryID = 0;
        _hashCode = parent?._hashCode ?? 0;
        FactoryType = default;
        return this;
    }

    private void SetResolvedFactory(object factoryOrImplType, int factoryID, FactoryType factoryType, IReuse reuse, int decoratedFactoryID)
    {
        _factoryOrImplType = factoryOrImplType;
        SelectedConstructor = null;
        FactoryID = factoryID;
        FactoryType = factoryType;
        Reuse = reuse;
        DecoratedFactoryID = decoratedFactoryID;
        _hashCode = DirectParent == null ? FactoryID : Hasher.Combine(DirectParent._hashCode, FactoryID);
    }
}

/// <summary>Type of services supported by Container.</summary>
public enum FactoryType : byte
{
    /// <summary>(default) Defines normal service factory</summary>
    Service = 0,
    /// <summary>Defines decorator factory</summary>
    Decorator,
    /// <summary>Defines wrapper factory.</summary>
    Wrapper
};

/// <summary>Base class to store optional <see cref="Factory"/> settings.</summary>
public abstract class Setup
{
    /// <summary>Factory type is required to be specified by concrete setups as in
    /// <see cref="ServiceSetup"/>, <see cref="DecoratorSetup"/>, <see cref="WrapperSetup"/>.</summary>
    public abstract FactoryType FactoryType { get; }

    /// <summary>Predicate to check if factory could be used for resolved request.</summary>
    public Func<Request, bool> Condition { get; }

    /// <summary>Relative disposal order when defined. Greater number, later dispose.</summary>
    public int DisposalOrder { get; }

    /// <summary>Arbitrary metadata object associated with Factory/Implementation, may be a dictionary of key-values.</summary>
    public virtual object Metadata => null;

    /// <summary>Returns true if passed meta key and value match the setup metadata.</summary>
    public bool MatchesMetadata(string metadataKey, object metadata)
    {
        if (metadataKey == null)
            return Equals(metadata, Metadata);
        return Metadata is IDictionary<string, object> metaDict
            && metaDict.TryGetValue(metadataKey, out var metaValue)
            && Equals(metaValue, metadata);
    }

    /// <summary>Retrieve the whole metadata object matched to the type or value from the metadata dictionary matched by the type</summary>
    public object GetMetadataValueMatchedByMetadataType(Type metadataType)
    {
        var metadata = Metadata;
        if (metadataType != typeof(object) &&
            metadata is IDictionary<string, object> metadataDict && metadataType != typeof(IDictionary<string, object>))
        {
            foreach (var kv in metadataDict)
            {
                metadata = kv.Value;
                if (metadata != null && metadataType.IsAssignableFrom(metadata.GetType()))
                    return metadata;
            }
            return null;
        }
        return metadata;
    }

    /// <summary>Indicates that injected expression should be:
    /// <c><![CDATA[r.Resolver.Resolve<IDependency>(...)]]></c>
    /// instead of: <c><![CDATA[new Dependency(...)]]></c></summary>
    public bool AsResolutionCall => (_settings & Settings.AsResolutionCall) != 0;

    /// <summary>Setup with the only setting of `AsResolutionCall</summary>` 
    public static readonly Setup AsResolutionCallSetup =
        new ServiceSetup { _settings = Settings.AsResolutionCall };

    /// <summary>Works as `AsResolutionCall` but only with `Rules.UsedForExpressionGeneration`</summary>
    public bool AsResolutionCallForExpressionGeneration => (_settings & Settings.AsResolutionCallForExpressionGeneration) != 0;

    /// <summary>Specifies to use `asResolutionCall` but only in expression generation context, e.g. for compile-time generation</summary>
    internal static readonly Setup AsResolutionCallForGeneratedExpressionSetup =
        new ServiceSetup { _settings = Settings.AsResolutionCallForExpressionGeneration };

    internal Setup WithAsResolutionCallForGeneratedExpression()
    {
        if (AsResolutionCallForExpressionGeneration)
            return this;

        if (this == Default)
            return AsResolutionCallForGeneratedExpressionSetup;

        var setupClone = (Setup)MemberwiseClone();
        setupClone._settings |= Settings.AsResolutionCallForExpressionGeneration;
        return setupClone;
    }

    /// <summary>Marks service (not a wrapper or decorator) registration that is expected to be resolved via Resolve call.</summary>
    public bool AsResolutionRoot => (_settings & Settings.AsResolutionRoot) != 0;

    /// <summary>Opens scope, also implies <see cref="AsResolutionCall"/>.</summary>
    public bool OpenResolutionScope => (_settings & Settings.OpenResolutionScope) != 0;

    /// <summary>Stores reused instance as WeakReference.</summary>
    public bool WeaklyReferenced => (_settings & Settings.WeaklyReferenced) != 0;

    /// <summary>Allows registering transient disposable.</summary>
    public bool AllowDisposableTransient => (_settings & Settings.AllowDisposableTransient) != 0;

    /// <summary>Turns On tracking of disposable transient dependency in parent scope or in open scope if resolved directly.</summary>
    public bool TrackDisposableTransient => (_settings & Settings.TrackDisposableTransient) != 0;

    /// <summary>Instructs to use parent reuse. Applied only if <see cref="Factory.Reuse"/> is not specified.</summary>
    public bool UseParentReuse => (_settings & Settings.UseParentReuse) != 0;

    /// <summary>Prevents disposal of reused instance if it is disposable.</summary>
    public bool PreventDisposal => (_settings & Settings.PreventDisposal) != 0;

    internal bool WeaklyReferencedOrPreventDisposal => (_settings & (Settings.WeaklyReferenced | Settings.PreventDisposal)) != 0;

    /// <summary>When single service is resolved, but multiple candidates found, this setting will be used to prefer this one.</summary>
    public bool PreferInSingleServiceResolve => (_settings & Settings.PreferInSingleServiceResolve) != 0;

    /// <summary>Does not add the resolution scope into the parent or singleton scope,
    /// preventing possibly unwanted holding of the scope (and its services) for the lifespan of the container.</summary>
    public bool AvoidResolutionScopeTracking => (_settings & Settings.AvoidResolutionScopeTracking) != 0;

    /// <summary>Instructs to use decorated service reuse. Decorated service may be decorator itself.
    /// Note: It does not consider the keys of decorated services, therefore it will be shared between all services in collection.
    /// Note: Setting is valid only for DecoratorSetup, for other setups it is always `false`.</summary>
    public bool UseDecorateeReuse => (_settings & Settings.UseDecorateeReuse) != 0;

    private Setup() { }

    private Setup(Func<Request, bool> condition,
        bool openResolutionScope, bool asResolutionCall, bool asResolutionRoot, bool preventDisposal, bool weaklyReferenced,
        bool allowDisposableTransient, bool trackDisposableTransient, bool useParentReuse, int disposalOrder,
        bool preferOverMultipleResolved = false, bool asResolutionCallForExpressionGeneration = false,
        bool avoidResolutionScopeTracking = false)
    {
        Condition = condition;
        DisposalOrder = disposalOrder;

        if (asResolutionCall)
            _settings |= Settings.AsResolutionCall;
        if (openResolutionScope)
        {
            _settings |= Settings.OpenResolutionScope;
            _settings |= Settings.AsResolutionCall;
            if (avoidResolutionScopeTracking)
                _settings |= Settings.AvoidResolutionScopeTracking;
        }

        if (preventDisposal)
            _settings |= Settings.PreventDisposal;
        if (weaklyReferenced)
            _settings |= Settings.WeaklyReferenced;
        if (allowDisposableTransient)
            _settings |= Settings.AllowDisposableTransient;
        if (trackDisposableTransient)
        {
            _settings |= Settings.TrackDisposableTransient;
            _settings |= Settings.AllowDisposableTransient;
        }
        if (asResolutionRoot)
            _settings |= Settings.AsResolutionRoot;
        if (useParentReuse)
            _settings |= Settings.UseParentReuse;
        if (preferOverMultipleResolved)
            _settings |= Settings.PreferInSingleServiceResolve;
        if (asResolutionCallForExpressionGeneration)
            _settings |= Settings.AsResolutionCallForExpressionGeneration;
    }
#pragma warning disable CS1591
    [Flags]
    public enum Settings : ushort
    {
        Default = 0,
        AsResolutionCall = 1 << 1,
        OpenResolutionScope = 1 << 2,
        PreventDisposal = 1 << 3,
        WeaklyReferenced = 1 << 4,
        AllowDisposableTransient = 1 << 5,
        TrackDisposableTransient = 1 << 6,
        AsResolutionRoot = 1 << 7,
        UseParentReuse = 1 << 8,
        PreferInSingleServiceResolve = 1 << 9,
        AsResolutionCallForExpressionGeneration = 1 << 10,
        AvoidResolutionScopeTracking = 1 << 11,
        UseDecorateeReuse = 1 << 12,
    }
#pragma warning restore CS1591

    /// <summary>The settings</summary>
    protected Settings _settings;

    /// <summary>Default setup for service factories.</summary>
    public static readonly Setup Default = new ServiceSetup();

    /// <summary>Constructs setup object out of specified settings.
    /// If all settings are default then <see cref="Default"/> setup will be returned.
    /// <paramref name="metadataOrFuncOfMetadata"/> is metadata object or Func returning metadata object.
    /// <paramref name="avoidResolutionScopeTracking"/>Does not add the resolution scope into the parent or singleton scope,
    /// preventing possibly unwanted holding of the scope (and its services) for the lifespan of the container.</summary>
    public static Setup With(
        object metadataOrFuncOfMetadata = null, Func<Request, bool> condition = null,
        bool openResolutionScope = false, bool asResolutionCall = false, bool asResolutionRoot = false,
        bool preventDisposal = false, bool weaklyReferenced = false,
        bool allowDisposableTransient = false, bool trackDisposableTransient = false,
        bool useParentReuse = false, int disposalOrder = 0, bool preferInSingleServiceResolve = false,
        bool avoidResolutionScopeTracking = false)
    {
        if (metadataOrFuncOfMetadata == null & condition == null & !openResolutionScope & !asResolutionRoot &
            !preventDisposal & !weaklyReferenced & !allowDisposableTransient & !trackDisposableTransient &
            !useParentReuse & disposalOrder == 0 & !preferInSingleServiceResolve & !avoidResolutionScopeTracking)
            return !asResolutionCall ? Default : AsResolutionCallSetup;

        return new ServiceSetup(condition,
            metadataOrFuncOfMetadata, openResolutionScope, asResolutionCall, asResolutionRoot,
            preventDisposal, weaklyReferenced, allowDisposableTransient, trackDisposableTransient,
            useParentReuse, disposalOrder, preferInSingleServiceResolve,
            avoidResolutionScopeTracking: avoidResolutionScopeTracking);
    }

    /// <summary>Default setup which will look for wrapped service type as single generic parameter.</summary>
    public static readonly Setup Wrapper = new WrapperSetup();

    private static Setup CreateWrapperWithPreventDisposal()
    {
        var w = new WrapperSetup();
        w._settings |= Settings.PreventDisposal;
        return w;
    }
    internal static readonly Setup WrapperWithPreventDisposal = CreateWrapperWithPreventDisposal();

    // todo: rename to WrapperOf
    /// <summary>Returns generic wrapper setup.
    /// Default for <paramref name="wrappedServiceTypeArgIndex" /> is -1 for generic wrapper with single type argument.
    /// Index need to be set for multiple type arguments. <paramref name="alwaysWrapsRequiredServiceType" /> need to be set 
    /// when generic wrapper type arguments should be ignored.</summary>
    public static Setup WrapperWith(int wrappedServiceTypeArgIndex = -1,
        bool alwaysWrapsRequiredServiceType = false, Func<Type, Type> unwrap = null,
        bool openResolutionScope = false, bool asResolutionCall = false,
        bool preventDisposal = false, bool weaklyReferenced = false,
        bool allowDisposableTransient = false, bool trackDisposableTransient = false,
        bool useParentReuse = false, Func<Request, bool> condition = null, int disposalOrder = 0,
        bool avoidResolutionScopeTracking = false) =>
            wrappedServiceTypeArgIndex == -1 && !alwaysWrapsRequiredServiceType && unwrap == null &&
            !openResolutionScope && !asResolutionCall && !preventDisposal && !weaklyReferenced &&
            !allowDisposableTransient && !trackDisposableTransient && condition == null && disposalOrder == 0 &&
            !avoidResolutionScopeTracking
                ? Wrapper
                : new WrapperSetup(wrappedServiceTypeArgIndex, alwaysWrapsRequiredServiceType, unwrap,
                    condition, openResolutionScope, asResolutionCall, preventDisposal, weaklyReferenced,
                    allowDisposableTransient, trackDisposableTransient, useParentReuse, disposalOrder,
                    avoidResolutionScopeTracking);

    /// <summary>Default decorator setup: decorator is applied to service type it registered with.</summary>
    public static readonly Setup Decorator = new DecoratorSetup();

    // todo: Make decorateeReuse a default?
    /// <summary>Creates setup with optional condition.
    /// The <paramref name="order" /> specifies relative decorator position in decorators chain.
    /// Greater number means further from decoratee - specify negative number to stay closer.
    /// Decorators without order (Order is 0) or with equal order are applied in registration order
    /// - first registered are closer decoratee.</summary>
    public static Setup DecoratorWith(
        Func<Request, bool> condition = null, int order = 0, bool useDecorateeReuse = false,
        bool openResolutionScope = false, bool asResolutionCall = false,
        bool preventDisposal = false, bool weaklyReferenced = false,
        bool allowDisposableTransient = false, bool trackDisposableTransient = false,
        int disposalOrder = 0, bool avoidResolutionScopeTracking = false) =>
        condition == null & order == 0 & !useDecorateeReuse & !openResolutionScope & !asResolutionCall &&
        !preventDisposal & !weaklyReferenced & !allowDisposableTransient & !trackDisposableTransient &
        disposalOrder == 0 & !avoidResolutionScopeTracking
            ? Decorator
            : new DecoratorSetup(condition, order, useDecorateeReuse, openResolutionScope, asResolutionCall,
                preventDisposal, weaklyReferenced, allowDisposableTransient, trackDisposableTransient, disposalOrder,
                avoidResolutionScopeTracking);

    ///<summary>Creates a condition for <paramref name="decorateeType"/></summary>
    public static Func<Request, bool> GetDecorateeCondition(Type decorateeType) =>
        r => r.GetKnownImplementationOrServiceType().IsAssignableTo(decorateeType);

    ///<summary>Creates a condition for <paramref name="decorateeServiceKey"/></summary>
    public static Func<Request, bool> GetDecorateeCondition(object decorateeServiceKey) =>
        r => decorateeServiceKey.Equals(r.ServiceKey);

    ///<summary>Creates a condition for <paramref name="decorateeServiceKey"/></summary>
    public static Func<Request, bool> GetDecorateeCondition(Type decorateeType, object decorateeServiceKey) =>
        r => r.GetKnownImplementationOrServiceType().IsAssignableTo(decorateeType)
            && decorateeServiceKey.Equals(r.ServiceKey);

    /// <summary>Setup for decorator of type <paramref name="decorateeType"/>.</summary>
    public static Setup DecoratorOf(Type decorateeType = null,
        int order = 0, bool useDecorateeReuse = false, bool openResolutionScope = false, bool asResolutionCall = false,
        bool preventDisposal = false, bool weaklyReferenced = false, bool allowDisposableTransient = false,
        bool trackDisposableTransient = false, int disposalOrder = 0, object decorateeServiceKey = null)
    {
        Func<Request, bool> cond = decorateeType == null & decorateeServiceKey == null
            ? null
            : decorateeType != null & decorateeServiceKey != null
                ? GetDecorateeCondition(decorateeType, decorateeServiceKey)
            : decorateeType != null
                ? GetDecorateeCondition(decorateeType)
                : GetDecorateeCondition(decorateeServiceKey);
        return DecoratorWith(cond, order, useDecorateeReuse, openResolutionScope, asResolutionCall,
            preventDisposal, weaklyReferenced, allowDisposableTransient, trackDisposableTransient, disposalOrder);
    }

    /// <summary>Setup for decorator of type <typeparamref name="TDecoratee"/>.</summary>
    public static Setup DecoratorOf<TDecoratee>(
        int order = 0, bool useDecorateeReuse = false, bool openResolutionScope = false, bool asResolutionCall = false,
        bool preventDisposal = false, bool weaklyReferenced = false, bool allowDisposableTransient = false,
        bool trackDisposableTransient = false, int disposalOrder = 0, object decorateeServiceKey = null) =>
        DecoratorOf(typeof(TDecoratee), order, useDecorateeReuse, openResolutionScope, asResolutionCall,
            preventDisposal, weaklyReferenced, allowDisposableTransient, trackDisposableTransient,
            disposalOrder, decorateeServiceKey);

    /// <summary>Service setup.</summary>
    internal sealed class ServiceSetup : Setup
    {
        /// <inheritdoc />
        public override FactoryType FactoryType => FactoryType.Service;

        /// <summary>Evaluates metadata if it specified as Func of object, and replaces Func with its result, otherwise just returns metadata object.</summary>
        /// <remarks>Invocation of Func metadata is Not thread-safe. Please take care of that inside the Func.</remarks>
        public override object Metadata =>
            _metadataOrFuncOfMetadata is Func<object> metaFactory ? (_metadataOrFuncOfMetadata = metaFactory()) : _metadataOrFuncOfMetadata;

        /// All settings are set to the default.
        public ServiceSetup() { }

        /// Specify all the individual settings.
        public ServiceSetup(Func<Request, bool> condition = null, object metadataOrFuncOfMetadata = null,
            bool openResolutionScope = false, bool asResolutionCall = false, bool asResolutionRoot = false,
            bool preventDisposal = false, bool weaklyReferenced = false, bool allowDisposableTransient = false,
            bool trackDisposableTransient = false, bool useParentReuse = false, int disposalOrder = 0,
            bool preferOverMultipleResolved = false, bool asResolutionCallForExpressionGeneration = false,
            bool avoidResolutionScopeTracking = false)
            : base(condition, openResolutionScope, asResolutionCall, asResolutionRoot,
                preventDisposal, weaklyReferenced, allowDisposableTransient, trackDisposableTransient,
                useParentReuse, disposalOrder, preferOverMultipleResolved, asResolutionCallForExpressionGeneration,
                avoidResolutionScopeTracking)
        {
            _metadataOrFuncOfMetadata = metadataOrFuncOfMetadata;
        }

        private object _metadataOrFuncOfMetadata;
    }

    /// <summary>Setup applied for wrappers.</summary>
    internal sealed class WrapperSetup : Setup
    {
        /// <summary>Returns <see cref="DryIoc.FactoryType.Wrapper"/> type.</summary>
        public override FactoryType FactoryType => FactoryType.Wrapper;

        /// <summary>Delegate to get wrapped type from provided wrapper type.
        /// If wrapper is generic, then wrapped type is usually a generic parameter.</summary>
        public readonly int WrappedServiceTypeArgIndex;

        /// <summary>Per name.</summary>
        public readonly bool AlwaysWrapsRequiredServiceType;

        /// <summary>Delegate returning wrapped type from wrapper type. Overwrites other options.</summary>
        public readonly Func<Type, Type> Unwrap;

        /// <summary>Default setup</summary>
        /// <param name="wrappedServiceTypeArgIndex">Default is -1 for generic wrapper with single type argument.
        /// Need to be set for multiple type arguments.</param>
        public WrapperSetup(int wrappedServiceTypeArgIndex = -1) =>
            WrappedServiceTypeArgIndex = wrappedServiceTypeArgIndex;

        /// <summary>Returns generic wrapper setup.
        /// Default for <paramref name="wrappedServiceTypeArgIndex" /> is -1 for generic wrapper with single type argument.
        /// Index need to be set for multiple type arguments. <paramref name="alwaysWrapsRequiredServiceType" /> need to be set 
        /// when generic wrapper type arguments should be ignored.</summary>
        public WrapperSetup(int wrappedServiceTypeArgIndex, bool alwaysWrapsRequiredServiceType, Func<Type, Type> unwrap,
            Func<Request, bool> condition,
            bool openResolutionScope, bool asResolutionCall,
            bool preventDisposal, bool weaklyReferenced, bool allowDisposableTransient, bool trackDisposableTransient,
            bool useParentReuse, int disposalOrder, bool avoidResolutionScopeTracking)
            : base(condition, openResolutionScope, asResolutionCall, false, preventDisposal, weaklyReferenced,
                allowDisposableTransient, trackDisposableTransient, useParentReuse, disposalOrder,
                avoidResolutionScopeTracking: avoidResolutionScopeTracking)
        {
            WrappedServiceTypeArgIndex = wrappedServiceTypeArgIndex;
            AlwaysWrapsRequiredServiceType = alwaysWrapsRequiredServiceType;
            Unwrap = unwrap;
        }

        internal bool ValidateWrapperRegistration(Type serviceType, bool throwIfInvalid)
        {
            if (AlwaysWrapsRequiredServiceType || Unwrap != null || !serviceType.IsGenericType)
                return true;

            var typeArgCount = serviceType.GetGenericArguments().Length;
            var typeArgIndex = WrappedServiceTypeArgIndex;
            if (typeArgCount > 1 && typeArgIndex == -1)
                return Throw.When(throwIfInvalid, Error.GenericWrapperWithMultipleTypeArgsShouldSpecifyArgIndex, serviceType);

            var index = typeArgIndex != -1 ? typeArgIndex : 0;
            if (index > typeArgCount - 1)
                return Throw.When(throwIfInvalid, Error.GenericWrapperTypeArgIndexOutOfBounds, serviceType, index);
            return true;
        }

        /// <summary>Unwraps service type or returns the <paramref name="serviceType"/> as-is.</summary>
        public Type GetWrappedTypeOrNullIfWrapsRequired(Type serviceType)
        {
            if (Unwrap != null)
                return Unwrap(serviceType);

            if (AlwaysWrapsRequiredServiceType || !serviceType.IsGenericType)
                return null;

            var typeArgs = serviceType.GetGenericArguments();
            var typeArgIndex = WrappedServiceTypeArgIndex;
            serviceType.ThrowIf(typeArgs.Length > 1 && typeArgIndex == -1,
                Error.GenericWrapperWithMultipleTypeArgsShouldSpecifyArgIndex);

            typeArgIndex = typeArgIndex != -1 ? typeArgIndex : 0;
            serviceType.ThrowIf(typeArgIndex > typeArgs.Length - 1,
                Error.GenericWrapperTypeArgIndexOutOfBounds, typeArgIndex);

            return typeArgs[typeArgIndex];
        }
    }

    /// <summary>Setup applied to decorators.</summary>
    internal sealed class DecoratorSetup : Setup
    {
        /// <summary>Returns Decorator factory type.</summary>
        public override FactoryType FactoryType => FactoryType.Decorator;

        /// <summary>If provided specifies relative decorator position in decorators chain.
        /// Greater number means further from decoratee - specify negative number to stay closer.
        /// Decorators without order (Order is 0) or with equal order are applied in registration order
        /// - first registered are closer decoratee.</summary>
        public readonly int Order;

        /// <summary>Default setup.</summary>
        public DecoratorSetup() { }

        /// <summary>Creates decorator setup with optional condition. <paramref name="condition" /> applied to 
        /// decorated service to find that service is the decorator target. <paramref name="order" /> specifies 
        /// relative decorator position in decorators chain. Greater number means further from decoratee -
        /// specify negative number to stay closer. Decorators without order (Order is 0) or with equal order
        /// are applied in registration order - first registered are closer decoratee.</summary>
        public DecoratorSetup(Func<Request, bool> condition, int order, bool useDecorateeReuse,
            bool openResolutionScope = false, bool asResolutionCall = false,
            bool preventDisposal = false, bool weaklyReferenced = false,
            bool allowDisposableTransient = false, bool trackDisposableTransient = false,
            int disposalOrder = 0, bool avoidResolutionScopeTracking = false)
            : base(condition, openResolutionScope, asResolutionCall, false, preventDisposal, weaklyReferenced,
                allowDisposableTransient, trackDisposableTransient, false, disposalOrder,
                avoidResolutionScopeTracking: avoidResolutionScopeTracking)
        {
            Order = order;
            if (useDecorateeReuse)
                _settings |= Settings.UseDecorateeReuse;
        }
    }
}

/// <summary>Flags to describe how to deal with factory result expression</summary>
[Flags]
public enum FactoryFlags : byte
{
    /// <summary>Up to DryIoc to decide</summary>
    Default = 0,
    /// <summary>Prevents DryIoc to set `DoNotCache`</summary>
    PleaseDontSetDoNotCache = 1,
    /// <summary>If set, the expression won't be cached</summary> 
    DoNotCache = 1 << 1,
    /// <summary>If set then as resolution cache, it is for the internal use complementing the Setup.IsResolutionCall</summary>
    AsResolutionCall = 1 << 2
}

/// <summary>Base class for different ways to instantiate service:
/// <list type="bullet">
/// <item>Through reflection - <see cref="ReflectionFactory"/></item>
/// <item>Using custom delegate - <see cref="DelegateFactory"/></item>
/// <item>Using custom expression - <see cref="ExpressionFactory"/></item>
/// <item>A placeholder for future actual implementation - <see cref="FactoryPlaceholder"/></item>
/// </list>
/// For all of the types Factory should provide result as <see cref="Expression"/> and `Func{IResolverContext, object}`.
/// Factories are supposed to be immutable and stateless.
/// Each created factory has an unique ID set in <see cref="FactoryID"/>.</summary>
public abstract class Factory
{
    /// <summary>Get next factory ID in a atomic way.</summary><returns>The ID.</returns>
    public static int GetNextID() => Interlocked.Increment(ref _lastFactoryID);
    internal static int _lastFactoryID;

    /// <summary>Unique factory id generated from static seed.</summary>
    public int FactoryID { get; internal set; } = GetNextID();

    /// <summary>Reuse policy for created services. The default is `null` which means the absense of the resue or Transient</summary>
    public virtual IReuse Reuse => null;

    /// <summary>Setup may contain different/non-default factory settings.</summary>
    public virtual Setup Setup => Setup.Default;

    /// <summary>Indicates how to deal with the result expression</summary>
    public FactoryFlags Flags { get; set; }

    /// <summary>Can cache the result expression</summary>
    public bool CanCache => (Flags & FactoryFlags.DoNotCache) == 0;

    /// <summary>Instructs to skip caching the factory unless it really wants to do it via `PleaseDontSetDoNotCache`</summary>
    public Factory DoNotCache()
    {
        if ((Flags & FactoryFlags.PleaseDontSetDoNotCache) == 0)
            Flags |= FactoryFlags.DoNotCache;
        return this;
    }

    internal void SetAsResolutionCall() => Flags |= FactoryFlags.AsResolutionCall;

    /// <summary>Checks that condition is met for request or there is no condition setup.</summary>
    public bool CheckCondition(Request request)
    {
        var condition = Setup.Condition;
        return condition == null || condition(request.Isolate());
    }

    /// <summary>Shortcut for <see cref="DryIoc.Setup.FactoryType"/>.</summary>
    public FactoryType FactoryType => Setup.FactoryType;

    /// <summary>Non-abstract closed implementation type. May be null if not known beforehand, e.g. in <see cref="DelegateFactory"/>.</summary>
    public virtual Type ImplementationType => null;

    /// <summary>Allow inheritors to define lazy implementation type</summary>
    public virtual bool CanAccessImplementationType => true;

    /// <summary>Registration order.</summary>
    public virtual int RegistrationOrder => FactoryID;

    /// <summary>Settings <b>(if any)</b> to select Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
    public virtual Made Made => Made.Default;

    /// <summary>The factory inserts the runtime-state into result expression, e.g. delegate or pre-created instance.</summary>
    public virtual bool HasRuntimeState => false;

    /// <summary>Factory expression should be the resolution call</summary>
    public bool AsResolutionCall => (Flags & FactoryFlags.AsResolutionCall) != 0 || Setup.AsResolutionCall;

    ///<summary>Closed generic factories</summary> 
    public virtual ImHashMap<KV<Type, object>, ReflectionFactory> GeneratedFactories => null; // todo: @perf use struct for the key

    ///<summary>Open-generic parent factory</summary> 
    public virtual ReflectionFactory GeneratorFactory => null;

    /// <summary>Returns the closed-generic generated factory or `null`</summary>
    public virtual Factory GetGeneratedFactoryOrDefault(Request request, bool ifErrorReturnDefault = false) => null;

    /// <summary>The main factory method to create a service expression, e.g. "new Client(new Service())".
    /// If <paramref name="request"/> has <see cref="Request.InputArgExprs"/> specified, they could be used in expression.</summary>
    public abstract Expression CreateExpressionOrDefault(Request request);

    /// <summary>The method is the optimization, its behavior should be the same as the `CreateExpressionOrDefault`.
    /// It accepts the service factory found by the collection or higher wrapper.
    /// Here in the default implementation we just ignoring the passed factory.</summary>
    public virtual Expression CreateExpressionWithWrappedFactory(Request request, Factory serviceFactory) => CreateExpressionOrDefault(request);

    /// <summary>Returns service expression: either by creating it with <see cref="CreateExpressionOrDefault"/> or taking expression from cache.
    /// Before returning method may transform the expression  by applying <see cref="Reuse"/>, or/and decorators if found any.</summary>
    public virtual Expression GetExpressionOrDefault(Request request)
    {
        // The factory usually is null unless it is provided by the collection or other higher wrapper.
        // Note, that we are storing it in the local variable Here because the follow-up WithResolvedFactory will override it with "this" factory.
        var serviceFactory = request.FactoryID == 0 ? request.Factory : null;

        request = request.WithResolvedFactory(this);

        // First look for decorators if it is not already a decorator
        var container = request.Container;
        if (FactoryType != FactoryType.Decorator)
        {
            var decoratorExpr = container.GetDecoratorExpressionOrDefault(request);
            if (decoratorExpr != null)
                return decoratorExpr;
        }

        var setup = Setup;
        var rules = container.Rules;
        var asResolutionCall = AsResolutionCall;
        var getAsRsolutionCall =
            (request.Flags & RequestFlags.IsGeneratedResolutionDependencyExpression) == 0
            && !request.OpensResolutionScope
            && (setup.OpenResolutionScope ||
                !request.IsResolutionCall
                    && (asResolutionCall || (setup.AsResolutionCallForExpressionGeneration && rules.UsedForExpressionGeneration))
                    && request.ActualServiceType != typeof(void));

        if (getAsRsolutionCall)
            return Resolver.CreateResolutionExpression(request, setup.OpenResolutionScope, asResolutionCall);

        var reuse = request.Reuse;
        var requestFlags = request.Flags;
        var cacheExpression =
            CanCache & FactoryType == FactoryType.Service &&

            // todo: @perf call !request.AvoidExpressionCaching instead
            // see #623 for the HasDecoratorCondition
            (requestFlags & (RequestFlags.IsDirectlyWrappedInFunc | RequestFlags.DoNotCacheExpression)) == 0 &&
            !request.IsResolutionRoot &&
            !request.IsWrappedInFuncWithArgs() &&

            !(reuse.Name is IScopeName) && // avoid caching of scoped services with the custom scope name and possibly the scope name matching rule
            !asResolutionCall && // see #295
            !setup.UseParentReuse &&
            setup.Condition == null &&
            !Made.IsConditional;

        // First, lookup in the expression cache
        ImHashMapEntry<int, object> cacheEntry = null;
        if (cacheExpression && container._registry.Value is Container.Registry r &&
            r.TryGetCachedExpression(request, reuse, rules, ref cacheEntry, out var cachedExpr))
            return cachedExpr;

        // Next, lookup for the already created service in the singleton scope
        Expression serviceExpr;
        var singletonId = 0;
        var canCreateSingletonNow = reuse is SingletonReuse & rules.EagerCachingSingletonForFasterAccess;
        if (canCreateSingletonNow)
        {
            // Then optimize for already resolved singleton object, otherwise goes normal ApplyReuse route
            singletonId = request.GetCombinedDecoratorAndFactoryID();
            var itemRef = ((Scope)container.SingletonScope)._maps[singletonId & Scope.MAP_COUNT_SUFFIX_MASK].GetEntryOrDefault(singletonId); // todo: @unsafe @perf cast to scope
            if (itemRef != null)
            {
                // Note: (for details check the test for #340 and the `For_singleton_can_use_func_without_args_or_just_resolve_after_func_with_args`)
                //
                // Now we are in a danger zone if we try to get a singleton wrapped in a Func as a dependency of the same singleton, e.g.
                //
                // `class Singleton { public Singleton(Func<Singleton> fs) {} }`
                //
                // In this situation the `itemRef` will stuck forever on the `WaitForItemIsSet` below.
                // So the way-out here is to abondon the attempt to wait for the item if we are not in the Func
                // and proceed to the normal Expression creation.
                //
                var singleton = itemRef.Value;
                if (singleton == Scope.NoItem && (requestFlags & (RequestFlags.TracksTransientDisposable | RequestFlags.IsWrappedInFunc)) == 0)
                    singleton = Scope.WaitForItemIsSet(itemRef);
                if (singleton != Scope.NoItem)
                {   // todo: @perf how to avoid the wrapping in Constant, because it happens just to conform to the API, but we may change the API as well, right?
                    if (singleton is ScopedItemException sex)
                        sex.ReThrow(); // see the #618 for details
                    var e = singleton != null ? Constant(singleton) : ConstantNull(request.ActualServiceType); // fixes #258
                    return !setup.WeaklyReferencedOrPreventDisposal ? e : GetWrappedSingletonAccessExpression(e, setup);
                }
            }
        }

        // At last, create the object graph with all of the dependencies created and injected
        // todo: @perf optimize the code path for IResolverContext Wrapper: ResolverContext.GetRootOrSelfExpr - override GetExpressionOrDefault
        // todo: @perf for IResolverContext no need to check expression cache at all
        serviceExpr = serviceFactory == null
            ? CreateExpressionOrDefault(request)
            : CreateExpressionWithWrappedFactory(request, serviceFactory);

        if (serviceExpr == null)
            return Container.ThrowUnableToResolveOrGetDefault(request, serviceExpr);

        if (reuse != DryIoc.Reuse.Transient)
        {
            if (!rules.UsedForValidation && request.ActualServiceType != typeof(void))
            {
                var originalServiceExprType = serviceExpr.Type;

                // This optimization eagerly creates singleton during the construction of object graph
                // Singleton is created once and then is stored for the container lifetime (until ontainer.SingletonScope is disposed).
                // That's why we are always intepreting them even if `Rules.WithoutInterpretationForTheFirstResolution()` is set.
                var weaklyReferencedOrPreventDisposal = setup.WeaklyReferencedOrPreventDisposal;
                if (canCreateSingletonNow && !request.TracksTransientDisposable && !request.IsWrappedInFunc()) // todo: @perf combine the request checks
                {
                    var singleton = Scope.NoItem; // NoItem is a marker for the value is not created yet

                    // Creating a new local item with the id and the marker for not yet created item
                    var itemRef = ImHashMap.Entry(singletonId, Scope.NoItem);
                    var singletonScope = (Scope)container.SingletonScope; // todo: @unsafe @perf remove cast and virtual property call
                    ref var map = ref singletonScope._maps[singletonId & Scope.MAP_COUNT_SUFFIX_MASK]; // got a live reference to the map where value can be queried and stored

                    var oldMap = map; // get a reference to the map available now as an oldMap
                    var newMap = oldMap.AddOrKeepEntry(itemRef);

                    // If the `newMap` is the same as an `oldMap` it means there is item already in the map.
                    // The check before the CAS operation is only here for Singleton and not for the scope 
                    // because the race for the Singletons and the situation where singleton is already create in parallel 
                    // is far more likely and the race for the Scoped services is almost non-existent 
                    // (because Scoped is almost equal to the single thread or the single invocation flow)
                    if (newMap == oldMap)
                    {
                        // It does not matter if the live `map` changed because the item can only be added and not removed ever
                        var otherItemRef = newMap.GetSurePresent(singletonId);
                        singleton = otherItemRef.Value != Scope.NoItem ? otherItemRef.Value : Scope.WaitForItemIsSet(otherItemRef);
                    }
                    else if (Interlocked.CompareExchange(ref map, newMap, oldMap) != oldMap) // set map to newMap if the map did no change since getting oldMap
                    {
                        // if the map was changed in parallel, let's retry using the Swap
                        newMap = Ref.SwapAndGetNewValue(ref map, itemRef, (x, i) => x.AddOrKeepEntry(i));
                        var otherItemRef = newMap.GetSurePresent(singletonId);
                        if (otherItemRef != itemRef)
                            singleton = otherItemRef.Value != Scope.NoItem ? otherItemRef.Value : Scope.WaitForItemIsSet(otherItemRef);
                    }

                    if (singleton == Scope.NoItem)
                    {
                        singleton = container.InterpretOrCompileSingletonAndUnwrapContainerException(serviceExpr, itemRef);

                        if (weaklyReferencedOrPreventDisposal)
                            singleton = setup.WeaklyReferenced ? new WeakReference(singleton) : new HiddenDisposable(singleton); // todo: @perf we don't need it here because because instead of wrapping the item into the non-disposable object we may skip adding it to Disposable items collection - just skipping the AddUnorderedDisposable or AddDisposable calls below

                        itemRef.Value = singleton;
                        if (singleton is IDisposable disp && !ReferenceEquals(disp, singletonScope))
                            singletonScope.AddDisposable(disp, setup.DisposalOrder);
                    }

                    if (request.DependencyCount > 0)
                        request.DecreaseTrackedDependencyCountForParents();

                    Debug.Assert(singleton != Scope.NoItem, "Should not be the case otherwise I am effing failed");
                    serviceExpr = singleton != null ? Constant(singleton) : Constant(null, serviceExpr.Type); // fixes #258

                    if (weaklyReferencedOrPreventDisposal)
                        serviceExpr = TryConvertIntrinsic(GetWrappedSingletonAccessExpression(serviceExpr, setup), originalServiceExprType);
                }
                else
                {
                    if (weaklyReferencedOrPreventDisposal)
                        serviceExpr = NewNoByRefArgs(setup.WeaklyReferenced ? ReflectionTools.WeakReferenceCtor : HiddenDisposable.Ctor, serviceExpr);

                    serviceExpr = reuse.Apply(request, serviceExpr);

                    if (weaklyReferencedOrPreventDisposal)
                        serviceExpr = TryConvertIntrinsic(GetWrappedSingletonAccessExpression(serviceExpr, setup), originalServiceExprType);
                    else if (serviceExpr.NodeType != ExprType.Constant &&
                        serviceExpr.Type != originalServiceExprType && !originalServiceExprType.IsAssignableFrom(serviceExpr.Type))
                        serviceExpr = TryConvertIntrinsic(serviceExpr, originalServiceExprType);
                }
            }
        }
        else if (!rules.UsedForValidation & !rules.UsedForExpressionGeneration &&
            request.DependencyCount >= rules.DependencyCountInLambdaToSplitBigObjectGraph)
        {
            // Split the expression with dependencies bigger than certain threshold by wrapping it in a Func and its Invocation
            // which is a separate compilation unit
            request.DecreaseTrackedDependencyCountForParents();
            serviceExpr = Invoke(serviceExpr.Type, Lambda<Func<object>>(serviceExpr, Empty<ParameterExpression>(), typeof(object)), Empty<Expression>());
        }

        if (cacheExpression)
            (cacheEntry ?? container.CacheFactoryExpression(request.FactoryID)).Value =
                reuse == DryIoc.Reuse.Transient ? new Container.ExprCacheOfTransientWithDepCount(serviceExpr, request.DependencyCount) :
                reuse is CurrentScopeReuse scoped && scoped.Name != null ? new Container.ExprCacheOfScopedWithName(serviceExpr, scoped.Name) :
                serviceExpr;

        return serviceExpr;
    }

    private static Expression GetWrappedSingletonAccessExpression(Expression e, Setup setup) =>
        setup.WeaklyReferenced
            ? Call(ThrowInGeneratedCode.WeakRefReuseWrapperGCedMethod, Property(TryConvertIntrinsic<WeakReference>(e), ReflectionTools.WeakReferenceValueProperty))
            : Field(TryConvertIntrinsic<HiddenDisposable>(e), HiddenDisposable.ValueField);

    /// <summary>Creates an instance of the service or the factory delegate to resolve the instance and returns either of them, or nulls.</summary>
    public virtual Func<IResolverContext, object> GetDelegateOrDefault(Request request, out object createdInstance)
    {
        createdInstance = null;
        var expr = GetExpressionOrDefault(request);
        if (expr == null)
            return null;

        if (expr is ConstantExpression constExpr)
        {
            createdInstance = constExpr.Value;
            return null;
        }

        return expr.CompileOrInterpretFactoryDelegate(request.Rules.UseInterpretation);
    }

    internal virtual bool ValidateAndNormalizeRegistration(Type serviceType, object serviceKey, bool isStaticallyChecked, Rules rules, bool throwIfInvalid)
    {
        if (serviceType == null)
            return Throw.When(throwIfInvalid, Error.ServiceTypeIsNull);

        var setup = Setup;
        if (setup.FactoryType == FactoryType.Service)
        {
            // Warn about registering disposable transient
            var reuse = Reuse ?? rules.DefaultReuse;
            if (reuse != DryIoc.Reuse.Transient || setup.AllowDisposableTransient || !rules.ThrowOnRegisteringDisposableTransient ||
                setup.UseParentReuse)
                return true;

            var knownImplOrServiceType = CanAccessImplementationType ? ImplementationType : serviceType;
            if (typeof(IDisposable).IsAssignableFrom(knownImplOrServiceType))
                return Throw.When(throwIfInvalid, Error.RegisteredDisposableTransientWontBeDisposedByContainer, serviceType, serviceKey ?? "{no key}", this);
        }
        else if (setup.FactoryType == FactoryType.Wrapper)
        {
            return ((Setup.WrapperSetup)setup).ValidateWrapperRegistration(serviceType, throwIfInvalid);
        }
        else if (setup.FactoryType == FactoryType.Decorator)
        {
            if (serviceKey != null)
                return Throw.When(throwIfInvalid, Error.DecoratorShouldNotBeRegisteredWithServiceKey, serviceKey);

            var reuse = Reuse ?? rules.DefaultReuse;
            if (reuse != DryIoc.Reuse.Transient || setup.AllowDisposableTransient || !rules.ThrowOnRegisteringDisposableTransient ||
                setup.UseDecorateeReuse)
                return true;

            var knownImplOrServiceType = CanAccessImplementationType ? ImplementationType : serviceType;
            if (typeof(IDisposable).IsAssignableFrom(knownImplOrServiceType))
                return Throw.When(throwIfInvalid, Error.RegisteredDisposableTransientWontBeDisposedByContainer, serviceType, serviceKey ?? "{no key}", this);
        }

        return true;
    }

    /// <summary>Returns nice string representation of factory.</summary>
    public override string ToString()
    {
        var s = new StringBuilder().Append("{FactoryID=").Append(FactoryID);
        if (ImplementationType != null)
            s.Append(", ImplType=").Print(ImplementationType);
        if (Reuse != null)
            s.Append(", Reuse=").Print(Reuse);
        if (Setup.FactoryType != Setup.Default.FactoryType)
            s.Append(", FactoryType=").Append(Setup.FactoryType);
        if (Setup.Metadata != null)
            s.Append(", Metadata=").Print(Setup.Metadata);
        if (Setup.Condition != null)
            s.Append(", HasCondition");

        if (Setup.OpenResolutionScope)
            s.Append(", OpensResolutionScope");
        else if (AsResolutionCall)
            s.Append(", AsResolutionCall");

        return s.Append("}").ToString();
    }
}

/// <summary>Declares delegate to get single factory method or constructor for resolved request.</summary>
public delegate FactoryMethod FactoryMethodSelector(Request request);

/// <summary>Specifies how to get parameter info for injected parameter and resolved request</summary>
public delegate Func<ParameterInfo, ParameterServiceInfo> ParameterSelector(Request request);

/// <summary>Specifies what properties or fields to inject and how.</summary>
public delegate IEnumerable<PropertyOrFieldServiceInfo> PropertiesAndFieldsSelector(Request request);

/// <summary>DSL for specifying <see cref="ParameterSelector"/> injection rules.</summary>
public static class Parameters
{
    /// <summary>Returns default service info wrapper for each parameter info.</summary>
    public static ParameterSelector Of = request => ParameterServiceInfo.Of;

    /// <summary>Returns service info which considers each parameter as optional.</summary>
    public static ParameterSelector IfUnresolvedReturnDefault =
        request => pi => ParameterServiceInfo.Of(pi).WithDetails(ServiceDetails.IfUnresolvedReturnDefault);

    /// <summary>Combines source selector with other. Other is used as fallback when source returns null.</summary>
    public static ParameterSelector OverrideWith(this ParameterSelector source, ParameterSelector other) =>
        source == null || source == Of ? other ?? Of
        : other == null || other == Of ? source
        : req => paramInfo => other(req)?.Invoke(paramInfo) ?? source(req)?.Invoke(paramInfo);

    /// <summary>Overrides source parameter rules with specific parameter details. 
    /// If it is not your parameter just return null.</summary>
    /// <param name="source">Original parameters rules</param>
    /// <param name="getDetailsOrNull">Should return specific details or null.</param>
    /// <returns>New parameters rules.</returns>
    public static ParameterSelector Details(this ParameterSelector source, Func<Request, ParameterInfo, ServiceDetails> getDetailsOrNull)
    {
        getDetailsOrNull.ThrowIfNull();
        return source.OverrideWith(request => p => getDetailsOrNull(request, p)?.To(ParameterServiceInfo.Of(p).WithDetails));
    }

    /// <summary>Adds to <paramref name="source"/> selector a service info for parameter identified by <paramref name="position"/>.</summary>
    public static ParameterSelector Position(this ParameterSelector source, int position,
        Type requiredServiceType = null, object serviceKey = null,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, object defaultValue = null,
        string metadataKey = null, object metadata = null) =>
        source.Details((r, p) => p.Position != position ? null :
            ServiceDetails.Of(requiredServiceType, serviceKey, ifUnresolved, defaultValue, metadataKey, metadata));

    /// <summary>Adds to <paramref name="source"/> selector a service info for parameter identified by <paramref name="position"/>
    /// and apply the specified service details..</summary>
    public static ParameterSelector Position(this ParameterSelector source,
        int position, Func<Request, ParameterInfo, ServiceDetails> getServiceDetails) =>
        source.Details((r, p) => p.Position == position ? getServiceDetails(r, p) : null);

    /// <summary>Adds to <paramref name="source"/> selector a service info for parameter identified by <paramref name="position"/>
    /// and assign the custom value to it.</summary>
    public static ParameterSelector Position(this ParameterSelector source,
        int position, Func<Request, object> getCustomValue) =>
        source.Position(position, (r, p) => ServiceDetails.Of(getCustomValue(r)));

    /// <summary>Adds to <paramref name="source"/> selector a service info for parameter identified by <paramref name="name"/>.</summary>
    /// <param name="source">Original parameters rules.</param> <param name="name">Name to identify parameter.</param>
    /// <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
    /// <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
    /// <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
    /// <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
    /// <returns>New parameters rules.</returns>
    public static ParameterSelector Name(this ParameterSelector source, string name,
        Type requiredServiceType = null, object serviceKey = null,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, object defaultValue = null,
        string metadataKey = null, object metadata = null) =>
        source.Details((r, p) => !p.Name.Equals(name) ? null
            : ServiceDetails.Of(requiredServiceType, serviceKey, ifUnresolved, defaultValue, metadataKey, metadata));

    /// <summary>Specify parameter by name and apply the specified service details.</summary>
    public static ParameterSelector Name(this ParameterSelector source,
        string name, Func<Request, ParameterInfo, ServiceDetails> getServiceDetails) =>
        source.Details((r, p) => p.Name.Equals(name) ? getServiceDetails(r, p) : null);

    /// <summary>Specify parameter by name and assign the custom value to it.</summary>
    public static ParameterSelector Name(this ParameterSelector source,
        string name, Func<Request, object> getCustomValue) =>
            source.Name(name, (r, p) => ServiceDetails.Of(getCustomValue(r)));

    /// <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <paramref name="parameterType"/>.</summary>
    /// <param name="source">Source selector.</param> <param name="parameterType">The type of the parameter.</param>
    /// <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
    /// <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
    /// <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
    /// <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
    /// <returns>Combined selector.</returns>
    public static ParameterSelector Type(this ParameterSelector source, Type parameterType,
        Type requiredServiceType = null, object serviceKey = null,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, object defaultValue = null,
        string metadataKey = null, object metadata = null) =>
        source.Details((r, p) => !parameterType.IsAssignableTo(p.ParameterType) ? null
            : ServiceDetails.Of(requiredServiceType, serviceKey, ifUnresolved, defaultValue, metadataKey, metadata));

    /// <summary>Adds to <paramref name="source"/> selector service info for parameter identified by type <typeparamref name="T"/>.</summary>
    /// <typeparam name="T">Type of parameter.</typeparam> <param name="source">Source selector.</param>
    /// <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
    /// <param name="ifUnresolved">(optional) By default throws exception if unresolved.</param>
    /// <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
    /// <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
    /// <returns>Combined selector.</returns>
    public static ParameterSelector Type<T>(this ParameterSelector source,
        Type requiredServiceType = null, object serviceKey = null,
        IfUnresolved ifUnresolved = IfUnresolved.Throw, object defaultValue = null,
        string metadataKey = null, object metadata = null) =>
        source.Type(typeof(T), requiredServiceType, serviceKey, ifUnresolved, defaultValue, metadataKey, metadata);

    /// <summary>Specify parameter by type and set its details.</summary>
    public static ParameterSelector Type<T>(this ParameterSelector source,
        Func<Request, ParameterInfo, ServiceDetails> getServiceDetails) =>
        source.Details((r, p) => p.ParameterType == typeof(T) ? getServiceDetails(r, p) : null);

    /// <summary>Specify parameter by type and set custom value to it.</summary>
    public static ParameterSelector Type<T>(this ParameterSelector source, Func<Request, T> getCustomValue) =>
        source.Type<T>((r, p) => ServiceDetails.Of(getCustomValue(r)));

    /// <summary>Specify parameter by type and set custom value to it.</summary>
    /// <param name="source">Original parameters rules.</param>
    /// <param name="parameterType">The type of the parameter.</param>
    /// <param name="getCustomValue">Custom value provider.</param>
    /// <returns>New parameters rules.</returns>
    public static ParameterSelector Type(this ParameterSelector source,
        Type parameterType, Func<Request, object> getCustomValue) =>
        source.Details((r, p) => p.ParameterType == parameterType ? ServiceDetails.Of(getCustomValue(r)) : null);
}

/// <summary>DSL for specifying <see cref="PropertiesAndFieldsSelector"/> injection rules.</summary>
public static partial class PropertiesAndFields
{
    /// <summary>Say to not resolve any properties or fields.</summary>
    public static PropertiesAndFieldsSelector Of = request => null;

    /// <summary>Public assignable instance members of any type except object, string, primitives types, and arrays of those.</summary>
    public static PropertiesAndFieldsSelector Auto = All(withNonPublic: false, withPrimitive: false);

    /// <summary>Public, declared, assignable, non-primitive properties.</summary>
    public static PropertiesAndFieldsSelector Properties(
        bool withNonPublic = false, bool withBase = false,
        IfUnresolved ifUnresolved = IfUnresolved.ReturnDefaultIfNotRegistered) =>
        All(withNonPublic: withNonPublic, withPrimitive: false, withFields: false, withBase: withBase, ifUnresolved: ifUnresolved);

#if SUPPORTS_REQUIRED_PROPERTIES
    /// <summary>The rule to discover and inject the `required properties` introduced in C# 11 and .NET 7.
    /// The properties are only injected if the constructor selected for the injection is NOT marked with `SetsRequiredMembers`,
    /// because it says the constuctor is reponsible for the setting of required properties.</summary>
    public static PropertiesAndFieldsSelector RequiredProperties() => _requiredProperties;

    // We are keeping it as the field internally 
    // and still using the public accessor method to be consistent with the rest of the PropertiesAndFields API.
    private static readonly PropertiesAndFieldsSelector _requiredProperties = req =>
    {
        var implType = req.ImplementationType;
        if (implType == null)
            return null;

        var ctor = req.SelectedConstructor;
        if (ctor != null && ctor.GetCustomAttribute<SetsRequiredMembersAttribute>() != null)
            return null;

        var props = implType.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        if (props.Length == 0)
            return null;

        var requiredProps = props.Match(
            static p => p.GetCustomAttribute<RequiredMemberAttribute>() != null,
            static p => PropertyOrFieldServiceInfo.OfRequiredProperty(p));
        return requiredProps;
    };
#endif

    /// <summary>Should return service info for input member (property or field).</summary>
    public delegate PropertyOrFieldServiceInfo GetServiceInfo(MemberInfo member, Request request);

    /// <summary>Generates selector property and field selector with settings specified by parameters.
    /// If all parameters are omitted the method returns all public not primitive fields and properties.</summary>
    public static PropertiesAndFieldsSelector All(
        bool withNonPublic = true,
        bool withPrimitive = true,
        bool withFields = true,
        bool withBase = true,
        IfUnresolved ifUnresolved = IfUnresolved.ReturnDefaultIfNotRegistered,
        GetServiceInfo serviceInfo = null)
    {
        if (serviceInfo == null)
        {
            var details = ServiceDetails.Of(ifUnresolved); // todo: @perf improve memory
            serviceInfo = (GetServiceInfo)((m, r) => PropertyOrFieldServiceInfo.Of(m).WithDetails(details));
        }

        Func<Request, PropertyInfo, bool> isInjectable =
            withNonPublic && withPrimitive ? ((r, p) => p.IsInjectable(true, true)) :
            withNonPublic ? ((r, p) => p.IsInjectable(true, false)) :
            withPrimitive ? ((r, p) => p.IsInjectable(false, true)) :
                            ((r, p) => p.IsInjectable(false, false));

        return req =>
        {
            var implType = req.ImplementationType;
            var properties = implType
                .GetMembers(x => x.DeclaredProperties, includeBase: withBase).ToArrayOrSelf()
                .Match(req, isInjectable, (r, p) => serviceInfo(p, r));

            if (!withFields)
                return properties;

            var fields = implType // todo: @perf optimize allocations and maybe combine with properties
                .GetMembers(x => x.DeclaredFields, includeBase: withBase).ToArrayOrSelf()
                .Match(req, (r, f) => f.IsInjectable(withNonPublic, withPrimitive), (r, f) => serviceInfo(f, r));

            return properties.Append(fields);
        };
    }

    /// <summary>Combines source properties and fields with other. Other will override the source condition.</summary>
    /// <param name="source">Source selector.</param> <param name="other">Specific other selector to add.</param>
    /// <returns>Combined result selector.</returns>
    public static PropertiesAndFieldsSelector OverrideWith(
        this PropertiesAndFieldsSelector source, PropertiesAndFieldsSelector other)
    {
        return source == null || source == Of ? (other ?? Of)
            : other == null || other == Of ? source
            : r =>
            {
                var sourceMembers = source(r).ToArrayOrSelf();
                var otherMembers = other(r).ToArrayOrSelf();
                return sourceMembers == null || sourceMembers.Length == 0 ? otherMembers
                    : otherMembers == null || otherMembers.Length == 0 ? sourceMembers
                    : otherMembers.Append(
                        sourceMembers.Match(otherMembers, (om, s) => s != null && om.All(o => o == null || !s.Member.Name.Equals(o.Member.Name))));
            };
    }

    /// <summary>Specifies service details (key, if-unresolved policy, required type) for property/field with the name.</summary>
    /// <param name="source">Original member selector.</param> <param name="name">Member name.</param> <param name="getDetails">Details.</param>
    /// <returns>New selector.</returns>
    public static PropertiesAndFieldsSelector Details(this PropertiesAndFieldsSelector source,
        string name, Func<Request, ServiceDetails> getDetails)
    {
        name.ThrowIfNull();
        getDetails.ThrowIfNull();
        return source.OverrideWith(req =>
        {
            var implType = req.GetKnownImplementationOrServiceType();

            var property = implType
                .GetMembers(x => x.DeclaredProperties, includeBase: true)
                .FindFirst(x => x.Name == name);
            if (property != null && property.IsInjectable(true, true))
                return getDetails(req)?.To(PropertyOrFieldServiceInfo.Of(property).WithDetails).One();

            var field = implType
                .GetMembers(x => x.DeclaredFields, includeBase: true)
                .FindFirst(x => x.Name == name);
            if (field != null && field.IsInjectable(true, true))
                return getDetails(req)?.To(PropertyOrFieldServiceInfo.Of(field).WithDetails).One();

            return Throw.For<IEnumerable<PropertyOrFieldServiceInfo>>(
                Error.NotFoundSpecifiedWritablePropertyOrField, name, req);
        });
    }

    /// <summary>Adds to <paramref name="source"/> selector service info for property/field identified by <paramref name="name"/>.</summary>
    /// <param name="source">Source selector.</param> <param name="name">Name to identify member.</param>
    /// <param name="requiredServiceType">(optional)</param> <param name="serviceKey">(optional)</param>
    /// <param name="ifUnresolved">(optional) By default returns default value if unresolved.</param>
    /// <param name="defaultValue">(optional) Specifies default value to use when unresolved.</param>
    /// <param name="metadataKey">(optional) Required metadata key</param> <param name="metadata">Required metadata or value.</param>
    /// <returns>Combined selector.</returns>
    public static PropertiesAndFieldsSelector Name(this PropertiesAndFieldsSelector source, string name,
        Type requiredServiceType = null, object serviceKey = null,
        IfUnresolved ifUnresolved = IfUnresolved.ReturnDefault, object defaultValue = null,
        string metadataKey = null, object metadata = null) =>
        source.Details(name, r => ServiceDetails.Of(
            requiredServiceType, serviceKey, ifUnresolved, defaultValue, metadataKey, metadata));

    /// <summary>Specifies custom value for property/field with specific name.</summary>
    public static PropertiesAndFieldsSelector Name(this PropertiesAndFieldsSelector source,
        string name, Func<Request, object> getCustomValue) =>
        source.Details(name, r => ServiceDetails.Of(getCustomValue(r)));

    /// <summary>Returns true if property matches flags provided.</summary>
    /// <param name="property">Property to match</param>
    /// <param name="withNonPublic">Says to include non public properties.</param>
    /// <param name="withPrimitive">Says to include properties of primitive type.</param>
    /// <returns>True if property is matched and false otherwise.</returns>
    public static bool IsInjectable(this PropertyInfo property,
        bool withNonPublic = false, bool withPrimitive = false)
    {
        if (!property.CanWrite || property.IsExplicitlyImplemented())
            return false;

        if (property.IsStatic())
            return false;

        return !property.IsIndexer() &&
                (withNonPublic || property.GetSetMethodOrNull() != null) &&
                (withPrimitive || !property.PropertyType.IsPrimitive(orArrayOfPrimitives: true));
    }

    /// <summary>Returns true if field matches flags provided.</summary>
    /// <param name="field">Field to match.</param>
    /// <param name="withNonPublic">Says to include non public fields.</param>
    /// <param name="withPrimitive">Says to include fields of primitive type.</param>
    /// <returns>True if property is matched and false otherwise.</returns>
    public static bool IsInjectable(this FieldInfo field,
        bool withNonPublic = false, bool withPrimitive = false) =>
        !field.IsInitOnly && !field.IsBackingField()
            && (withNonPublic || field.IsPublic)
            && (withPrimitive || !field.FieldType.IsPrimitive(orArrayOfPrimitives: true));
}

/// <summary>Reflects on <see cref="ImplementationType"/> constructor parameters and members,
/// creates expression for each reflected dependency, and composes result service expression.</summary>
public class ReflectionFactory : Factory
{
    /// <summary>Non-abstract service implementation type. May be open generic.</summary>
    public override Type ImplementationType
    {
        get
        {
            var x = _implementationTypeOrProviderOrPubCtorOrCtors;
            if (x is Type t)
                return t;
            if (x is ConstructorInfo singleCtor)
                return singleCtor.DeclaringType;
            if (x is ConstructorInfo[] manyCtors)
                return manyCtors[0].DeclaringType;
            return null;
        }
    }

    private object _implementationTypeOrProviderOrPubCtorOrCtors;

    /// <summary>Gets the constructors.</summary>
    public ConstructorInfo[] GetConstructors(Request request, BindingFlags additionalToPublicAndInstance = 0)
    {
        var ctorsOrCtorOrType = _implementationTypeOrProviderOrPubCtorOrCtors;
        ConstructorInfo[] ctors = null;
        if (ctorsOrCtorOrType is ConstructorInfo singleCtor) // super rare case, no need to optimize
            ctors = singleCtor.DeclaringType.GetConstructors(BindingFlags.Public | BindingFlags.Instance | additionalToPublicAndInstance);
        else if (ctorsOrCtorOrType is ConstructorInfo[] manyCtors)
            ctors = manyCtors;
        else if (ctorsOrCtorOrType is Type t)
            ctors = t.GetConstructors(BindingFlags.Public | BindingFlags.Instance | additionalToPublicAndInstance);
        else if (ctorsOrCtorOrType is Func<Type> typeProvider && typeProvider() is Type providedType)
            ctors = providedType.GetConstructors(BindingFlags.Public | BindingFlags.Instance | additionalToPublicAndInstance);
        else
            Throw.It(Error.ImplTypeIsNotSpecifiedForAutoCtorSelection, request);
        return ctors;
    }

    [MethodImpl((MethodImplOptions)256)]
    private static void ValidateImplementationType(Type type)
    {
        if (type == null)
            Throw.It(Error.RegisteringNullImplementationTypeAndNoFactoryMethod);
        if (type == typeof(object))
            Throw.It(Error.RegisteringObjectTypeAsImplementationIsNotSupported);
        if (type.IsAbstract)
            Throw.It(Error.RegisteringAbstractImplementationTypeAndNoFactoryMethod, type);
    }

    private static Type ValidateImplementationType(Type implType, Made made)
    {
        Debug.Assert(made != null, "made != null");
        if (made == Made.Default)
        {
            ValidateImplementationType(implType);
            return implType;
        }

        var knownImplType = implType;

        var factoryMethodResultType = made.FactoryMethodKnownResultType;
        if (implType == null |
            implType == typeof(object) || // required as currently object represents the open-generic type argument T registrations
            implType.IsAbstract)
        {
            if (made.FactoryMethodOrSelector == null)
                ValidateImplementationType(implType);

            knownImplType = null; // Ensure that we do not have abstract implementation type

            // Using non-abstract factory method result type is safe for conditions and diagnostics
            if (factoryMethodResultType != null &
                factoryMethodResultType != typeof(object) &&
                !factoryMethodResultType.IsAbstract)
                knownImplType = factoryMethodResultType;
        }
        else if (factoryMethodResultType != null & factoryMethodResultType != implType)
        {
            if (!implType.IsAssignableFrom(factoryMethodResultType) &&
                !factoryMethodResultType.HasConversionOperatorTo(implType))
                Throw.It(Error.RegisteredFactoryMethodResultTypesIsNotAssignableToImplementationType, implType, factoryMethodResultType);
        }

        return knownImplType;
    }

    [MethodImpl((MethodImplOptions)256)]
    private static bool IsFactoryGenerator(Type t) =>
        t.IsGenericTypeDefinition || t.IsGenericParameter;

    [MethodImpl((MethodImplOptions)256)]
    private static bool IsFactoryGenerator(Type t, Made m) =>
        t == typeof(object) || t?.IsGenericTypeDefinition == true || t?.IsGenericParameter == true || m.IsConditionalImplementation;

    /// <summary>Is `true` for `null` or some implementation type, but is `false` below in `WithAllDetails` for the type provider</summary>
    public override bool CanAccessImplementationType => true;

    /// <summary>Injection rules set for Constructor/FactoryMethod, Parameters, Properties and Fields.</summary>
    public override Made Made => Made.Default;

    /// <summary>Will contain factory ID of generator's factory for generated factory.</summary>
    public override int RegistrationOrder => GeneratorFactory?.FactoryID ?? FactoryID;

    [MethodImpl((MethodImplOptions)256)]
    internal static ReflectionFactory OfReuse(Type implementationType, IReuse reuse) =>
        reuse == null ? new ReflectionFactory(implementationType)
        : reuse == DryIoc.Reuse.Singleton ? new WithSingletonReuse(implementationType)
        : reuse == DryIoc.Reuse.Scoped ? new WithScopedReuse(implementationType)
        : reuse == DryIoc.Reuse.Transient ? new WithTransientReuse(implementationType)
        : reuse == DryIoc.Reuse.ScopedOrSingleton ? new WithScopedOrSingletonReuse(implementationType)
        : new WithReuse(implementationType, reuse);

    /// <summary>Creates the memory-optimized factory based on arguments</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ReflectionFactory Of(Type implementationType, IReuse reuse)
    {
        ValidateImplementationType(implementationType);
        return IsFactoryGenerator(implementationType)
            ? WithAllDetails.OfOpenGenericType(implementationType, reuse, Made.Default, Setup.Default)
            : OfReuse(implementationType, reuse);
    }

    /// <summary>Creates the memory-optimized factory based on arguments</summary>
    public static ReflectionFactory Of(Type implementationType) => Of(implementationType, null);

    /// <summary>Creates the memory-optimized factory based on arguments</summary>
    public static ReflectionFactory Of(Type implementationType = null, IReuse reuse = null, Made made = null, Setup setup = null)
    {
        if (made == null & setup == null)
            return Of(implementationType, reuse);

        if (made == null) // also means `setup != null` 
        {
            ValidateImplementationType(implementationType);
            return IsFactoryGenerator(implementationType)
                ? WithAllDetails.OfOpenGenericType(implementationType, reuse, Made.Default, setup)
                : WithAllDetails.OfConcreteType(implementationType, reuse, Made.Default, setup);
        }

        if (setup == null) // also means `made != null`
            setup = Setup.Default;

        var validatedImplType = ValidateImplementationType(implementationType, made);
        return IsFactoryGenerator(validatedImplType ?? implementationType, made)
            ? WithAllDetails.OfOpenGenericType(validatedImplType, reuse, made, setup)
            : setup == Setup.Default
                ? (made == Made.Default ? OfReuse(validatedImplType, reuse)
                    : reuse == null ? new WithMade(validatedImplType, made)
                    : new WithMadeAndReuse(validatedImplType, reuse, made))
                : WithAllDetails.OfConcreteType(validatedImplType, reuse, made, setup);
    }

    /// <summary>Creates the factory out of concrete or closed-generic `knownImplOrServiceType` and other details</summary>
    public static ReflectionFactory OfConcreteTypeAndMadeNoValidation(Type knownImplOrServiceType, Made made, IReuse reuse = null, Setup setup = null) =>
        setup == null | setup == Setup.Default
            ? (reuse == null ? new WithMade(knownImplOrServiceType, made) : new WithMadeAndReuse(knownImplOrServiceType, reuse, made))
            : WithAllDetails.OfConcreteType(knownImplOrServiceType, reuse, made, setup ?? Setup.Default);

    /// <summary>Creates the factory, that will generate a new factory for each new resolution service key or for the default key resolution</summary>
    public static ReflectionFactory OfAnyKey(Type knownImplOrServiceType, Made made, IReuse reuse, Setup setup) =>
        new WithAnyKeyGeneratorAndAllDetails(knownImplOrServiceType, reuse, made, setup ?? Setup.Default);

    /// <summary>Creates the factory based on arguments</summary>
    public static ReflectionFactory Of(Func<Type> implementationTypeProvider, IReuse reuse = null, Made made = null, Setup setup = null) =>
        new WithTypeProvider(implementationTypeProvider, reuse, made ?? Made.Default, setup ?? Setup.Default);

    /// <summary>Required for the `WithAllDetails` factory below</summary>
    protected ReflectionFactory() { }

    /// <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
    protected ReflectionFactory(Type implementationType) => _implementationTypeOrProviderOrPubCtorOrCtors = implementationType;

    internal sealed class WithSingletonReuse : ReflectionFactory
    {
        public override IReuse Reuse => DryIoc.Reuse.Singleton;
        public WithSingletonReuse(Type implementationType) : base(implementationType) { }
    }

    internal sealed class WithTransientReuse : ReflectionFactory
    {
        public override IReuse Reuse => DryIoc.Reuse.Transient;
        public WithTransientReuse(Type implementationType) : base(implementationType) { }
    }

    internal sealed class WithScopedOrSingletonReuse : ReflectionFactory
    {
        public override IReuse Reuse => DryIoc.Reuse.ScopedOrSingleton;
        public WithScopedOrSingletonReuse(Type implementationType) : base(implementationType) { }
    }

    internal sealed class WithScopedReuse : ReflectionFactory
    {
        public override IReuse Reuse => DryIoc.Reuse.Scoped;
        public WithScopedReuse(Type implementationType) : base(implementationType) { }
    }

    internal sealed class WithReuse : ReflectionFactory
    {
        public override IReuse Reuse { get; }
        public WithReuse(Type implementationType, IReuse reuse) : base(implementationType) => Reuse = reuse;
    }

    internal sealed class WithMade : ReflectionFactory
    {
        public override Made Made { get; }
        public WithMade(Type implementationType, Made made) : base(implementationType) => Made = made;
    }

    internal sealed class WithMadeAndReuse : ReflectionFactory
    {
        public override IReuse Reuse { get; }
        public override Made Made { get; }
        public WithMadeAndReuse(Type implementationType, IReuse reuse, Made made) : base(implementationType)
        {
            Reuse = reuse;
            Made = made;
        }
    }

    internal class WithAllDetails : ReflectionFactory
    {
        internal object _generatedFactoriesOrFactoryGenerator; // ImHashMap<KV<Type, object>, ReflectionFactory> or Factory
        ///<inheritdoc />
        public override ImHashMap<KV<Type, object>, ReflectionFactory> GeneratedFactories =>
            _generatedFactoriesOrFactoryGenerator as ImHashMap<KV<Type, object>, ReflectionFactory>;
        ///<inheritdoc />
        public override ReflectionFactory GeneratorFactory =>
            _generatedFactoriesOrFactoryGenerator as ReflectionFactory;

        public override IReuse Reuse { get; }
        public override Made Made { get; }
        public override Setup Setup { get; }
        protected WithAllDetails(object implementationType, IReuse reuse, Made made, Setup setup,
            ImHashMap<KV<Type, object>, ReflectionFactory> generatedFactories, FactoryFlags flags = default) : base()
        {
            _implementationTypeOrProviderOrPubCtorOrCtors = implementationType;
            Reuse = reuse;
            Made = made;
            Setup = setup;
            _generatedFactoriesOrFactoryGenerator = generatedFactories;
            Flags = flags;
        }

        [MethodImpl((MethodImplOptions)256)]
        internal static ReflectionFactory OfConcreteType(Type implType, IReuse reuse, Made made, Setup setup) =>
            new WithAllDetails(implType, reuse, made, setup, null);

        [MethodImpl((MethodImplOptions)256)]
        internal static ReflectionFactory OfOpenGenericType(Type implType, IReuse reuse, Made made, Setup setup,
            FactoryFlags flags = default) =>
            new WithAllDetails(implType, reuse, made, setup, ImHashMap<KV<Type, object>, ReflectionFactory>.Empty, flags);

        private WithAllDetails(ReflectionFactory factoryGenerator, Type implementationType, IReuse reuse, Made made, Setup setup) : base()
        {
            _implementationTypeOrProviderOrPubCtorOrCtors = implementationType;
            Reuse = reuse;
            Made = made;
            Setup = setup;
            _generatedFactoriesOrFactoryGenerator = factoryGenerator;
        }

        // todo: @perf optimize request.Details access and reflection here
        /// <inheritdoc />
        public override Factory GetGeneratedFactoryOrDefault(Request request, bool ifErrorReturnDefault = false)
        {
            var implType = ImplementationType;
            var serviceType = request.ActualServiceType;

            var closedTypeArgs = implType == null || implType == serviceType.GetGenericDefinitionOrNull()
                ? serviceType.GetGenericArguments()
                : implType.IsGenericParameter ? serviceType.One()
                : GetClosedTypeArgsOrNullForOpenGenericType(implType, serviceType, request, ifErrorReturnDefault);

            if (closedTypeArgs == null)
                return null;

            var made = Made;
            if (made.FactoryMethodOrSelector != null)
            {
                // resolve request with factory to specify the implementation type may be required by FactoryMethod or GetClosed...
                request = request.WithResolvedFactory(this, ifErrorReturnDefault, ifErrorReturnDefault, copyRequest: true);
                var factoryMethod = made.FactoryMethodOrSelector as FactoryMethod ?? ((FactoryMethodSelector)made.FactoryMethodOrSelector)(request);
                if (factoryMethod == null)
                    return ifErrorReturnDefault ? null : Throw.For<Factory>(Error.GotNullFactoryWhenResolvingService, request);

                var checkMatchingType = implType != null && implType.IsGenericParameter;
                var closedFactoryMethod = GetClosedFactoryMethodOrDefault(factoryMethod, closedTypeArgs, request, checkMatchingType);

                // may be null only for `IfUnresolved.ReturnDefault` or if the check for matching type is failed
                if (closedFactoryMethod == null)
                    return null;

                made = Made.Of(closedFactoryMethod, made.Parameters, made.PropertiesAndFields);
            }

            var details = request.GetServiceDetails();
            if (implType != null)
            {
                implType = implType.IsGenericParameter
                    ? closedTypeArgs[0]
                    : implType.TryCloseGenericTypeOrMethod(closedTypeArgs, (t, a) => t.MakeGenericType(a),
                        !ifErrorReturnDefault && details.IfUnresolved == IfUnresolved.Throw, Error.NoMatchedGenericParamConstraints, request);
                if (implType == null)
                    return null;
            }

            var knownImplOrServiceType = implType ?? made.FactoryMethodKnownResultType ?? serviceType;
            var serviceKey = details.ServiceKey;
            serviceKey = (serviceKey as ServiceKeyAndRequiredOpenGenericType)?.ServiceKey ?? serviceKey ?? DefaultKey.Value;
            var generatedFactoryKey = KV.Of(knownImplOrServiceType, serviceKey);

            var generatedFactories = GeneratedFactories;
            if (!generatedFactories.IsEmpty)
            {
                var generatedFactory = generatedFactories.GetValueOrDefault(generatedFactoryKey);
                if (generatedFactory != null)
                    return generatedFactory;
            }

            ReflectionFactory closedGenericFactory = new WithAllDetails(this, implType, Reuse, made, Setup) { Flags = Flags };

            Ref.Swap(ref _generatedFactoriesOrFactoryGenerator, generatedFactoryKey, closedGenericFactory,
                (x, genFacKey, closedGenFac) =>
                {
                    // todo: @perf @mem move the entry outside as it is always created with the same values
                    var newEntry = ImHashMap.Entry(genFacKey.GetHashCode(), genFacKey, closedGenFac);
                    var mapOrOldEntry = ((ImHashMap<KV<Type, object>, ReflectionFactory>)x).AddOrGetEntry(newEntry);
                    if (mapOrOldEntry is ImHashMapEntry<KV<Type, object>, ReflectionFactory> oldEntry && oldEntry != newEntry)
                    {
                        closedGenericFactory = oldEntry.Value;
                        return x;
                    }
                    return mapOrOldEntry;
                });

            return closedGenericFactory;
        }

        private static Type[] GetClosedTypeArgsOrNullForOpenGenericType(
            Type openImplType, Type closedServiceType, Request request, bool ifErrorReturnDefault)
        {
            var serviceTypeArgs = closedServiceType.GetGenericArguments();
            var serviceTypeGenericDef = closedServiceType.GetGenericTypeDefinition();

            var implTypeParams = openImplType.GetGenericArguments();
            var implTypeArgs = new Type[implTypeParams.Length];

            var implementedTypes = openImplType.GetImplementedTypes();

            var matchFound = false;
            for (var i = 0; !matchFound && i < implementedTypes.Length; ++i)
            {
                var implementedType = implementedTypes[i];
                if (implementedType.IsOpenGeneric() && implementedType.GetGenericDefinitionOrNull() == serviceTypeGenericDef)
                    matchFound = MatchServiceWithImplementedTypeParams(
                        implTypeArgs, implTypeParams, implementedType.GetGenericArguments(), serviceTypeArgs);
            }

            if (!matchFound)
                return ifErrorReturnDefault || request.IfUnresolved != IfUnresolved.Throw ? null
                    : Throw.For<Type[]>(Error.NoMatchedImplementedTypesWithServiceType,
                        openImplType, implementedTypes, request);

            MatchOpenGenericConstraints(implTypeParams, implTypeArgs);

            var notMatchedIndex = Array.IndexOf(implTypeArgs, null);
            if (notMatchedIndex != -1)
                return ifErrorReturnDefault || request.IfUnresolved != IfUnresolved.Throw ? null
                    : Throw.For<Type[]>(Error.NotFoundOpenGenericImplTypeArgInService,
                        openImplType, implTypeParams[notMatchedIndex], request);

            return implTypeArgs;
        }
    }

    internal class WithAnyKeyGeneratorAndAllDetails : ReflectionFactory
    {
        internal object _generatedFactoriesOrFactoryGenerator; // ImHashMap<KV<Type, object>, ReflectionFactory> or Factory
        ///<inheritdoc />
        public override ImHashMap<KV<Type, object>, ReflectionFactory> GeneratedFactories =>
            _generatedFactoriesOrFactoryGenerator as ImHashMap<KV<Type, object>, ReflectionFactory>;
        ///<inheritdoc />
        public override ReflectionFactory GeneratorFactory =>
            _generatedFactoriesOrFactoryGenerator as ReflectionFactory;

        public override IReuse Reuse { get; }
        public override Made Made { get; }
        public override Setup Setup { get; }
        internal WithAnyKeyGeneratorAndAllDetails(Type knownImplOrServiceType, IReuse reuse, Made made, Setup setup) : base()
        {
            _implementationTypeOrProviderOrPubCtorOrCtors = knownImplOrServiceType;
            Reuse = reuse;
            Made = made;
            Setup = setup;
            _generatedFactoriesOrFactoryGenerator = ImHashMap<KV<Type, object>, ReflectionFactory>.Empty;
        }

        private WithAnyKeyGeneratorAndAllDetails(ReflectionFactory factoryGenerator,
            Type knownImplOrServiceType, IReuse reuse, Made made, Setup setup) : base()
        {
            _implementationTypeOrProviderOrPubCtorOrCtors = knownImplOrServiceType;
            Reuse = reuse;
            Made = made;
            Setup = setup;
            _generatedFactoriesOrFactoryGenerator = factoryGenerator;
        }

        /// <inheritdoc />
        public override Factory GetGeneratedFactoryOrDefault(Request request, bool ifErrorReturnDefault = false)
        {
            var implOrServiceType = ImplementationType;
            var serviceKey = request.ServiceKey;
            serviceKey = serviceKey is Registrator.AnyServiceKey anyKey ? anyKey.ResolutionKey : serviceKey ?? DefaultKey.Value;
            var generatedFactoryKey = KV.Of(implOrServiceType, serviceKey);

            ReflectionFactory resultFactory = null;
            var generatedFactories = GeneratedFactories;
            if (!generatedFactories.IsEmpty)
            {
                resultFactory = generatedFactories.GetValueOrDefault(generatedFactoryKey);
                if (resultFactory != null)
                    return resultFactory.GeneratedFactories != null
                        ? resultFactory.GetGeneratedFactoryOrDefault(request)
                        : resultFactory;
            }

            if (IsFactoryGenerator(implOrServiceType, Made))
                resultFactory = WithAllDetails.OfOpenGenericType(implOrServiceType, Reuse, Made, Setup, Flags);
            else
                resultFactory = new WithAnyKeyGeneratorAndAllDetails(this, implOrServiceType, Reuse, Made, Setup) { Flags = Flags };

            var generatedFactoryEntry = ImHashMap.Entry(generatedFactoryKey.GetHashCode(), generatedFactoryKey, resultFactory);
            resultFactory = Ref.Swap(ref _generatedFactoriesOrFactoryGenerator, generatedFactoryEntry, resultFactory,
                static (map, ne, _) => ((ImHashMap<KV<Type, object>, ReflectionFactory>)map).AddOrGetEntry(ne),
                static (_, newMap, ne, rf) =>
                    newMap is ImHashMapEntry<KV<Type, object>, ReflectionFactory> existingEntry && existingEntry != ne
                        ? existingEntry.Value
                        : rf);

            return resultFactory != null && resultFactory.GeneratedFactories != null
                ? resultFactory.GetGeneratedFactoryOrDefault(request)
                : resultFactory;
        }
    }

    internal sealed class WithTypeProvider : WithAllDetails
    {
        public override bool CanAccessImplementationType => false;
        public override Type ImplementationType
        {
            get
            {
                var m = Made;
                var implType = ((Func<Type>)_implementationTypeOrProviderOrPubCtorOrCtors)();
                var validatedImplType = ValidateImplementationType(implType, m);
                if (IsFactoryGenerator(validatedImplType ?? implType, m))
                    _generatedFactoriesOrFactoryGenerator = ImHashMap<KV<Type, object>, ReflectionFactory>.Empty;
                return validatedImplType;
            }
        }

        public WithTypeProvider(Func<Type> implementationTypeProvider, IReuse reuse, Made made, Setup setup)
            : base(implementationTypeProvider.ThrowIfNull(), reuse, made, setup, null) { }
    }

    /// <summary>Creates service expression.</summary>
    public override Expression CreateExpressionOrDefault(Request request)
    {
        var container = request.Container;
        var rules = container.Rules;

        FactoryMethod factoryMethod = null;
        var ctor = _implementationTypeOrProviderOrPubCtorOrCtors as ConstructorInfo;
        if (ctor == null)
        {
            var factoryMethodSelector = Made.FactoryMethodOrSelector ?? rules.FactoryMethodOrSelector;
            if (factoryMethodSelector != null)
            {
                factoryMethod = factoryMethodSelector as FactoryMethod ?? ((FactoryMethodSelector)factoryMethodSelector)(request);
                if (factoryMethod == null)
                {
                    if (request.IfUnresolved != IfUnresolved.ReturnDefault)
                        Throw.It(Error.UnableToSelectCtor, request.ImplementationType, request);
                    return null;
                }
            }
        }

        MethodBase ctorOrMethod;
        MethodInfo method = null;
        Expression factoryExpr = null;
        Delegate factoryFunc = null;
        if (factoryMethod == null)
        {
            ctorOrMethod = ctor = ctor ?? request.ImplementationType.SingleConstructor();
        }
        else
        {
            factoryFunc = factoryMethod.FactoryFunc;
            if (factoryFunc != null)
            {
                if (rules.ThrowIfRuntimeStateRequired)
                    Throw.StateIsRequiredToUseItem(factoryFunc.Target);
            }
            else
            {
                // here we are not handling the UsedForExpressionGeneration
                factoryExpr = factoryMethod.FactoryExpression;
                if (factoryExpr == null)
                {
                    // If factory method is the method of some registered service, then resolve factory service first.
                    if (factoryMethod.FactoryServiceInfo != null)
                    {
                        var factoryRequest = request.Push(factoryMethod.FactoryServiceInfo);
                        factoryExpr = container.ResolveFactory(factoryRequest)?.GetExpressionOrDefault(factoryRequest);
                        if (factoryExpr == null)
                            return null; // todo: @check should we check for request.IfUnresolved != IfUnresolved.ReturnDefault here?
                    }
                }
            }

            // return earlier if already have the parameters resolved, e.g. when using `ConstructorWithResolvableArguments`
            var ctorOrMember = factoryMethod.ConstructorOrMethodOrMember;
            if (factoryMethod.ResolvedParameterExpressions != null)
            {
                ctor = (ConstructorInfo)ctorOrMember;
                request.SelectedConstructor = ctor;

                if (rules.UsedForValidation)
                {   // evaluate the assignments without using the result for the side-effect sake
                    TryGetMemberInitList(null, request, container, rules, validateOnly: true);
                    return request.ActualServiceType.GetDefaultValueExpression();
                }

                var newExpr = New(ctor, factoryMethod.ResolvedParameterExpressions);
                return TryGetMemberInitList(newExpr, request, container, rules);
            }

            ctorOrMethod = ctorOrMember as MethodBase;
            if (ctorOrMethod == null) // return earlier when factory is Property or Field
                return ConvertExpressionIfNeeded(
                    ctorOrMember is PropertyInfo p ? Property(factoryExpr, p) : Field(factoryExpr, (FieldInfo)ctorOrMember), request, ctorOrMember);

            ctor = ctorOrMethod as ConstructorInfo;
            method = ctorOrMethod as MethodInfo;
        }

        request.SelectedConstructor = ctor;

        var parameters = ctorOrMethod.GetParameters();
        if (parameters.Length == 0)
        {
            if (rules.UsedForValidation)
            {
                if (ctor != null)
                    TryGetMemberInitList(null, request, container, rules, validateOnly: true);
                return request.ActualServiceType.GetDefaultValueExpression();
            }
            if (method != null)
            {
                var callExpr = factoryFunc != null ? new FuncInvoke0Expression(factoryFunc, method) : Call(factoryExpr, method);
                return ConvertExpressionIfNeeded(callExpr, request, method);
            }
            return TryGetMemberInitList(New(ctor), request, container, rules);
        }

        var hasByRefParams = false;
        Expression a0 = null, a1 = null, a2 = null, a3 = null, a4 = null, a5 = null, a6 = null;
        var paramExprs = parameters.Length > 7 ? new Expression[parameters.Length] : null;
        var rulesParams = rules._made.Parameters;
        var madeParams = Made.Parameters;
        Func<ParameterInfo, ParameterServiceInfo> paramSelector = null;
        if (rulesParams != null | madeParams != null)
            paramSelector = (rules.OverrideRegistrationMade ? madeParams.OverrideWith(rulesParams) : rulesParams.OverrideWith(madeParams))(request);

        var inputArgs = request.InputArgExprs;
        var argsUsedMask = 0;
        for (var i = 0; i < parameters.Length; ++i)
        {
            var param = parameters[i];
            var paramType = param.ParameterType;
            if (inputArgs != null)
            {
                var inputArgExpr = TryGetExpressionFromInputArgs(paramType, inputArgs, ref argsUsedMask);
                if (inputArgExpr != null)
                {
                    if (paramExprs != null)
                        paramExprs[i] = inputArgExpr;
                    else switch (i)
                        {
                            case 0: a0 = inputArgExpr; break;
                            case 1: a1 = inputArgExpr; break;
                            case 2: a2 = inputArgExpr; break;
                            case 3: a3 = inputArgExpr; break;
                            case 4: a4 = inputArgExpr; break;
                            case 5: a5 = inputArgExpr; break;
                            case 6: a6 = inputArgExpr; break;
                        }
                    continue;
                }
            }

            hasByRefParams |= paramType.IsByRef;

            var paramServiceInfo = paramSelector == null
                ? ParameterServiceInfo.OrNull(param)
                : (paramSelector(param) ?? ParameterServiceInfo.OrNull(param));

            Factory paramFactory = null;
            Request paramRequest = null;
            var paramDetails = ServiceDetails.Default;
            if (paramServiceInfo != ParameterServiceInfo.DefinitelyUnresolvedParameter)
            {
                if (paramServiceInfo == null)
                    paramRequest = request.Push(param);
                else
                {
                    paramRequest = request.Push(paramServiceInfo);
                    paramDetails = paramServiceInfo.Details;
                }

                var usedOrCustomValExpr = TryGetUsedInstanceOrCustomValueExpression(request, paramRequest, paramDetails);
                if (usedOrCustomValExpr != null)
                {
                    if (paramExprs != null)
                        paramExprs[i] = usedOrCustomValExpr;
                    else switch (i)
                        {
                            case 0: a0 = usedOrCustomValExpr; break;
                            case 1: a1 = usedOrCustomValExpr; break;
                            case 2: a2 = usedOrCustomValExpr; break;
                            case 3: a3 = usedOrCustomValExpr; break;
                            case 4: a4 = usedOrCustomValExpr; break;
                            case 5: a5 = usedOrCustomValExpr; break;
                            case 6: a6 = usedOrCustomValExpr; break;
                        }
                    continue;
                }

                paramFactory = container.ResolveFactory(paramRequest);
            }

            if (paramFactory == null & rules.GenerateResolutionCallForMissingDependency)
            {
                var paramResolutionCall = Resolver.CreateResolutionExpression(paramRequest ?? request.Push(param), generateResolutionCallForMissingDependency: true);
                if (paramExprs != null)
                    paramExprs[i] = paramResolutionCall;
                else switch (i)
                    {
                        case 0: a0 = paramResolutionCall; break;
                        case 1: a1 = paramResolutionCall; break;
                        case 2: a2 = paramResolutionCall; break;
                        case 3: a3 = paramResolutionCall; break;
                        case 4: a4 = paramResolutionCall; break;
                        case 5: a5 = paramResolutionCall; break;
                        case 6: a6 = paramResolutionCall; break;
                    }
                continue;
            }
            var injectedExpr = paramFactory?.GetExpressionOrDefault(paramRequest);
            if (injectedExpr == null ||
                // When param is an empty array / collection, then we may use a default value instead (#581)
                paramDetails.DefaultValue != null && injectedExpr.NodeType == ExprType.NewArrayInit && ((NewArrayExpression)injectedExpr).ArgumentCount == 0)
            {
                // Check if parameter dependency itself (without propagated parent details)
                // does not allow default, then stop checking the rest of the parameters.
                if (paramDetails.IfUnresolved == IfUnresolved.Throw)
                    return null;
                injectedExpr = paramDetails.DefaultValue != null
                    ? container.GetConstantExpression(paramDetails.DefaultValue, paramRequest.ServiceType)
                    : paramRequest.ServiceType.GetDefaultValueExpression();
            }

            if (paramExprs != null)
                paramExprs[i] = injectedExpr;
            else switch (i)
                {
                    case 0: a0 = injectedExpr; break;
                    case 1: a1 = injectedExpr; break;
                    case 2: a2 = injectedExpr; break;
                    case 3: a3 = injectedExpr; break;
                    case 4: a4 = injectedExpr; break;
                    case 5: a5 = injectedExpr; break;
                    case 6: a6 = injectedExpr; break;
                }
        }

        if (rules.UsedForValidation)
            return request.ActualServiceType.GetDefaultValueExpression();

        Expression serviceExpr;
        if (a0 == null) // thus handling multiple arguments (more than 7 currently)
            serviceExpr = ctor != null ? hasByRefParams ? New(ctor, paramExprs) : NewNoByRefArgs(ctor, paramExprs)
                : Call(factoryExpr, method, paramExprs);
        else if (a1 == null)
            serviceExpr = ctor != null ? hasByRefParams ? New(ctor, a0) : NewNoByRefArgs(ctor, a0)
                : factoryFunc != null ? new FuncInvoke1Expression(factoryFunc, a0) : Call(factoryExpr, method, a0);
        else if (a2 == null)
            serviceExpr = ctor != null ? hasByRefParams ? New(ctor, a0, a1) : NewNoByRefArgs(ctor, a0, a1)
                : factoryFunc != null ? new FuncInvoke2Expression(factoryFunc, a0, a1) : Call(factoryExpr, method, a0, a1);
        else if (a3 == null)
            serviceExpr = ctor != null ? hasByRefParams ? New(ctor, a0, a1, a2) : NewNoByRefArgs(ctor, a0, a1, a2)
                : factoryFunc != null ? new FuncInvoke3Expression(factoryFunc, a0, a1, a2) : Call(factoryExpr, method, a0, a1, a2);
        else if (a4 == null)
            serviceExpr = ctor != null ? hasByRefParams ? New(ctor, a0, a1, a2, a3) : NewNoByRefArgs(ctor, a0, a1, a2, a3)
                : factoryFunc != null ? new FuncInvoke4Expression(factoryFunc, a0, a1, a2, a3) : Call(factoryExpr, method, a0, a1, a2, a3);
        else if (a5 == null)
            serviceExpr = ctor != null ? hasByRefParams ? New(ctor, a0, a1, a2, a3, a4) : NewNoByRefArgs(ctor, a0, a1, a2, a3, a4)
                : factoryFunc != null ? new FuncInvoke5Expression(factoryFunc, a0, a1, a2, a3, a4) : Call(factoryExpr, method, a0, a1, a2, a3, a4);
        else if (a6 == null)
            serviceExpr = ctor != null ? hasByRefParams ? New(ctor, a0, a1, a2, a3, a4, a5) : NewNoByRefArgs(ctor, a0, a1, a2, a3, a4, a5)
                : factoryFunc != null ? new FuncInvoke6Expression(factoryFunc, a0, a1, a2, a3, a4, a5) : Call(factoryExpr, method, a0, a1, a2, a3, a4, a5);
        else
            serviceExpr = ctor != null ? hasByRefParams ? New(ctor, a0, a1, a2, a3, a4, a5, a6) : NewNoByRefArgs(ctor, a0, a1, a2, a3, a4, a5, a6)
                : factoryFunc != null ? new FuncInvoke7Expression(factoryFunc, a0, a1, a2, a3, a4, a5, a6) : Call(factoryExpr, method, a0, a1, a2, a3, a4, a5, a6);

        if (ctor == null)
            return ConvertExpressionIfNeeded(serviceExpr, request, ctorOrMethod);

        return TryGetMemberInitList((NewExpression)serviceExpr, request, container, rules);
    }

    private Expression TryGetMemberInitList(NewExpression newExpr, Request request, IContainer container, Rules rules,
        bool validateOnly = false)
    {
        if (rules.PropertiesAndFields == null && Made.PropertiesAndFields == null)
            return newExpr;

        var propertiesAndFields = rules.TryGetPropertiesAndFieldsSelector(Made).Invoke(request);
        if (propertiesAndFields == null)
            return newExpr;

        object memberOrMembers = null; // null | MemberAssignment | MemberAssignment[] // the man made discriminated union
        foreach (var member in propertiesAndFields)
            if (member != null)
            {
                var memberRequest = request.Push(member);
                var memberExpr = TryGetUsedInstanceOrCustomValueExpression(request, memberRequest, member.Details);
                if (memberExpr == null)
                    memberExpr = container.ResolveFactory(memberRequest)?.GetExpressionOrDefault(memberRequest);

                if (memberExpr == null)
                {
                    if (request.IfUnresolved == IfUnresolved.ReturnDefault)
                        return null; // todo: @wip add two properties to indicate that we have failed to get the member
                    continue;
                }

                if (!validateOnly)
                {
                    var memberAssignment = Bind(member.Member, memberExpr);
                    memberOrMembers = memberOrMembers == null ? memberAssignment
                        : memberOrMembers is MemberAssignment ma0 ? new MemberAssignment[] { ma0, memberAssignment }
                        : ((MemberAssignment[])memberOrMembers).AppendToNonEmpty(memberAssignment);
                }
            }

        if (validateOnly)
            return null;
        return memberOrMembers == null ? newExpr
            : memberOrMembers is MemberAssignment ma
                ? MemberInit(newExpr, ma)
                : MemberInitMany(newExpr, (MemberAssignment[])memberOrMembers);
    }

    private static Expression ConvertExpressionIfNeeded(Expression serviceExpr, Request request, MemberInfo ctorOrMember)
    {
        var actualServiceType = request.ActualServiceType;
        var serviceExprType = serviceExpr.Type;
        if (serviceExprType == actualServiceType || actualServiceType.IsAssignableFrom(serviceExprType))
            return serviceExpr;
        if (serviceExprType == typeof(object))
            return TryConvertIntrinsic(serviceExpr, actualServiceType);
        var conversionMethod = serviceExprType.GetConversionOperatorOrNull(actualServiceType);
        if (conversionMethod != null)
            return Convert(serviceExpr, actualServiceType, conversionMethod);
        return request.IfUnresolved != IfUnresolved.Throw ? null
                : Throw.For<Expression>(Error.ServiceIsNotAssignableFromFactoryMethod, actualServiceType, ctorOrMember, request);
    }

    // Check not yet used arguments provided via `Func<Arg, TService>` or `Resolve(.., args: new[] { arg })`
    internal static Expression TryGetExpressionFromInputArgs(Type paramType, Expression[] inputArgs, ref int argsUsedMask)
    {
        for (var a = 0; a < inputArgs.Length; ++a)
        {
            var inputArg = inputArgs[a];
            if ((argsUsedMask & 1 << a) == 0 && paramType.IsAssignableFrom(inputArg.Type))
            {
                argsUsedMask |= 1 << a; // mark that argument was used
                return inputArg;
            }
        }
        return null;
    }

    internal static Expression TryGetUsedInstanceOrCustomValueExpression(Request request, Request paramRequest, ServiceDetails paramDetails)
    {
        var serviceType = paramRequest.ServiceType;
        if (paramDetails.HasCustomValue)
        {
            MethodInfo conversionOperator = null;
            var customValue = paramDetails.CustomValue;
            if (customValue != null)
            {
                var customTypeValue = customValue.GetType();
                if (!customTypeValue.IsArray && !serviceType.IsAssignableFrom(customTypeValue) &&
                    null == (conversionOperator = customTypeValue.GetConversionOperatorOrNull(serviceType)))
                    return Throw.For<Expression>(paramRequest.IfUnresolved != IfUnresolved.ReturnDefault,
                        Error.InjectedCustomValueIsOfDifferentType, customValue, serviceType, paramRequest);
            }

            return conversionOperator != null
                ? Convert(request.Container.GetConstantExpression(customValue), serviceType, conversionOperator)
                : request.Container.GetConstantExpression(customValue, serviceType);
        }

        // Generate the fast resolve call for used instances
        if (paramDetails == DryIoc.ServiceDetails.Default &&
            request.Container.TryGetUsedInstance(RuntimeHelpers.GetHashCode(serviceType), serviceType, out var instance))
            return Call(ResolverContext.GetRootOrSelfExpr(paramRequest), Resolver.ResolveFastMethod,
                ConstantOf(serviceType), paramRequest.IfUnresolved.ToConstant());

        return null;
    }

    internal override bool ValidateAndNormalizeRegistration(Type serviceType, object serviceKey, bool isStaticallyChecked, Rules rules, bool throwIfInvalid)
    {
        if (!base.ValidateAndNormalizeRegistration(serviceType, serviceKey, isStaticallyChecked, rules, throwIfInvalid))
            return false;

        if (!CanAccessImplementationType)
            return true;

        // skip the step if the _implementationTypeOrProviderOrPubCtorOrCtors is already ConstructorInfo or ConstructorInfo[],
        // so we called the method already, e.g. from the RegisterMany.
        var ctorsOrType = _implementationTypeOrProviderOrPubCtorOrCtors;
        var implType = ctorsOrType as Type;
        if (implType != null)
        {
            var factoryMethod = Made.FactoryMethodOrSelector ?? rules.FactoryMethodOrSelector;
            if (factoryMethod == null | ReferenceEquals(factoryMethod, FactoryMethod.ConstructorWithResolvableArguments)) // optimizing for one of the common cases with the ConstructorWithResolvableArguments
            {
                var ctors = implType.GetConstructors(); // getting all public instance constructors with particular order
                var ctorCount = ctors.Length;
                if (ctorCount == 1)
                {
                    // todo: @perf do we need it for the open-generic because we still want to create the closed-generic type and then ask for its constructors again
                    _implementationTypeOrProviderOrPubCtorOrCtors = ctors[0];
                }
                else if (ctorCount == 0) // todo: @feature struct/ValueType without constructor is not supported, because there is no default constructor generated for it
                    return Throw.When(throwIfInvalid, Error.UnableToSelectSinglePublicConstructorFromNone, implType);
                else if (factoryMethod == null)
                    return Throw.When(throwIfInvalid, Error.UnableToSelectSinglePublicConstructorFromMultiple, implType, ctors);
                else
                {
                    // todo: @perf do we need it for the open-generic because we still want to create the closed-generic type and then ask for its constructors again
                    _implementationTypeOrProviderOrPubCtorOrCtors = ctors; // store the constructors to prevent calling the GetConstructors(...) again for ConstructorWithResolvableArguments
                }
            }
        }
        else if (ctorsOrType is ConstructorInfo c)
            implType = c.DeclaringType;
        else if (ctorsOrType is ConstructorInfo[] cs)
            implType = cs[0].DeclaringType;

        if (isStaticallyChecked || implType == null)
            return true;

        if (!implType.IsGenericTypeDefinition)
        {
            if (implType.IsGenericType && implType.ContainsGenericParameters)
                return Throw.When(throwIfInvalid, Error.RegisteringNotAGenericTypedefImplType, implType, implType.GetGenericDefinitionOrNull());

            if (implType != serviceType | serviceType != typeof(object))
            {
                if (!serviceType.IsGenericTypeDefinition)
                {
                    if (!serviceType.IsAssignableFrom(implType))
                        return Throw.When(throwIfInvalid, Error.RegisteringImplementationNotAssignableToServiceType, implType, serviceType);
                }
                else if (implType.GetImplementedTypes().IndexOf(serviceType,
                    static (st, t) => t == st || t.GetGenericDefinitionOrNull() == st) == -1)
                    return Throw.When(throwIfInvalid, Error.RegisteringImplementationNotAssignableToServiceType, implType, serviceType);
            }
        }
        else if (implType != serviceType)
        {
            if (serviceType.IsGenericTypeDefinition)
                return ValidateImplementationAndServiceTypeParamsMatch(implType, serviceType, throwIfInvalid);

            if (!serviceType.IsGenericType)
                return Throw.When(throwIfInvalid, Error.RegisteringOpenGenericImplWithNonGenericService, implType, serviceType);

            if (!implType.IsImplementingServiceType(serviceType.GetGenericTypeDefinition()))
                return Throw.When(throwIfInvalid, Error.RegisteringImplementationNotAssignableToServiceType, implType, serviceType);
        }

        return true;
    }

    private static bool ValidateImplementationAndServiceTypeParamsMatch(Type implType, Type serviceType, bool throwIfInvalid)
    {
        var implTypeParams = implType.GetGenericArguments();
        var implementedTypes = implType.GetImplementedTypes(); // todo: @perf we are extracting the implemented types once on validation and then when resolving the open-generic and matching with service type, can we save our work here?

        var implementedTypeFound = false;
        var containsAllTypeParams = false;
        for (var i = 0; !containsAllTypeParams && i < implementedTypes.Length; ++i)
        {
            var implementedType = implementedTypes[i];
            implementedTypeFound = implementedType.GetGenericDefinitionOrNull() == serviceType;
            containsAllTypeParams = implementedTypeFound && implementedType.ContainsAllGenericTypeParameters(implTypeParams);
        }

        if (!implementedTypeFound)
            return Throw.When(throwIfInvalid, Error.RegisteringImplementationNotAssignableToServiceType, implType, serviceType);

        if (!containsAllTypeParams)
            return Throw.When(throwIfInvalid, Error.RegisteringOpenGenericServiceWithMissingTypeArgs,
                implType, serviceType, implementedTypes.Match(serviceType, (st, t) => t.GetGenericDefinitionOrNull() == st));

        return true;
    }

    private static void MatchOpenGenericConstraints(Type[] implTypeParams, Type[] implTypeArgs)
    {
        for (var i = 0; i < implTypeParams.Length; i++)
        {
            var implTypeArg = implTypeArgs[i];
            if (implTypeArg == null)
                continue; // skip yet unknown type arg

            var implTypeParamConstraints = implTypeParams[i].GetGenericParameterConstraints();
            if (implTypeParamConstraints.IsNullOrEmpty())
                continue; // skip case with no constraints

            // match type parameters inside constraint
            var constraintMatchFound = false;
            for (var j = 0; !constraintMatchFound && j < implTypeParamConstraints.Length; ++j)
            {
                var implTypeParamConstraint = implTypeParamConstraints[j];
                if (implTypeParamConstraint != implTypeArg && implTypeParamConstraint.IsOpenGeneric())
                {
                    var implTypeArgArgs =
                        implTypeArg.IsGenericType ? implTypeArg.GetGenericArguments() :
                        implTypeArg.IsArray ? implTypeArg.GetElementType().One() :
                        implTypeArg.One();
                    var implTypeParamConstraintParams = implTypeParamConstraint.GetGenericArguments();

                    constraintMatchFound = MatchServiceWithImplementedTypeParams(
                        implTypeArgs, implTypeParams, implTypeParamConstraintParams, implTypeArgArgs);
                }
            }
        }
    }

    private static bool MatchServiceWithImplementedTypeParams(
        Type[] resultImplArgs, Type[] implParams, Type[] serviceParams, Type[] serviceArgs)
    {
        if (serviceArgs.Length != serviceParams.Length)
            return false;

        for (var i = 0; i < serviceParams.Length; i++)
        {
            var serviceArg = serviceArgs[i];
            var implementedParam = serviceParams[i];
            if (implementedParam.IsGenericParameter)
            {
                var paramIndex = implParams.Length - 1;
                while (paramIndex != -1 && !ReferenceEquals(implParams[paramIndex], implementedParam))
                    --paramIndex;
                if (paramIndex != -1)
                {
                    if (resultImplArgs[paramIndex] == null)
                        resultImplArgs[paramIndex] = serviceArg;
                    else if (resultImplArgs[paramIndex] != serviceArg)
                        return false; // more than one service type arg is matching with single implementation type parameter
                }
            }
            else if (implementedParam != serviceArg)
            {
                if (!implementedParam.IsOpenGeneric() ||
                    implementedParam.GetGenericDefinitionOrNull() != serviceArg.GetGenericDefinitionOrNull())
                    return false; // type parameter and argument are of different types

                if (!MatchServiceWithImplementedTypeParams(resultImplArgs, implParams,
                    implementedParam.GetGenericArguments(), serviceArg.GetGenericArguments()))
                    return false; // nested match failed due one of above reasons.
            }
        }

        return true;
    }

    private static FactoryMethod GetClosedFactoryMethodOrDefault(
        FactoryMethod factoryMethod, Type[] serviceTypeArgs, Request request, bool ifErrorReturnDefault = false)
    {
        var factoryMember = factoryMethod.ConstructorOrMethodOrMember;
        var factoryInfo = factoryMethod.FactoryServiceInfo;

        var resultType = factoryMember.GetReturnTypeOrDefault();
        var implTypeParams = resultType.IsGenericParameter ? resultType.One() : resultType.GetGenericArguments();

        // Get method declaring type, and if its open-generic,
        // then close it first. It is required to get actual method.
        var factoryImplType = factoryMember.DeclaringType.ThrowIfNull();
        if (factoryImplType.IsOpenGeneric())
        {
            var factoryImplTypeParams = factoryImplType.GetGenericArguments();
            var resultFactoryImplTypeArgs = new Type[factoryImplTypeParams.Length];

            var isFactoryImplTypeClosed = MatchServiceWithImplementedTypeParams(
                resultFactoryImplTypeArgs, factoryImplTypeParams, implTypeParams, serviceTypeArgs);

            if (!isFactoryImplTypeClosed)
                return ifErrorReturnDefault || request.IfUnresolved != IfUnresolved.Throw ? null
                    : Throw.For<FactoryMethod>(Error.NoMatchedFactoryMethodDeclaringTypeWithServiceTypeArgs,
                        factoryImplType, serviceTypeArgs, request);

            // For instance factory match its service type from the implementation factory type.
            if (factoryInfo != null)
            {
                // Look for service type equivalent within factory implementation type base classes and interfaces,
                // because we need identical type arguments to match.
                var factoryServiceType = factoryInfo.ServiceType;
                if (factoryServiceType != factoryImplType)
                    factoryServiceType = factoryImplType.GetImplementedTypes()
                        .FindFirst(factoryServiceType, static (fServiceType, t) => t.IsGenericType && t.GetGenericTypeDefinition() == fServiceType)
                        .ThrowIfNull();

                var factoryServiceTypeParams = factoryServiceType.GetGenericArguments();
                var resultFactoryServiceTypeArgs = new Type[factoryServiceTypeParams.Length];

                var isFactoryServiceTypeClosed = MatchServiceWithImplementedTypeParams(
                    resultFactoryServiceTypeArgs, factoryServiceTypeParams, factoryImplTypeParams, resultFactoryImplTypeArgs);

                // Replace factory info with close factory service type
                if (isFactoryServiceTypeClosed)
                {
                    factoryServiceType = factoryServiceType.GetGenericTypeDefinition().ThrowIfNull();
                    var closedFactoryServiceType = factoryServiceType.TryCloseGenericTypeOrMethod(
                        resultFactoryServiceTypeArgs, static (t, a) => t.MakeGenericType(a),
                        !ifErrorReturnDefault && request.IfUnresolved == IfUnresolved.Throw, Error.NoMatchedGenericParamConstraints, request);

                    if (closedFactoryServiceType == null)
                        return null;

                    // Copy factory info with closed factory type
                    factoryInfo = ServiceInfo.Of(closedFactoryServiceType).WithDetails(factoryInfo.Details);
                }
            }

            MatchOpenGenericConstraints(factoryImplTypeParams, resultFactoryImplTypeArgs);

            // Close the factory type implementation
            // and get factory member to use from it.
            var closedFactoryImplType = factoryImplType.TryCloseGenericTypeOrMethod(
                resultFactoryImplTypeArgs, static (t, a) => t.MakeGenericType(a),
                !ifErrorReturnDefault & request.IfUnresolved == IfUnresolved.Throw, Error.NoMatchedGenericParamConstraints, request);

            if (closedFactoryImplType == null)
                return null;

            // Find corresponding member again, now from closed type
            var factoryMethodBase = factoryMember as MethodBase;
            if (factoryMethodBase != null)
            {
                var targetMethods = closedFactoryImplType.GetMethods()
                    .Match(factoryMember, factoryMethodBase.GetParameters(),
                        static (fm, fp, m) => m.Name == fm.Name && m.GetParameters().Length == fp.Length);

                if (targetMethods.Length == 1)
                    factoryMember = targetMethods[0];
                else // Fallback to MethodHandle only if methods have similar signatures
                {
                    var methodHandleProperty = typeof(MethodBase).GetProperty("MethodHandle")
                        .ThrowIfNull(Error.OpenGenericFactoryMethodDeclaringTypeIsNotSupportedOnThisPlatform,
                            factoryImplType, closedFactoryImplType, factoryMethodBase.Name);
                    factoryMember = MethodBase.GetMethodFromHandle(
                        (RuntimeMethodHandle)methodHandleProperty.GetValue(factoryMethodBase, Empty<object>()),
                        closedFactoryImplType.TypeHandle);
                }
            }
            else if (factoryMember is FieldInfo)
                factoryMember = closedFactoryImplType.GetField(factoryMember.Name).ThrowIfNull();
            else if (factoryMember is PropertyInfo)
                factoryMember = closedFactoryImplType.GetProperty(factoryMember.Name).ThrowIfNull();
        }

        // If factory method is actual method and still open-generic after closing its declaring type,
        // then match remaining method type parameters and make closed method
        var openFactoryMethod = factoryMember as MethodInfo;
        if (openFactoryMethod != null && openFactoryMethod.ContainsGenericParameters)
        {
            var methodTypeParams = openFactoryMethod.GetGenericArguments();
            var resultMethodTypeArgs = new Type[methodTypeParams.Length];

            var isMethodClosed = MatchServiceWithImplementedTypeParams(
                resultMethodTypeArgs, methodTypeParams, implTypeParams, serviceTypeArgs);

            if (!isMethodClosed)
                return ifErrorReturnDefault || request.IfUnresolved != IfUnresolved.Throw ? null
                    : Throw.For<FactoryMethod>(Error.NoMatchedFactoryMethodWithServiceTypeArgs,
                        openFactoryMethod, serviceTypeArgs, request);

            MatchOpenGenericConstraints(methodTypeParams, resultMethodTypeArgs);

            factoryMember = openFactoryMethod.TryCloseGenericTypeOrMethod(
                resultMethodTypeArgs, static (m, a) => m.MakeGenericMethod(a),
                !ifErrorReturnDefault && request.IfUnresolved == IfUnresolved.Throw, Error.NoMatchedGenericParamConstraints, request);

            if (factoryMember == null)
                return null;
        }

        var factoryInstance = factoryMethod.FactoryExpression;
        return factoryInstance != null
            ? new FactoryMethod.WithFactoryExpression(factoryMember, factoryInstance)
            : new FactoryMethod.WithFactoryServiceInfo(factoryMember, factoryInfo);
    }
}

/// <summary>Creates service expression using client provided expression factory delegate.</summary>
public sealed class ExpressionFactory : Factory
{


    /// <inheritdoc/>
    public override IReuse Reuse { get; }
    /// <inheritdoc/>
    public override Setup Setup { get; }
    private readonly Func<Request, Expression> _getServiceExpression;

    /// <summary>Constructor</summary>
    public ExpressionFactory(Func<Request, Expression> getServiceExpression, IReuse reuse = null, Setup setup = null)
    {
        _getServiceExpression = getServiceExpression.ThrowIfNull();
        Reuse = reuse;
        Setup = setup ?? Setup.Default;
    }

    /// <inheritdoc/>
    public override Expression CreateExpressionOrDefault(Request request) => _getServiceExpression(request);
}

/// <summary>Creates service expression using client provided expression factory delegate.
/// Important! that it may use the already resolved service factory unwrapped by the higher wrapper</summary>
public class WrapperExpressionFactory : Factory
{
    /// <summary>Creates the factory out of provided delegate producing the expression based on the request</summary>
    public static WrapperExpressionFactory Of(Func<Request, Factory, Expression> getServiceExpression) =>
        new WrapperExpressionFactory(getServiceExpression);

    /// <summary>Creates the factory out of provided delegate producing the expression based on the request, and the setup</summary>
    public static WrapperExpressionFactory Of(Func<Request, Factory, Expression> getServiceExpression, Setup setup) =>
        setup == null || setup == Setup.Wrapper
            ? new WrapperExpressionFactory(getServiceExpression)
            : new WrapperExpressionFactoryWithSetup(getServiceExpression, setup);

    /// <summary>Creates the factory out of provided delegate producing the expression based on the request, and the setup and/or setup</summary>
    public static WrapperExpressionFactory Of(Func<Request, Factory, Expression> getServiceExpression, IReuse reuse, Setup setup = null) =>
        reuse == null
            ? Of(getServiceExpression, setup)
            : new WrapperExpressionFactoryWithReuseAndSetup(getServiceExpression, reuse, setup ?? Setup.Wrapper);

    /// <inheritdoc/>
    public override IReuse Reuse => DryIoc.Reuse.Transient;

    /// <inheritdoc/>
    public override Setup Setup => Setup.Wrapper;

    private readonly Func<Request, Factory, Expression> _getServiceExpression;

    /// <summary>Constructor</summary>
    private WrapperExpressionFactory(Func<Request, Factory, Expression> getServiceExpression) =>
        _getServiceExpression = getServiceExpression;

    private class WrapperExpressionFactoryWithSetup : WrapperExpressionFactory
    {
        public override Setup Setup { get; }
        public WrapperExpressionFactoryWithSetup(Func<Request, Factory, Expression> getServiceExpression, Setup setup)
            : base(getServiceExpression) => Setup = setup;
    }

    internal sealed class OfContainer : WrapperExpressionFactory
    {
        // Despite the name, this setup prevents the wrapping of the expression into HiddenDisposable,
        // instead it will allow to keep the Transient reuse when cheking WithResolvedFactory 
        public override Setup Setup => Setup.WrapperWithPreventDisposal;
        public OfContainer(Func<Request, Factory, Expression> getServiceExpression)
            : base(getServiceExpression) { }

        public override Expression GetExpressionOrDefault(Request request)
        {
            request = request.WithResolvedFactoryUnsafe(this);
            if (request.Container._registry.Value is Container.Registry r && !r.Decorators.IsEmpty)
            {
                var decoratorExpr = request.Container.GetDecoratorExpressionOrDefault(request);
                if (decoratorExpr != null)
                    return decoratorExpr;
            }
            return _getServiceExpression(request, null);
        }
    }

    private sealed class WrapperExpressionFactoryWithReuseAndSetup : WrapperExpressionFactoryWithSetup
    {
        public override IReuse Reuse { get; }
        public WrapperExpressionFactoryWithReuseAndSetup(Func<Request, Factory, Expression> getServiceExpression, IReuse reuse, Setup setup)
            : base(getServiceExpression, setup) => Reuse = reuse;
    }

    /// <inheritdoc/>
    public override Expression CreateExpressionOrDefault(Request request) =>
        _getServiceExpression(request, null);

    /// <inheritdoc/>
    public override Expression CreateExpressionWithWrappedFactory(Request request, Factory serviceFactory) =>
        _getServiceExpression(request, serviceFactory);
}

/// <summary>Wraps the instance in registry</summary>
public class InstanceFactory : Factory
{
    /// <summary>The registered pre-created object instance</summary>
    public readonly object Instance;

    /// <summary>Non-abstract closed implementation type.</summary>
    public override Type ImplementationType => Instance?.GetType();
    /// <inheritdoc/>
    public override IReuse Reuse => DryIoc.Reuse.Singleton;
    /// <inheritdoc/>
    public override Setup Setup => Setup.AsResolutionCallForGeneratedExpressionSetup;
    /// <inheritdoc />
    public override bool HasRuntimeState => true;

    /// <summary>Creates the memory-optimized factory from the supplied arguments</summary>
    public static InstanceFactory Of(object instance) => new InstanceFactory(instance);

    /// <summary>Creates the memory-optimized factory from the supplied arguments</summary>
    public static InstanceFactory Of(object instance, Setup setup) =>
        setup == null || setup == Setup.Default
            ? new InstanceFactory(instance)
            : new WithAllDetails(instance, setup ?? Setup.Default);

    /// <summary>Creates the factory.</summary>
    public InstanceFactory(object instance) => Instance = instance;

    internal sealed class WithAllDetails : InstanceFactory
    {
        public override Setup Setup { get; }
        public override Type ImplementationType => (Instance as WeakReference)?.Target.GetType() ?? Instance?.GetType();
        public WithAllDetails(object instance, Setup setup)
            : base(instance != null && setup.WeaklyReferenced ? new WeakReference(instance) : instance) =>
            Setup = setup.WithAsResolutionCallForGeneratedExpression();
    }

    /// Simplified specially for the register instance 
    internal override bool ValidateAndNormalizeRegistration(Type serviceType, object serviceKey, bool isStaticallyChecked, Rules rules, bool throwIfInvalid)
    {
        if (isStaticallyChecked)
            return true;
        if (serviceType == null)
            return Throw.When(throwIfInvalid, Error.ServiceTypeIsNull);
        var implType = ImplementationType;
        if (implType != null && !serviceType.IsAssignableFrom(implType))
            return Throw.When(throwIfInvalid, Error.RegisteringInstanceNotAssignableToServiceType, implType, serviceType);
        return true;
    }

    /// <summary>Wraps the instance in expression constant</summary>
    public override Expression CreateExpressionOrDefault(Request request)
    {
        // unpacks the weak-reference
        if (Setup.WeaklyReferenced)
            return Call(typeof(ThrowInGeneratedCode).GetMethod(nameof(ThrowInGeneratedCode.WeakRefReuseWrapperGCed)),
                Property(ConstantOf((WeakReference)Instance), typeof(WeakReference).GetProperty(nameof(WeakReference.Target))));

        // otherwise just return a constant
        var instanceExpr = request.Container.GetConstantExpression(Instance);
        var serviceType = request.ActualServiceType;
        var implType = ImplementationType;
        return implType == null || serviceType.IsAssignableFrom(implType) ? instanceExpr : TryConvertIntrinsic(instanceExpr, serviceType);
    }

    /// <summary>Simplified path for the registered instance</summary>
    public override Expression GetExpressionOrDefault(Request request)
    {
        if (// preventing recursion
            (request.Flags & RequestFlags.IsGeneratedResolutionDependencyExpression) == 0 && !request.IsResolutionCall &&
                (AsResolutionCall || Setup.AsResolutionCallForExpressionGeneration && request.Rules.UsedForExpressionGeneration))
            return Resolver.CreateResolutionExpression(request.WithResolvedFactory(this), Setup.OpenResolutionScope, AsResolutionCall);

        // First look for decorators if it is not already a decorator
        var serviceType = request.ServiceType;
        if (serviceType.IsArray)
            serviceType = typeof(IEnumerable<>).MakeGenericType(serviceType.GetElementType());

        // todo: @perf Prevents the costly `WithResolvedFactory` call
        if (request.Container._registry.Value is Container.Registry r && !r.Decorators.IsEmpty)
        {
            // todo: @perf optimize WithResolvedFactory for registered instance
            var decoratorExpr = request.Container.GetDecoratorExpressionOrDefault(request.WithResolvedFactory(this));
            if (decoratorExpr != null)
                return decoratorExpr;
        }

        return CreateExpressionOrDefault(request);
    }

    /// <summary>Used at the resolution root to simplify getting the actual instance</summary>
    public override Func<IResolverContext, object> GetDelegateOrDefault(Request request, out object createdInstance)
    {
        createdInstance = null;
        request = request.WithResolvedFactory(this);
        if (request.Container.GetDecoratorExpressionOrDefault(request) != null)
            return base.GetDelegateOrDefault(request, out createdInstance);

        if (Setup.WeaklyReferenced)
            return Instance.WeakRefObjToFactoryDelegate;

        createdInstance = Instance;
        return null;
    }
}

/// <summary>This factory is the thin wrapper for user provided delegate
/// and where possible it uses delegate directly: without converting it to expression.</summary>
public class DelegateFactory : Factory
{
    /// <inheritdoc />
    public override bool HasRuntimeState => true;
    /// <inheritdoc />
    public override Setup Setup => DryIoc.Setup.AsResolutionCallForGeneratedExpressionSetup;
    private readonly Func<IResolverContext, object> _factoryDelegate;

    /// <summary>Creates the memory-optimized factory from the provided arguments</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static DelegateFactory Of(Func<IResolverContext, object> factoryDelegate) => new DelegateFactory(factoryDelegate);

    /// <summary>Creates the memory-optimized factory from the provided arguments</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static DelegateFactory Of(Func<IResolverContext, object> factoryDelegate, IReuse reuse) =>
        reuse == null ? new DelegateFactory(factoryDelegate)
            : reuse == DryIoc.Reuse.Singleton ? new WithSingletonReuse(factoryDelegate)
            : reuse == DryIoc.Reuse.Scoped ? new WithScopedReuse(factoryDelegate)
            : reuse == DryIoc.Reuse.Transient ? new WithTransientReuse(factoryDelegate)
            : reuse == DryIoc.Reuse.ScopedOrSingleton ? new WithScopedOrSingletonReuse(factoryDelegate)
            : new WithReuse(factoryDelegate, reuse);

    /// <summary>Creates the memory-optimized factory from the provided arguments</summary>
    public static DelegateFactory Of(Func<IResolverContext, object> factoryDelegate, Setup setup) =>
        setup == null || setup == Setup.Default
            ? new DelegateFactory(factoryDelegate)
            : new WithAllDetails(factoryDelegate, null, setup ?? Setup.Default);

    /// <summary>Creates the memory-optimized factory from the provided arguments</summary>
    public static DelegateFactory Of(Func<IResolverContext, object> factoryDelegate, IReuse reuse, Setup setup) =>
        setup == null || setup == Setup.Default
            ? Of(factoryDelegate, reuse)
            : new WithAllDetails(factoryDelegate, reuse, setup ?? Setup.Default);

    /// <summary>Creates the factory.</summary>
    public DelegateFactory(Func<IResolverContext, object> factoryDelegate) => _factoryDelegate = factoryDelegate.ThrowIfNull();

    internal sealed class WithSingletonReuse : DelegateFactory
    {
        public override IReuse Reuse => DryIoc.Reuse.Singleton;
        public WithSingletonReuse(Func<IResolverContext, object> factoryDelegate) : base(factoryDelegate) { }
    }

    internal sealed class WithScopedReuse : DelegateFactory
    {
        public override IReuse Reuse => DryIoc.Reuse.Scoped;
        public WithScopedReuse(Func<IResolverContext, object> factoryDelegate) : base(factoryDelegate) { }
    }

    internal sealed class WithTransientReuse : DelegateFactory
    {
        public override IReuse Reuse => DryIoc.Reuse.Transient;
        public WithTransientReuse(Func<IResolverContext, object> factoryDelegate) : base(factoryDelegate) { }
    }

    internal sealed class WithScopedOrSingletonReuse : DelegateFactory
    {
        public override IReuse Reuse => DryIoc.Reuse.ScopedOrSingleton;
        public WithScopedOrSingletonReuse(Func<IResolverContext, object> factoryDelegate) : base(factoryDelegate) { }
    }

    internal sealed class WithReuse : DelegateFactory
    {
        public override IReuse Reuse { get; }
        public WithReuse(Func<IResolverContext, object> factoryDelegate, IReuse reuse) : base(factoryDelegate) => Reuse = reuse;
    }

    internal sealed class WithAllDetails : DelegateFactory
    {
        public override IReuse Reuse { get; }
        public override Setup Setup { get; }
        public WithAllDetails(Func<IResolverContext, object> factoryDelegate, IReuse reuse, Setup setup) : base(factoryDelegate)
        {
            Reuse = reuse;
            Setup = setup.WithAsResolutionCallForGeneratedExpression();
        }
    }

    /// <summary>Create expression by wrapping call to stored delegate with provided request.</summary>
    public override Expression CreateExpressionOrDefault(Request request)
    {
        // GetConstant here is needed to check the runtime state rule
        var container = request.Container;
        if (container.Rules.ThrowIfRuntimeStateRequired)
            Throw.StateIsRequiredToUseItem(_factoryDelegate);

        // We are checking just for SingletonReuse here - if we injecting resolver in the singleton it should be the root container
        return request.Reuse is SingletonReuse
            ? new InvokeFactoryDelegateOfRootOrSelfExpression(request.ActualServiceType, _factoryDelegate)
            : new InvokeFactoryDelegateExpression(request.ActualServiceType, _factoryDelegate);
    }

    /// <summary>If possible returns delegate directly, without creating expression trees, just wrapped in `Func{IResolverContext, object}`/>.
    /// If decorator found for request then factory fall-backs to the expression creation.</summary>
    public override Func<IResolverContext, object> GetDelegateOrDefault(Request request, out object createdInstance)
    {
        request = request.WithResolvedFactory(this);

        // Wrap the delegate in respective expression for non-simple use
        if (request.Reuse != DryIoc.Reuse.Transient ||
            FactoryType == FactoryType.Service &&
            request.Container.GetDecoratorExpressionOrDefault(request) != null)
            return base.GetDelegateOrDefault(request, out createdInstance);

        // Otherwise just use delegate as-is
        createdInstance = null;
        return _factoryDelegate;
    }
}

internal class InvokeFactoryDelegateExpression : InvocationExpression
{
    public sealed override bool IsIntrinsic => true;

    public sealed override Type Type { get; }
    public readonly Func<IResolverContext, object> FactoryDelegate;
    public sealed override Expression Expression => ConstantOf(FactoryDelegate);
    public sealed override int ArgumentCount => 1;
    public override IReadOnlyList<Expression> Arguments => FactoryDelegateCompiler.ResolverContextParamExprs;
    public override Expression GetArgument(int index) => FactoryDelegateCompiler.ResolverContextParamExpr;
    public InvokeFactoryDelegateExpression(Type type, Func<IResolverContext, object> f)
    {
        Type = type;
        FactoryDelegate = f;
    }

    public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
         NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas)
    {
        closure.AddConstantOrIncrementUsageCount(FactoryDelegate);
        return ExpressionCompiler.TryCollectInfo(ref closure, FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, nestedLambda, ref rootNestedLambdas, flags);
    }

    public override bool TryEmit(CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs,
        ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
        EmittingVisitor.TryEmitNotNullConstant(true, FactoryDelegate, il, ref closure) &&
        EmittingVisitor.TryEmitNonByRefNonValueTypeParameter(FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, il, ref closure) &&
        EmittingVisitor.EmitMethodCall(il, FactoryDelegateCompiler.InvokeMethod) &&
        il.EmitConvertObjectTo(Type);
}

internal sealed class InvokeFactoryDelegateOfRootOrSelfExpression : InvokeFactoryDelegateExpression
{
    public override IReadOnlyList<Expression> Arguments => new[] { ResolverContext.RootOrSelfExpr };
    public override Expression GetArgument(int index) => ResolverContext.RootOrSelfExpr;
    public InvokeFactoryDelegateOfRootOrSelfExpression(Type type, Func<IResolverContext, object> f) : base(type, f) { }

    public sealed override bool TryEmit(CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs,
        ILGenerator il, ParentFlags parent, int byRefIndex = -1) =>
        EmittingVisitor.TryEmitNotNullConstant(true, FactoryDelegate, il, ref closure) &&
        ResolverContext.RootOrSelfExpr.TryEmit(config, ref closure, paramExprs, il, parent, byRefIndex) &&
        EmittingVisitor.EmitMethodCall(il, FactoryDelegateCompiler.InvokeMethod) &&
        il.EmitConvertObjectTo(Type);
}

/// <summary>The placeholder for thr later resgitration</summary>
public sealed class FactoryPlaceholder : Factory
{
    /// <summary>May be used in places where placeholder is needed</summary>
    public static readonly Factory Default = new FactoryPlaceholder();

    private static readonly Setup _setup = Setup.AsResolutionCallSetup;
    ///<summary> Always resolved asResolutionCall, to create a hole in object graph to be filled-in later by the runtime container</summary>
    public override Setup Setup => _setup;

    /// <summary>Explicit Transient reuse to avoid captive dependency error, e.g. if the Rules.Default reuse is Singleton</summary>
    public override IReuse Reuse => DryIoc.Reuse.Transient;

    /// <inheritdoc />
    public override Expression CreateExpressionOrDefault(Request request) =>
        Throw.For<Expression>(Error.NoImplementationForPlaceholder, request);
}

internal sealed class InjectedIntoFactoryDummy : Factory
{
    private static readonly Setup _setup = Setup.AsResolutionCallSetup;

    public override Setup Setup => _setup;

    /// Explicit Transient reuse to avoid captive dependency error, e.g. if the Rules.Default reuse is Singleton
    public override IReuse Reuse => DryIoc.Reuse.Transient;

    public override Type ImplementationType { get; }

    public InjectedIntoFactoryDummy(Type instanceType) => ImplementationType = instanceType;

    public override Expression CreateExpressionOrDefault(Request request) => Throw.For<Expression>(Error.InjectedIntoFactoryDummy);
}

internal sealed class ScopedItemException
{
    public readonly Exception Ex;
    public ScopedItemException(Exception ex) => Ex = ex;
    internal object ReThrow() => throw Ex.TryRethrowWithPreservedStackTrace();
}

/// <summary>Lazy object storage that will create object with provided factory on first access,
/// then will be returning the same object for subsequent access.</summary>
public interface IScope : IEnumerable<IScope>, IDisposable
{
    /// <summary>Parent scope in scope stack. Null for root scope.</summary>
    IScope Parent { get; }

    /// <summary>Optional name object associated with scope.</summary>
    object Name { get; }

    /// <summary>True if scope is disposed.</summary>
    bool IsDisposed { get; }

    /// <summary>Looks up for stored item by id.</summary>
    bool TryGet(out object item, int id);

    /// Create the value via `Func{IResolverContext, object}` passing the `IResolverContext`
    object GetOrAddViaFactoryDelegate(int id, Func<IResolverContext, object> createValue, IResolverContext r);

    /// Create the value via `Func{IResolverContext, object}` passing the `IResolverContext`
    object GetOrAddViaFactoryDelegateWithDisposalOrder(int id, Func<IResolverContext, object> createValue, IResolverContext r, int disposalOrder);

    /// Creates, stores, and returns created item
    object TryGetOrAddWithoutClosure(int id, IResolverContext resolveContext, Expression expr,
        Func<IResolverContext, Expression, object> createValue, int disposalOrder = 0);

    /// <summary>Tracked item will be disposed with the scope. Smaller <paramref name="disposalOrder"/> will be disposed first.</summary>
    T TrackDisposable<T>(T disposable, int disposalOrder = 0) where T : IDisposable;

    ///<summary>Sets or adds the service item directly to the scope services</summary>
    void SetOrAdd(int id, object item);

    /// <summary>Sets (replaces) the used instance factory for the specified type.</summary>
    void SetUsed(int hash, Type type, object instance);

    /// <summary>Try to retrieve factory or instance (wrapped in factory) via the Use method.</summary>
    bool TryGetUsed(int hash, Type type, out object instance);

    /// <summary>Replaces all used instances map with the new one. Use with caution. 
    /// It is safe to use when you've created the scope to pre-initialize it with the used instances,
    /// before returning it to the outside world</summary>
    void InitializeUsed(ImHashMap<Type, object> all);

    /// <summary>The method will clone the scope factories and already created services,
    /// but may or may not drop the disposables thus ensuring that only the new disposables added in clone will be disposed</summary>
    IScope Clone(bool withDisposables);

    /// <summary>Gets a copy of resolved objects stored in scope with their respective factory ID.
    /// Then the factory IDs may be used to find the corresponding container registrations.</summary>
    KeyValuePair<int, object>[] GetSnapshotOfServicesWithFactoryIDs();
}

/// <summary>Extension methods for scope</summary>
public static class ScopeTools
{
    [MethodImpl((MethodImplOptions)256)]
    internal static IScope AsScopeOrNull(this IDisposable scopeOrContextOrNull) =>
        scopeOrContextOrNull as IScope ?? (scopeOrContextOrNull as IScopeContext)?.GetCurrentOrDefault();

    /// <summary>The method will clone the scope factories and already created services, including the tracked disposables</summary>
    public static IScope Clone(this IScope s) => s.Clone(true);

    /// <summary>Check if the service instance or factory is set to the scope</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static bool IsUsed(this IScope s, Type serviceType) =>
        s.TryGetUsed(RuntimeHelpers.GetHashCode(serviceType), serviceType, out _);

    /// <summary>Sets (replaces) instance to the scope</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static void UseFactory(this IScope s, Type type, Func<IResolverContext, object> factory) =>
        s.SetUsed(RuntimeHelpers.GetHashCode(type), type, factory);

    /// <summary>Sets (replaces) instance to the scope</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static void UseFactory<T>(this IScope s, Func<IResolverContext, object> factory) =>
        s.UseFactory(typeof(T), factory);

    /// <summary>Sets (replaces) instance in the scope</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static void Use(this IScope s, Type type, object instance) =>
        s.SetUsed(RuntimeHelpers.GetHashCode(type), type, instance);

    /// <summary>Sets (replaces) instance in the scope</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static void Use<T>(this IScope s, object instance) =>
        s.Use(typeof(T), instance);
}

/// <summary>
/// Scope is container to hold the shared per scope items and dispose <see cref="IDisposable"/> items.
/// Scope uses Locking to ensure that the object factory called only once.
/// </summary>
public class Scope : IScope
{
    /// <summary>Parent scope in scope stack. Null for the root scope.</summary>
    public virtual IScope Parent => null; // todo: @perf make it non virtual because it is often used

    /// <summary>Optional name associated with scope.</summary>
    public virtual object Name => null;

    /// <summary>True if scope is disposed.</summary>
    public bool IsDisposed => _disposed == 1;
    internal int _disposed;

    private ImHashMap<int, ImList<IDisposable>> _disposables;
    internal ImHashMap<Type, object> _used;

    internal const int MAP_COUNT = 16;
    internal const int MAP_COUNT_SUFFIX_MASK = MAP_COUNT - 1;
    internal ImHashMap<int, object>[] _maps; // todo: @perf can we use the fixed buffers (stack array) for that in .NET 8?

    internal static readonly object NoItem = new object();
    private static ImHashMap<int, object>[] _emptyMaps = CreateEmptyMaps();
    private static ImHashMap<int, object>[] CreateEmptyMaps()
    {
        var maps = new ImHashMap<int, object>[MAP_COUNT];
        var empty = ImHashMap<int, object>.Empty;
        for (var i = 0; i < maps.Length; ++i)
            maps[i] = empty;
        return maps;
    }

    // Creates a single entry with an empty list of unordered disposables (the key 0 is reserved for the unordered disposables)
    private static ImHashMap<int, ImList<IDisposable>> CreateEmptyDisposables() => ImHashMap.Entry(0, ImList<IDisposable>.Empty);

    [MethodImpl((MethodImplOptions)256)]
    internal ImHashMap<int, object>[] CloneMaps() => _maps.CopyNonEmpty();

    ///<summary>Creating</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static IScope Of(IScope parent, object name) =>
        parent == null & name == null ? new Scope() : new WithParentAndName(parent, name);

    ///<summary>Creating scope with parent</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static IScope Of(IScope parent) =>
        parent == null ? new Scope() : new WithParentAndName(parent, null);

    ///<summary>Creating scope with parent</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static IScope OfSomeParent(IScope parent) =>
        new WithParentAndName(parent, null);

    ///<summary>Creating the root scope with name</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static IScope Of(object name) =>
        name == null ? new Scope() : new WithParentAndName(null, name);

    /// <summary>Creates scope with optional parent and name.</summary>
    public Scope() : this(_emptyMaps.CopyNonEmpty(), ImHashMap<Type, object>.Empty, CreateEmptyDisposables()) // todo: @question        ,      entry ?
    { }

    /// <summary>The basic constructor</summary>
    protected Scope(ImHashMap<int, object>[] maps, ImHashMap<Type, object> used, ImHashMap<int, ImList<IDisposable>> disposables)
    {
        _disposables = disposables;
        _used = used;
        _maps = maps;
    }

    internal sealed class WithParentAndName : Scope
    {
        public override IScope Parent { get; }
        public override object Name { get; }
        internal WithParentAndName(IScope parent, object name) : base()
        {
            Parent = parent;
            Name = name;
        }

        internal WithParentAndName(IScope parent, object name, ImHashMap<int, object>[] maps, ImHashMap<Type, object> used, ImHashMap<int, ImList<IDisposable>> disposables)
            : base(maps, used, disposables)
        {
            Parent = parent;
            Name = name;
        }

        public override IScope Clone(bool withDisposables) =>
            new WithParentAndName(Parent?.Clone(withDisposables), Name, _maps.CopyNonEmpty(), _used,
                withDisposables ? _disposables : CreateEmptyDisposables()); //     (  )
    }

    /// <inheritdoc />
    public virtual IScope Clone(bool withDisposables) =>
        new Scope(_maps.CopyNonEmpty(), _used,
            withDisposables ? _disposables : CreateEmptyDisposables()); //     (  )


    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public object GetOrAddViaFactoryDelegate(int id, Func<IResolverContext, object> createValue, IResolverContext r)
    {
        var itemRef = _maps[id & MAP_COUNT_SUFFIX_MASK].GetEntryOrDefault(id);
        return itemRef != null
            ? itemRef.Value != NoItem
                ? (itemRef.Value is ScopedItemException sex ? sex.ReThrow() : itemRef.Value)
                : WaitForItemIsSet(itemRef)
            : TryGetOrAddViaFactoryDelegate(id, createValue, r);
    }

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public object GetOrAddViaFactoryDelegateWithDisposalOrder(int id, Func<IResolverContext, object> createValue, IResolverContext r, int disposalOrder)
    {
        var itemRef = _maps[id & MAP_COUNT_SUFFIX_MASK].GetEntryOrDefault(id);
        return itemRef != null
            ? itemRef.Value != NoItem
                ? (itemRef.Value is ScopedItemException sex ? sex.ReThrow() : itemRef.Value)
                : WaitForItemIsSet(itemRef)
            : TryGetOrAddViaFactoryDelegate(id, createValue, r, disposalOrder);
    }

    internal static readonly MethodInfo GetOrAddViaFactoryDelegateMethod =
        typeof(IScope).GetMethod(nameof(IScope.GetOrAddViaFactoryDelegate));

    internal static readonly MethodInfo GetOrAddViaFactoryDelegateWithDisposalOrderMethod =
        typeof(IScope).GetMethod(nameof(IScope.GetOrAddViaFactoryDelegateWithDisposalOrder));

    internal object TryGetOrAddViaFactoryDelegate(int id, Func<IResolverContext, object> createValue, IResolverContext r, int disposalOrder = 0)
    {
        if (_disposed == 1)
            Throw.ScopeIsDisposed(this, r);

        var itemRef = ImHashMap.Entry(id, NoItem);
        ref var map = ref _maps[id & MAP_COUNT_SUFFIX_MASK];
        var oldMap = map;
        var oldRefOrNewMap = oldMap.AddOrGetEntry(id, itemRef);
        if (oldRefOrNewMap is ImHashMapEntry<int, object> oldRef && oldRef != itemRef)
            return oldRef.Value != NoItem ? oldRef.Value : WaitForItemIsSet(oldRef);
        if (Interlocked.CompareExchange(ref map, oldRefOrNewMap, oldMap) != oldMap)
        {
            oldRefOrNewMap = Ref.SwapAndGetNewValue(ref map, itemRef, (x, i) => x.AddOrKeepEntry(i));
            var otherItemRef = oldRefOrNewMap.GetSurePresent(id);
            if (otherItemRef != itemRef)
                return otherItemRef.Value != NoItem ? otherItemRef.Value : WaitForItemIsSet(otherItemRef);
        }

        object result = null;
        itemRef.Value = result = createValue(r);

        if (result is IDisposable disp && !ReferenceEquals(disp, this))
            AddDisposable(disp, disposalOrder);

        return result;
    }

    /// <summary>The amount of time to wait for the other party to create the scoped (or singleton) service.</summary>
    public static int WaitForScopedServiceIsCreatedTimeoutMilliseconds = 3_000; // 3 seconds max

    internal static object WaitForItemIsSet(ImHashMapEntry<int, object> itemRef)
    {
        var timeout = WaitForScopedServiceIsCreatedTimeoutMilliseconds;

        var startedAt = Environment.TickCount & Int32.MaxValue;
        Debug.WriteLine($"Starting: Waiting for Scoped service to be set/created for max {timeout} ms starting at {startedAt}...");

        var ellapsed = 0;
        var spinWait = new SpinWait();
        while (itemRef.Value == NoItem)
        {
            spinWait.SpinOnce();
            var currentAt = Environment.TickCount & Int32.MaxValue;
            ellapsed = currentAt - startedAt;
            if (ellapsed > timeout)
                Throw.WithDetails(itemRef.Key, Error.WaitForScopedServiceIsCreatedTimeoutExpired, ellapsed);
            else if (ellapsed < 0)
            {
                startedAt = currentAt;
                Debug.WriteLine($"Happened: Robustness for the case of possible overflow, so we are starting a new with new {startedAt}.");
            }
        }
        Debug.WriteLine($"Completed: Waiting for Scoped service to be set/created is completed in {ellapsed}.");
        return itemRef.Value;
    }

    /// <inheritdoc />
    public object TryGetOrAddWithoutClosure(int id, IResolverContext resolverContext,
        Expression expr, Func<IResolverContext, Expression, object> createValue, int disposalOrder = 0)
    {
        if (_disposed == 1)
            Throw.ScopeIsDisposed(this, resolverContext);

        var itemRef = ImHashMap.Entry(id, NoItem);
        ref var map = ref _maps[id & MAP_COUNT_SUFFIX_MASK];
        var oldMap = map;
        var newMap = oldMap.AddOrKeepEntry(itemRef);
        if (Interlocked.CompareExchange(ref map, newMap, oldMap) != oldMap)
        {
            newMap = Ref.SwapAndGetNewValue(ref map, itemRef, static (x, i) => x.AddOrKeepEntry(i));
            var otherItemRef = newMap.GetSurePresent(id);
            if (otherItemRef != itemRef)
                return otherItemRef.Value != NoItem ? otherItemRef.Value : WaitForItemIsSet(otherItemRef);
        }
        else if (newMap == oldMap)
        {
            var otherItemRef = newMap.GetSurePresent(id);
            return otherItemRef.Value != NoItem ? otherItemRef.Value : WaitForItemIsSet(otherItemRef);
        }

        object result = null;
        itemRef.Value = result = createValue(resolverContext, expr);

        if (result is IDisposable disp && !ReferenceEquals(disp, this))
            AddDisposable(disp, disposalOrder);

        return result;
    }

    ///<inheritdoc />
    public void SetOrAdd(int id, object item)
    {
        if (_disposed == 1)
            Throw.ScopeIsDisposed(this, null);

        var itemRef = ImHashMap.Entry(id, item);
        ref var map = ref _maps[id & MAP_COUNT_SUFFIX_MASK];
        var oldMap = map;
        var newMap = oldMap.AddOrUpdateEntry(itemRef);
        if (Interlocked.CompareExchange(ref map, newMap, oldMap) != oldMap)
            Ref.Swap(ref map, itemRef, static (x, i) => x.AddOrUpdateEntry(i));

        if (item is IDisposable disp && !ReferenceEquals(disp, this))
            AddUnorderedDisposable(disp);
    }

    internal void AddDisposable(IDisposable disposable, int disposalOrder = 0)
    {
        if (disposalOrder == 0)
            AddUnorderedDisposable(disposable);
        else
        {
            var e = _disposables.GetEntryOrDefault(disposalOrder) ?? AddDisposableEntry(disposalOrder);
            var items = e.Value;
            if (Interlocked.CompareExchange(ref e.Value, items.Push(disposable), items) != items)
                Ref.Swap(ref e.Value, disposable, static (x, d) => x.Push(d));
        }
    }

    [MethodImpl((MethodImplOptions)256)]
    internal void AddUnorderedDisposable(IDisposable disposable)
    {
        var e = _disposables.GetEntryOrDefault(0);
        var items = e.Value;
        if (Interlocked.CompareExchange(ref e.Value, items.Push(disposable), items) != items)
            Ref.Swap(ref e.Value, disposable, static (x, d) => x.Push(d));
    }

    private ImHashMapEntry<int, ImList<IDisposable>> AddDisposableEntry(int disposableOrder)
    {
        Ref.Swap(ref _disposables, disposableOrder, static (x, o) => x.AddOrKeep(o, ImList<IDisposable>.Empty));
        return _disposables.GetSurePresent(disposableOrder);
    }

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool TryGet(out object item, int id)
    {
        var itemRef = _maps[id & MAP_COUNT_SUFFIX_MASK].GetEntryOrDefault(id);
        if (itemRef != null && itemRef.Value != NoItem)
        {
            item = itemRef.Value;
            return true;
        }

        item = null;
        return false;
    }

    /// <summary>Can be used to manually add service for disposal</summary>
    public T TrackDisposable<T>(T item, int disposalOrder = 0) where T : IDisposable
    {
        if (!ReferenceEquals(item, this))
            AddDisposable(item, disposalOrder);
        return item;
    }

    // todo: @wip use TrackScoped as in Scope Apply instead of TrackDisposable
    internal static readonly MethodInfo TrackDisposableOpenGenericMethod = typeof(IScope).GetMethod(nameof(IScope.TrackDisposable));

    /// <inheritdoc />
    public void SetUsed(int hash, Type type, object instance)
    {
        if (_disposed == 1)
            Throw.It(Error.ScopeIsDisposed, ToString());
        var u = _used;
        if (Interlocked.CompareExchange(ref _used, u.AddOrUpdateByReferenceEquals(hash, type, instance), u) != u)
            Ref.Swap(ref _used, hash, type, instance, static (x, h, t, i) => x.AddOrUpdateByReferenceEquals(h, t, i));
    }

    /// <summary>Try retrieve the used instance from the scope.</summary>
    public bool TryGetUsed(int hash, Type type, out object used) // todo: @perf maybe pass the SingletonScope as Parent here?
    {
        if (_disposed != 1)
        {
            if (!_used.IsEmpty)
            {
                var e = _used.GetEntryOrDefaultByReferenceEquals(hash, type);
                if (e != null)
                {
                    used = e.Value;
                    return true;
                }
            }
            var p = Parent;
            if (p != null)
                return p.TryGetUsed(hash, type, out used);
        }
        used = default;
        return false;
    }

    /// <inheritdoc />
    public void InitializeUsed(ImHashMap<Type, object> all) => _used = all;

    /// <summary>Enumerates all the parent scopes upwards starting from this one.</summary>
    public IEnumerator<IScope> GetEnumerator()
    {
        for (IScope scope = this; scope != null; scope = scope.Parent)
            yield return scope;
    }

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>Disposes all stored <see cref="IDisposable"/> objects and empties item storage.
    /// The disposal happens in REVERSE resolution / injection order, consumer first, dependency next.
    /// It will allow consumer to do something with its dependency before it is disposed.</summary>
    /// <remarks>All disposal exceptions are swallowed except the ContainerException,
    /// which may indicate container misconfiguration.</remarks>
    public void Dispose()
    {
        if (Interlocked.CompareExchange(ref _disposed, 1, 0) == 1)
            return;

        var ds = _disposables;
        if (ds is ImHashMapEntry<int, ImList<IDisposable>> e)
            for (var d = e.Value; d.Tail != null; d = d.Tail)
                d.Head.Dispose();
        else if (!ds.IsEmpty)
            SafelyDisposeOrderedDisposables(ds);

        _disposables = ImHashMap<int, ImList<IDisposable>>.Empty; // todo: @perf @mem combine used and _factories together
        _used = ImHashMap<Type, object>.Empty;
        _maps = _emptyMaps;
    }

    private static void SafelyDisposeOrderedDisposables(ImHashMap<int, ImList<IDisposable>> disposables)
    {
        disposables.ForEach(static (e, _) =>
        {
            try
            {
                for (var d = e.Value; !d.IsEmpty; d = d.Tail)
                    d.Head.Dispose();
            }
            catch (ContainerException)
            {
                throw;
            }
            catch (Exception)
            {
                // Ignoring disposing exception, as it is not important to proceed the disposal of other items
            }
        });
    }

    /// <summary>Prints scope info (name and parent) to string for debug purposes.</summary>
    public override string ToString() =>
        "{" + (IsDisposed ? "IsDisposed=true, " : "")
            + (Name != null ? "Name=" + Name : "Name=null")
            + (Parent != null ? ", Parent=" + Parent : "")
            + "}";

    /// <inheritdoc/>
    public KeyValuePair<int, object>[] GetSnapshotOfServicesWithFactoryIDs()
    {
        var maps = _maps.CopyNonEmpty();
        var items = maps.ForEach(new List<KeyValuePair<int, object>>(),
            static (entry, _, it) =>
            {
                if (entry.Value != NoItem)
                    it.Add(entry.Key.Pair(entry.Value));
            });
        return items.ToArray();
    }
}

/// <summary>Delegate to get new scope from old/existing current scope.</summary>
/// <param name="oldScope">Old/existing scope to change.</param>
/// <returns>New scope or old if do not want to change current scope.</returns>
public delegate IScope SetCurrentScopeHandler(IScope oldScope);

/// <summary>Provides ambient current scope and optionally scope storage for container,
/// examples are HttpContext storage, Execution context, Thread local.</summary>
public interface IScopeContext : IDisposable
{
    /// <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
    /// <returns>Current scope or null.</returns>
    IScope GetCurrentOrDefault();

    /// <summary>Changes current scope using provided delegate. Delegate receives current scope as input and
    /// should return new current scope.</summary>
    /// <param name="setCurrentScope">Delegate to change the scope.</param>
    /// <remarks>Important: <paramref name="setCurrentScope"/> may be called multiple times in concurrent environment.
    /// Make it predictable by removing any side effects.</remarks>
    /// <returns>New current scope. So it is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
    IScope SetCurrent(SetCurrentScopeHandler setCurrentScope);
}

/// <summary>Tracks one current scope per thread, so the current scope in different tread would be different or null,
/// if not yet tracked. Context actually stores scope references internally, so it should be disposed to free them.</summary>
public sealed class ThreadScopeContext : IScopeContext
{
    /// <summary>Provides static name for context. It is OK because its constant.</summary>
    public static readonly string ScopeContextName = "ThreadScopeContext";

    private ThreadLocal<IScope> _scope = new ThreadLocal<IScope>(true);

    /// <summary>Returns current scope in calling Thread or null, if no scope tracked.</summary>
    public IScope GetCurrentOrDefault() =>
        _scope.Value;

    /// <summary>Change current scope for the calling Thread.</summary>
    public IScope SetCurrent(SetCurrentScopeHandler setCurrentScope) =>
        _scope.Value = setCurrentScope(_scope.Value);

    /// <summary>Disposes the scopes and empties internal scope storage.</summary>
    public void Dispose()
    {
        var scopes = _scope.Values;
        foreach (var scope in scopes)
        {
            var s = scope;
            while (s != null)
            {
                var x = s;
                s = s.Parent;
                x.Dispose();
            }
        }
    }

}

/// <summary>Simplified scope agnostic reuse abstraction. More easy to implement,
///  and more powerful as can be based on other storage beside reuse.</summary>
public interface IReuse : IConvertibleToExpression
{
    /// <summary>Relative to other reuses lifespan value.</summary>
    int Lifespan { get; }

    /// <summary>Optional name. Use to find matching scope by the name.
    /// It also may be interpreted as object[] Names for matching with multiple scopes </summary>
    object Name { get; }

    /// <summary>Returns true if reuse can be applied: may check if scope or other reused item storage is present.</summary>
    bool CanApply(Request request);

    /// <summary>Returns composed expression.</summary>
    Expression Apply(Request request, Expression serviceFactoryExpr);
}

/// <summary>Returns container bound scope for storing singleton objects.</summary>
public sealed class SingletonReuse : IReuse
{
    /// <summary>Big lifespan.</summary>
    public const int DefaultLifespan = 1000;

    /// <summary>Relative to other reuses lifespan value.</summary>
    public int Lifespan => DefaultLifespan;

    /// <inheritdoc />
    public object Name => null;

    /// <summary>Returns true because singleton is always available.</summary>
    public bool CanApply(Request request) => true;

    /// <summary>Returns expression call to GetOrAddItem.</summary>
    public Expression Apply(Request request, Expression serviceFactoryExpr)
    {
        // todo: @wip use this line again after replacing TrackDisposableOpenGenericMethod with TrackScoped
        //serviceFactoryExpr = serviceFactoryExpr.NormalizeExpression();

        // strip the conversion as we are operating with object anyway
        if (serviceFactoryExpr.NodeType == ExprType.Convert)
            serviceFactoryExpr = ((UnaryExpression)serviceFactoryExpr).Operand;

        var disposalOrder = request.Factory.Setup.DisposalOrder;
        var serviceExprType = serviceFactoryExpr.Type;

        if (request.TracksTransientDisposable)
            return Call(ResolverContext.SingletonScopeExpr,
                Scope.TrackDisposableOpenGenericMethod.MakeGenericMethod(serviceExprType), // todo: @simplify @perf convert trackdisposable to accepting and returning object
                serviceFactoryExpr, ConstantInt(disposalOrder));

        // this is required because we cannot use ValueType for the object
        if (serviceExprType.IsValueType)
            serviceFactoryExpr = Convert<object>(serviceFactoryExpr);

        if (request.DependencyCount > 0)
            request.DecreaseTrackedDependencyCountForParents();

        var factoryId = request.GetCombinedDecoratorAndFactoryID();
        var lambdaExpr = new FactoryDelegateExpression(serviceFactoryExpr);
        if (disposalOrder == 0)
            return Call(ResolverContext.SingletonScopeExpr, Scope.GetOrAddViaFactoryDelegateMethod,
                ConstantInt(factoryId), lambdaExpr, FactoryDelegateCompiler.ResolverContextParamExpr);

        return Call(ResolverContext.SingletonScopeExpr, Scope.GetOrAddViaFactoryDelegateWithDisposalOrderMethod,
            ConstantInt(factoryId), lambdaExpr, FactoryDelegateCompiler.ResolverContextParamExpr, ConstantInt(disposalOrder));
    }

    private static readonly Lazy<Expression> _singletonReuseExpr = Lazy.Of<Expression>(() =>
        Field(typeof(Reuse).GetField(nameof(Reuse.Singleton))));

    /// <inheritdoc />
    public Expression ToExpression<S>(S state, Func<S, object, Expression> fallbackConverter) => _singletonReuseExpr.Value;

    /// <summary>Pretty prints reuse name and lifespan</summary>
    public override string ToString() => "Singleton {Lifespan=" + Lifespan + "}";
}

/// <summary>Specifies that instances are created, stored and disposed together with some scope.</summary>
public sealed class CurrentScopeReuse : IReuse
{
    /// <summary>Less than Singleton's</summary>
    public const int DefaultLifespan = 100;

    /// <summary>Relative to other reuses lifespan value.</summary>
    public int Lifespan { get; }

    /// <inheritdoc />
    public object Name { get; }

    /// <summary>Returns true if scope is open and the name is matching with reuse <see cref="Name"/>.</summary>
    public bool CanApply(Request request) =>
        ScopedOrSingleton || request.Container.GetNamedScope(Name, false) != null;

    /// <summary>Creates scoped item creation and access expression.</summary>
    public Expression Apply(Request request, Expression serviceFactoryExpr)
    {
        serviceFactoryExpr = serviceFactoryExpr.NormalizeExpression();

        if (request.TracksTransientDisposable)
        {
            if (ScopedOrSingleton)
                return Call(TrackScopedOrSingletonMethod, FactoryDelegateCompiler.ResolverContextParamExpr, serviceFactoryExpr);

            var ifNoScopeThrowExpr = Constant(request.IfUnresolved == IfUnresolved.Throw);
            if (Name == null)
                return Call(TrackScopedMethod, FactoryDelegateCompiler.ResolverContextParamExpr, ifNoScopeThrowExpr, serviceFactoryExpr);

            var nameExpr = request.Container.GetConstantExpression(Name, typeof(object));
            return Call(TrackNameScopedMethod, FactoryDelegateCompiler.ResolverContextParamExpr, nameExpr, ifNoScopeThrowExpr, serviceFactoryExpr);
        }
        else
        {
            // decrease the dependency count when wrapping into lambda
            if (serviceFactoryExpr is InvokeFactoryDelegateExpression == false && request.DependencyCount > 0)
                request.DecreaseTrackedDependencyCountForParents();

            var disposalOrder = request.Factory.Setup.DisposalOrder;
            var factoryId = request.GetCombinedDecoratorAndFactoryID();
            if (ScopedOrSingleton)
                return disposalOrder == 0
                    ? new GetScopedOrSingletonViaFactoryDelegateExpression(factoryId, serviceFactoryExpr)
                    : new GetScopedOrSingletonViaFactoryDelegateWithDisposalOrderExpression(factoryId, serviceFactoryExpr, disposalOrder);

            var ifNoScopeThrow = request.IfUnresolved == IfUnresolved.Throw;

            if (Name == null)
                return disposalOrder == 0
                    ? (ifNoScopeThrow ?
                        new ThrowIfNoScopeGetScopedViaFactoryDelegateExpression(factoryId, serviceFactoryExpr) :
                        new CurrentScopeGetScopedViaFactoryDelegateExpression(factoryId, serviceFactoryExpr))
                    : (ifNoScopeThrow ?
                        new ThrowIfNoScopeGetScopedViaFactoryDelegateWithDisposalOrderExpression(factoryId, serviceFactoryExpr, disposalOrder) :
                        new CurrentScopeGetScopedViaFactoryDelegateWithDisposalOrderExpression(factoryId, serviceFactoryExpr, disposalOrder));

            // todo: @perf optimize the same way as for scope without Name
            serviceFactoryExpr = serviceFactoryExpr is InvokeFactoryDelegateExpression i ? i.Expression : new FactoryDelegateExpression(serviceFactoryExpr);
            return Call(GetNameScopedViaFactoryDelegateMethod, FactoryDelegateCompiler.ResolverContextParamExpr,
                request.Container.GetConstantExpression(Name, typeof(object)),
                Constant(ifNoScopeThrow), ConstantInt(factoryId), serviceFactoryExpr, ConstantInt(disposalOrder));
        }
    }

    /// <inheritdoc />
    public Expression ToExpression<S>(S state, Func<S, object, Expression> fallbackConverter) =>
        Name == null && !ScopedOrSingleton
            ? Field(null, typeof(Reuse).GetField(nameof(Reuse.Scoped)))
            : ScopedOrSingleton
                ? Field(null, typeof(Reuse).GetField(nameof(Reuse.ScopedOrSingleton)))
                : Call(typeof(Reuse).Method(nameof(Reuse.ScopedTo), typeof(object)), fallbackConverter(state, Name));

    /// <summary>Pretty prints reuse to string.</summary> <returns>Reuse string.</returns>
    public override string ToString()
    {
        var s = new StringBuilder(ScopedOrSingleton ? "ScopedOrSingleton" : "Scoped");
        if (Name == null && Lifespan == DefaultLifespan)
            return s.ToString();
        s.Append("{");
        var addComma = false;
        if (Name != null)
        {
            s.Append("Name=").Print(Name);
            addComma = true;
        }
        if (Lifespan != DefaultLifespan)
        {
            if (addComma) s.Append(", ");
            s.Append("Lifespan=").Append(Lifespan);
        }
        return s.Append("}").ToString();
    }

    /// <summary>Creates the reuse.</summary>
    public CurrentScopeReuse(object name, bool scopedOrSingleton, int lifespan)
    {
        Name = name;
        ScopedOrSingleton = scopedOrSingleton;
        Lifespan = lifespan;
    }

    /// <summary>Creates the reuse optionally specifying its name.</summary>
    public CurrentScopeReuse(object name = null, bool scopedOrSingleton = false)
        : this(name, scopedOrSingleton, DefaultLifespan) { }

    /// <summary>Flag indicating that it is a scope or singleton.</summary>
    public readonly bool ScopedOrSingleton;

    /// Subject
    public static object GetScopedOrSingletonViaFactoryDelegateWithDisposalOrder(IResolverContext r, int id, Func<IResolverContext, object> createValue,
        int disposalOrder = 0) => disposalOrder == 0
            ? r.CurrentOrSingletonScope.GetOrAddViaFactoryDelegate(id, createValue, r)
            : r.CurrentOrSingletonScope.GetOrAddViaFactoryDelegateWithDisposalOrder(id, createValue, r, disposalOrder);

    internal class GetScopedOrSingletonViaFactoryDelegateExpression : MethodCallExpression
    {
        public override bool IsIntrinsic => true;

        public override Type Type => ServiceOrInvokeExpr.Type;
        public override Expression Object => ResolverContext.CurrentOrSingletonScopeExpr;
        public override MethodInfo Method => Scope.GetOrAddViaFactoryDelegateMethod;
        public readonly int FactoryID;
        public ConstantExpression FactoryIdExpr => ConstantInt(FactoryID);
        public readonly Expression ServiceOrInvokeExpr;
        public Expression FactoryDelegateExpr =>
            ServiceOrInvokeExpr is InvokeFactoryDelegateExpression i ? i.Expression : new FactoryDelegateExpression(ServiceOrInvokeExpr);
        public override int ArgumentCount => 3;
        public override IReadOnlyList<Expression> Arguments =>
            new[] { FactoryIdExpr, FactoryDelegateExpr, FactoryDelegateCompiler.ResolverContextParamExpr };
        public override Expression GetArgument(int i) =>
            i == 0 ? FactoryIdExpr : i == 1 ? FactoryDelegateExpr : FactoryDelegateCompiler.ResolverContextParamExpr;
        internal GetScopedOrSingletonViaFactoryDelegateExpression(int factoryId, Expression serviceOrInvokeExpr)
        {
            FactoryID = factoryId;
            ServiceOrInvokeExpr = serviceOrInvokeExpr;
        }

        public override Result TryCollectInfo(CompilerFlags flags, ref ClosureInfo closure, IParameterProvider paramExprs,
            NestedLambdaInfo nestedLambda, ref SmallList<NestedLambdaInfo> rootNestedLambdas)
        {
            var r = Result.OK;
            return (r = ExpressionCompiler.TryCollectInfo(ref closure, FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, nestedLambda, ref rootNestedLambdas, flags)) != Result.OK ? r
                : ExpressionCompiler.TryCollectInfo(ref closure, FactoryDelegateExpr, paramExprs, nestedLambda, ref rootNestedLambdas, flags);
        }

        // Emitting the arguments for GetOrAddViaFactoryDelegateMethod(int id, Func<IResolverContext, object> createValue, IResolverContext r)
        public override bool TryEmit(CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs,
            ILGenerator il, ParentFlags parent, int byRefIndex = -1)
        {
            EmittingVisitor.TryEmit(Object, paramExprs, il, ref closure, config, parent);
            EmittingVisitor.EmitLoadConstantInt(il, FactoryID);

            if (!EmittingVisitor.TryEmit(FactoryDelegateExpr, paramExprs, il, ref closure, config, parent))
                return false;

            EmittingVisitor.TryEmitNonByRefNonValueTypeParameter(FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, il, ref closure);

            EmittingVisitor.EmitVirtualMethodCall(il, Scope.GetOrAddViaFactoryDelegateMethod);
            il.EmitConvertObjectTo(Type);

            return true;
        }
    }

    internal class GetScopedOrSingletonViaFactoryDelegateWithDisposalOrderExpression : GetScopedOrSingletonViaFactoryDelegateExpression
    {
        public override bool IsIntrinsic => true;

        public override MethodInfo Method => Scope.GetOrAddViaFactoryDelegateWithDisposalOrderMethod;
        public readonly int DisposalOrder;
        public ConstantExpression DisposalOrderExpr => ConstantInt(DisposalOrder);
        public override int ArgumentCount => 4;
        public override IReadOnlyList<Expression> Arguments =>
            new[] { FactoryIdExpr, FactoryDelegateExpr, FactoryDelegateCompiler.ResolverContextParamExpr, DisposalOrderExpr };
        public override Expression GetArgument(int i) =>
            i == 0 ? FactoryIdExpr : i == 1 ? FactoryDelegateExpr : i == 2 ? FactoryDelegateCompiler.ResolverContextParamExpr : DisposalOrderExpr;
        internal GetScopedOrSingletonViaFactoryDelegateWithDisposalOrderExpression(
            int factoryId, Expression createValueExpr, int disposalOrder) : base(factoryId, createValueExpr) => DisposalOrder = disposalOrder;

        // Emitting the arguments for GetOrAddViaFactoryDelegateWithDisposalOrderMethod(int id, Func<IResolverContext, object> createValue, IResolverContext r, int disposalOrder = 0)
        public override bool TryEmit(CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs,
            ILGenerator il, ParentFlags parent, int byRefIndex = -1)
        {
            EmittingVisitor.TryEmit(Object, paramExprs, il, ref closure, config, parent);
            EmittingVisitor.EmitLoadConstantInt(il, FactoryID);

            if (!EmittingVisitor.TryEmit(FactoryDelegateExpr, paramExprs, il, ref closure, config, parent))
                return false;

            EmittingVisitor.TryEmitNonByRefNonValueTypeParameter(FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, il, ref closure);

            EmittingVisitor.EmitLoadConstantInt(il, DisposalOrder);

            EmittingVisitor.EmitVirtualMethodCall(il, Scope.GetOrAddViaFactoryDelegateWithDisposalOrderMethod);
            il.EmitConvertObjectTo(Type);
            return true;
        }
    }

    internal sealed class ThrowIfNoScopeGetScopedViaFactoryDelegateExpression : GetScopedOrSingletonViaFactoryDelegateExpression
    {
        public override Expression Object => ResolverContext.GetCurrentScopeOrThrowExpr;
        internal ThrowIfNoScopeGetScopedViaFactoryDelegateExpression(int factoryId, Expression createValueExpr) : base(factoryId, createValueExpr) { }
    }

    internal sealed class CurrentScopeGetScopedViaFactoryDelegateExpression : GetScopedOrSingletonViaFactoryDelegateExpression
    {
        public override Expression Object => ResolverContext.CurrentScopeExpr;
        internal CurrentScopeGetScopedViaFactoryDelegateExpression(int factoryId, Expression createValueExpr) : base(factoryId, createValueExpr) { }

        // Emitting the arguments for GetOrAddViaFactoryDelegateMethod(int id, Func<IResolverContext, object> createValue, IResolverContext r)
        public override bool TryEmit(CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs,
            ILGenerator il, ParentFlags parent, int byRefIndex = -1)
        {
            EmittingVisitor.TryEmit(Object, paramExprs, il, ref closure, config, parent);

            // The same way as in `InterpretGetScopedOrSingletonViaFactoryDelegate` check for null and immediatly return null as a result
            // to avoid NRE when scope is absent and we specifically said to avoid throwing an exception.
            Label nullScope = il.DefineLabel();
            var scopeVar = EmittingVisitor.EmitStoreAndLoadLocalVariable(il, typeof(IScope));
            il.Demit(OpCodes.Brfalse, nullScope);
            EmittingVisitor.EmitLoadLocalVariable(il, scopeVar);

            EmittingVisitor.EmitLoadConstantInt(il, FactoryID);

            if (!EmittingVisitor.TryEmit(FactoryDelegateExpr, paramExprs, il, ref closure, config, parent))
                return false;

            EmittingVisitor.TryEmitNonByRefNonValueTypeParameter(FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, il, ref closure);

            EmittingVisitor.EmitVirtualMethodCall(il, Scope.GetOrAddViaFactoryDelegateMethod);

            il.EmitConvertObjectTo(Type);

            var result = il.DefineLabel();
            il.Demit(OpCodes.Br, result);
            il.DmarkLabel(nullScope);
            il.Demit(OpCodes.Ldnull);
            il.DmarkLabel(result);
            return true;
        }
    }

    internal sealed class ThrowIfNoScopeGetScopedViaFactoryDelegateWithDisposalOrderExpression : GetScopedOrSingletonViaFactoryDelegateWithDisposalOrderExpression
    {
        public override Expression Object => ResolverContext.GetCurrentScopeOrThrowExpr;
        internal ThrowIfNoScopeGetScopedViaFactoryDelegateWithDisposalOrderExpression(
            int factoryId, Expression serviceFactoryExpr, int disposalOrder) : base(factoryId, serviceFactoryExpr, disposalOrder) { }
    }

    internal sealed class CurrentScopeGetScopedViaFactoryDelegateWithDisposalOrderExpression : GetScopedOrSingletonViaFactoryDelegateWithDisposalOrderExpression
    {
        public override Expression Object => ResolverContext.CurrentScopeExpr;
        internal CurrentScopeGetScopedViaFactoryDelegateWithDisposalOrderExpression(
            int factoryId, Expression serviceFactoryExpr, int disposalOrder) : base(factoryId, serviceFactoryExpr, disposalOrder) { }

        // Emitting the arguments for GetOrAddViaFactoryDelegateWithDisposalOrderMethod(int id, Func<IResolverContext, object> createValue, IResolverContext r, int disposalOrder = 0)
        public override bool TryEmit(CompilerFlags config, ref ClosureInfo closure, IParameterProvider paramExprs,
            ILGenerator il, ParentFlags parent, int byRefIndex = -1)
        {
            EmittingVisitor.TryEmit(Object, paramExprs, il, ref closure, config, parent);

            // The same way as in `InterpretGetScopedOrSingletonViaFactoryDelegate` check for null and immediatly return null as a result
            // to avoid NRE when scope is absent and we specifically said to avoid throwing an exception.
            Label nullScope = il.DefineLabel();
            var scopeVar = EmittingVisitor.EmitStoreAndLoadLocalVariable(il, typeof(IScope));
            il.Demit(OpCodes.Brfalse, nullScope);
            EmittingVisitor.EmitLoadLocalVariable(il, scopeVar);

            EmittingVisitor.EmitLoadConstantInt(il, FactoryID);

            if (!EmittingVisitor.TryEmit(FactoryDelegateExpr, paramExprs, il, ref closure, config, parent))
                return false;

            EmittingVisitor.TryEmitNonByRefNonValueTypeParameter(FactoryDelegateCompiler.ResolverContextParamExpr, paramExprs, il, ref closure);

            EmittingVisitor.EmitLoadConstantInt(il, DisposalOrder);

            EmittingVisitor.EmitVirtualMethodCall(il, Scope.GetOrAddViaFactoryDelegateWithDisposalOrderMethod);
            il.EmitConvertObjectTo(Type);

            var result = il.DefineLabel();
            il.Demit(OpCodes.Br, result);
            il.DmarkLabel(nullScope);
            il.Demit(OpCodes.Ldnull);
            il.DmarkLabel(result);
            return true;
        }
    }

    /// Subject
    public static object GetNameScopedViaFactoryDelegate(IResolverContext r,
        object scopeName, bool throwIfNoScope, int id, Func<IResolverContext, object> createValue, int disposalOrder) =>
        r.GetNamedScope(scopeName, throwIfNoScope)?.GetOrAddViaFactoryDelegateWithDisposalOrder(id, createValue, r, disposalOrder);

    internal static readonly MethodInfo GetNameScopedViaFactoryDelegateMethod =
        typeof(CurrentScopeReuse).GetMethod(nameof(GetNameScopedViaFactoryDelegate));

    /// <summary>Tracks the Unordered disposal in the current scope or in the singleton as fallback</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static object TrackScopedOrSingleton(IResolverContext r, object item) =>
        item is IDisposable d ? r.CurrentOrSingletonScope.TrackDisposable(d) : item;

    internal static readonly MethodInfo TrackScopedOrSingletonMethod =
        typeof(CurrentScopeReuse).GetMethod(nameof(TrackScopedOrSingleton));

    /// Subject
    public static object TrackScoped(IResolverContext r, bool throwIfNoScope, object item) =>
        item is IDisposable d ? r.GetCurrentScope(throwIfNoScope)?.TrackDisposable(d) : item;

    internal static readonly MethodInfo TrackScopedMethod =
        typeof(CurrentScopeReuse).GetMethod(nameof(TrackScoped));

    /// Subject
    public static object TrackNameScoped(IResolverContext r, object scopeName, bool throwIfNoScope, object item) =>
        item is IDisposable d ? r.GetNamedScope(scopeName, throwIfNoScope)?.TrackDisposable(d) : item;

    internal static readonly MethodInfo TrackNameScopedMethod =
        typeof(CurrentScopeReuse).GetMethod(nameof(TrackNameScoped));
}

/// <summary>Abstracts way to match reuse and scope names</summary>
public interface IScopeName
{
    /// <summary>Does the job.</summary>
    bool Match(object scopeName);
}

/// <summary>Custom name matcher via the provided function. 
/// It may be used as a negative check, e.g. to avoid cirtain scopes and proceed to search for the specific parent scope.</summary>
public sealed class ScopeName : IScopeName
{
    /// <summary>Constucts the scope name matches based on the user-provided predicate</summary>
    public static ScopeName Of(Func<object, bool> matchPredicate) => new ScopeName(matchPredicate);

    /// <summary>The match precicate</summary>
    public readonly Func<object, bool> MatchPredicate;
    private ScopeName(Func<object, bool> matchPredicate) => MatchPredicate = matchPredicate;

    /// <inheritdoc />
    public bool Match(object scopeName) => MatchPredicate(scopeName);
}

/// <summary>Represents multiple names</summary>
public sealed class CompositeScopeName : IScopeName
{
    /// <summary>Wraps multiple names</summary>
    public static CompositeScopeName Of(object[] names) => new CompositeScopeName(names);

    /// <summary>Matches all the name in a loop until first match is found, otherwise returns false.</summary>
    public bool Match(object scopeName)
    {
        var names = _names;
        for (var i = 0; i < names.Length; i++)
        {
            var name = names[i];
            if (name == scopeName)
                return true;
            var aScopeName = name as IScopeName;
            if (aScopeName != null && aScopeName.Match(scopeName))
                return true;
            if (scopeName != null && scopeName.Equals(name))
                return true;
        }

        return false;
    }

    private CompositeScopeName(object[] names) { _names = names; }
    private readonly object[] _names;
}

/// <summary>Holds the name for the resolution scope.</summary>
public sealed class ResolutionScopeName : IScopeName
{
    /// <summary>Creates scope with specified service type and key</summary>
    public static ResolutionScopeName Of(Type serviceType = null, object serviceKey = null) =>
        new ResolutionScopeName(serviceType, serviceKey);

    /// <summary>Creates scope with specified service type and key.</summary>
    public static ResolutionScopeName Of<TService>(object serviceKey = null) =>
        new ResolutionScopeName(typeof(TService), serviceKey);

    /// <summary>Type of service opening the scope.</summary>
    public readonly Type ServiceType;

    /// <summary>Optional service key of service opening the scope.</summary>
    public readonly object ServiceKey;

    private ResolutionScopeName(Type serviceType, object serviceKey)
    {
        ServiceType = serviceType;
        ServiceKey = serviceKey;
    }

    /// <inheritdoc />
    public bool Match(object scopeName)
    {
        var name = scopeName as ResolutionScopeName;
        return name != null &&
                (ServiceType == null ||
                name.ServiceType.IsAssignableTo(ServiceType) ||
                ServiceType.IsOpenGeneric() &&
                name.ServiceType.GetGenericDefinitionOrNull().IsAssignableTo(ServiceType)) &&
                (ServiceKey == null || ServiceKey.Equals(name.ServiceKey));
    }

    /// <summary>String representation for easy debugging and understood error messages.</summary>
    public override string ToString()
    {
        var s = new StringBuilder().Append("{ServiceType=").Print(ServiceType);
        if (ServiceKey != null)
            s.Append(", ServiceKey=").Print(ServiceKey);
        return s.Append('}').ToString();
    }
}

/// <summary>Specifies pre-defined reuse behaviors supported by container:
/// used when registering services into container with <see cref="Registrator"/> methods.</summary>
public static class Reuse
{
    /// <summary>Synonym for absence of reuse.</summary>
    public static readonly IReuse Transient = new TransientReuse();

    /// <summary>Specifies to store single service instance per <see cref="Container"/>.</summary>
    public static readonly IReuse Singleton = new SingletonReuse();

    /// <summary>Scoped to the any scope - either with or without the name.</summary>
    public static readonly IReuse Scoped = new CurrentScopeReuse();

    /// <summary>Scoped to the scope with the specified name only. 
    /// The `name` may be null, so the service will be scoped to any scope.</summary>
    public static IReuse ScopedTo(object name) => new CurrentScopeReuse(name);

    /// <summary>Scoped to the scope with the specified name only. 
    /// The `name` may be null, so the service will be scoped to any scope. Specifies all the scope details</summary>
    public static IReuse ScopedTo(object name, bool scopedOrSingleton, int lifespan) =>
        new CurrentScopeReuse(name, scopedOrSingleton, lifespan);

    /// <summary>Scoped to the closest scope (in scope parent hierarchy) with the name from the specified names list. 
    /// The `names` should no contain the `null`</summary>
    public static IReuse ScopedTo(params object[] names) =>
        names.IsNullOrEmpty() ? Scoped : names.Length == 1 ? ScopedTo(names[0]) : new CurrentScopeReuse(CompositeScopeName.Of(names));

    /// <summary>Scoped to the scope created by the service with the specified type and optional key</summary>
    public static IReuse ScopedToService(Type serviceType = null, object serviceKey = null) =>
        serviceType == null && serviceKey == null ? Scoped
        : new CurrentScopeReuse(ResolutionScopeName.Of(serviceType, serviceKey));

    /// <summary>Scoped to the scope created by the service with the specified `TService` type and `serviceKey`,
    /// The service should specify the creation of the scope in the registration call via `setup: Setup.With(opensResolutionScope: true)` argument.</summary>
    public static IReuse ScopedTo<TService>(object serviceKey = null) =>
        ScopedToService(typeof(TService), serviceKey);

    /// <summary>Scoped to the scope created by the service with the specified type and optional key</summary>
    public static IReuse ScopedToService<TService>(object serviceKey = null) =>
        ScopedToService(typeof(TService), serviceKey);

    /// <summary>The same as <see cref="Scoped"/> but in case of no scope available will fallback to the <see cref="Singleton"/> reuse</summary>
    /// <remarks>The <see cref="Error.DependencyHasShorterReuseLifespan"/> is applied the same way as for <see cref="Scoped"/> reuse.</remarks>
    public static readonly IReuse ScopedOrSingleton = new CurrentScopeReuse(scopedOrSingleton: true);

    /// <summary>Obsolete: please use <see cref="Scoped"/> instead.</summary>
    public static readonly IReuse InCurrentScope = Scoped;

    /// <summary>Obsolete: please use `ScopedTo` instead.</summary>
    public static IReuse InCurrentNamedScope(object name = null) => ScopedTo(name);

    /// <summary>Same as Scoped but requires <see cref="ThreadScopeContext"/>.</summary>
    public static readonly IReuse InThread = Scoped;

    /// <summary>A special name recognized by <see cref="InWebRequest"/>.
    /// Note: The usage of the named scopes is the less performant than the unnamed ones. e.g. ASP.NET Core does not use the named scope.</summary>
    public static string WebRequestScopeName = "~WebRequestScopeName";

    /// <summary>Obsolete: please prefer using `Scoped` without name instead. 
    /// The usage of the named scopes is the less performant than the unnamed ones. e.g. ASP.NET Core does not use the named scope.</summary>
    public static readonly IReuse InWebRequest = ScopedTo(WebRequestScopeName);

    #region Implementation

    private sealed class TransientReuse : IReuse
    {
        public int Lifespan => 0;

        public object Name => null;

        public Expression Apply(Request _, Expression serviceFactoryExpr) => serviceFactoryExpr;

        public bool CanApply(Request request) => true;

        private readonly Lazy<Expression> _transientReuseExpr = Lazy.Of<Expression>(() =>
            Field(null, typeof(Reuse).GetField(nameof(Transient))));

        public Expression ToExpression<S>(S state, Func<S, object, Expression> fallbackConverter) =>
            _transientReuseExpr.Value;

        public override string ToString() => "TransientReuse";
    }

    #endregion
}

/// <summary>Policy to handle unresolved service.</summary>
public enum IfUnresolved : byte
{
    /// <summary>If service is unresolved for whatever means, the Resolve will throw the respective exception.</summary>
    Throw = 0,
    /// <summary>If service is unresolved for whatever means, the Resolve will return the default value.</summary>
    ReturnDefault,
    /// <summary>If service is not registered, then the Resolve will return the default value, for the other errors it will throw.</summary>
    ReturnDefaultIfNotRegistered,
}

/// <summary>Declares minimal API for service resolution. 
/// Resolve default and keyed is separated because of optimization for faster resolution of the former.</summary>
public interface IResolver : IServiceProvider
{
    /// <summary>Resolves default (non-keyed) service from container and returns created service object.</summary>
    /// <param name="serviceType">Service type to search and to return.</param>
    /// <param name="ifUnresolved">Says what to do if service is unresolved.</param>
    /// <returns>Created service object or default based on <paramref name="ifUnresolved"/> provided.</returns>
    object Resolve(Type serviceType, IfUnresolved ifUnresolved);

    /// <summary>Resolves service instance from container.</summary>
    /// <param name="serviceType">Service type to search and to return.</param>
    /// <param name="serviceKey">(optional) service key used for registering service.</param>
    /// <param name="ifUnresolved">(optional) Says what to do if service is unresolved.</param>
    /// <param name="requiredServiceType">(optional) Registered or wrapped service type to use instead of <paramref name="serviceType"/>,
    ///     or wrapped type for generic wrappers.  The type should be assignable to return <paramref name="serviceType"/>.</param>
    /// <param name="preResolveParent">(optional) Dependency chain info.</param>
    /// <param name="args">(optional) To specify the dependency objects to use instead of resolving them from container.</param>
    /// <returns>Created service object or default based on <paramref name="ifUnresolved"/> parameter.</returns>
    object Resolve(Type serviceType, object serviceKey,
        IfUnresolved ifUnresolved, Type requiredServiceType, Request preResolveParent, object[] args);

    /// <summary>Resolves all services registered for specified <paramref name="serviceType"/>, or if not found returns
    /// empty enumerable. If <paramref name="serviceType"/> specified then returns only (single) service registered with this type.</summary>
    /// <param name="serviceType">Return type of an service item.</param>
    /// <param name="serviceKey">(optional) Resolve only single service registered with the key.</param>
    /// <param name="requiredServiceType">(optional) Actual registered service to search for.</param>
    /// <param name="preResolveParent">Dependency resolution path info.</param>
    /// <param name="args">(optional) To specify the dependency objects to use instead of resolving them from container.</param>
    /// <returns>Enumerable of found services or empty. Does Not throw if no service found.</returns>
    IEnumerable<object> ResolveMany(Type serviceType, object serviceKey,
        Type requiredServiceType, Request preResolveParent, object[] args);
}

/// <summary>Specifies options to handle situation when registered service is already present in the registry.</summary>
public enum IfAlreadyRegistered : byte
{
    /// <summary>Appends new default registration or throws for registration with the same key.</summary>
    AppendNotKeyed,
    /// <summary>Throws if default or registration with the same key is already exist.</summary>
    Throw,
    /// <summary>Keeps old default or keyed registration ignoring new registration: ensures Register-Once semantics.</summary>
    Keep,
    /// <summary>Replaces old registration with new one.</summary>
    Replace,
    /// <summary>Adds the new implementation or null (Made.Of),
    /// otherwise keeps the previous registration of the same implementation type.</summary>
    AppendNewImplementation
}

/// <summary>Decorator registration info.</summary>

public struct DecoratorRegistrationInfo
{
    /// <summary>Registered factory.</summary>
    public Factory Factory;

    /// <summary>Decorator type.</summary>
    public Type DecoratorType;

    /// <summary>Creates info.</summary>
    public DecoratorRegistrationInfo(Factory factory, Type decoratorType)
    {
        Factory = factory;
        DecoratorType = decoratorType;
    }

    /// <summary>Pretty-prints info into the string.</summary>
    public override string ToString()
    {
        var sb = new StringBuilder("DecoratorType=`").Print(DecoratorType).Append('`');
        return sb.Append(" with Factory=`").Append(Factory).Append('`').ToString();
    }
}

/// <summary>Service registration info.</summary>
public struct ServiceRegistrationInfo : IComparable<ServiceRegistrationInfo>
{
    /// <summary>Registered factory.</summary>
    public Factory Factory;

    /// <summary>Required service type.</summary>
    public Type ServiceType;

    /// <summary>May be <c>null</c> for single default service, or <see cref="DefaultKey"/> for multiple default services.</summary>
    public object OptionalServiceKey;

    /// <summary>Provides registration order across all factory registrations in container.</summary>
    /// <remarks>May be the same for factory registered with multiple services
    /// OR for closed-generic factories produced from the single open-generic registration.</remarks>
    public int FactoryRegistrationOrder => Factory.RegistrationOrder;

    /// <summary>Implementation type if available.</summary>
    public Type ImplementationType => Factory.CanAccessImplementationType ? Factory.ImplementationType : null;

    /// <summary>Shortcut to <see cref="Setup.AsResolutionRoot"/> property, useful to find all roots</summary>
    public bool AsResolutionRoot => Factory.Setup.AsResolutionRoot;

    /// <summary>Shortcut to service info.</summary>
    public ServiceInfo ToServiceInfo() => OptionalServiceKey == null
        ? ServiceInfo.Of(ServiceType) : ServiceInfo.Of(ServiceType, serviceKey: OptionalServiceKey);

    /// <summary>Overrides the service type and pushes the original service type to required service type</summary>
    public ServiceInfo ToServiceInfo(Type serviceType) =>
        ServiceInfo.Of(serviceType, ServiceType, IfUnresolved.Throw, OptionalServiceKey);

    /// <summary>Overrides the service type and pushes the original service type to required service type</summary>
    public ServiceInfo ToServiceInfo<TService>() => ToServiceInfo(typeof(TService));

    /// <summary>Creates info. Registration order is figured out automatically based on Factory.</summary>
    public ServiceRegistrationInfo(Factory factory, Type serviceType, object optionalServiceKey)
    {
        Factory = factory;
        ServiceType = serviceType;
        OptionalServiceKey = optionalServiceKey;
    }

    /// <summary>Orders by registration</summary>
    public int CompareTo(ServiceRegistrationInfo other) => Factory.FactoryID - other.Factory.FactoryID;

    /// <summary>Pretty-prints info into the string.</summary>
    public override string ToString()
    {
        var sb = new StringBuilder("ServiceType=").Print(ServiceType);
        if (OptionalServiceKey != null)
            sb.Append(" with ServiceKey='").Print(OptionalServiceKey).Append('\'');
        return sb.Append(" with Factory=").Append(Factory).ToString();
    }
}

/// <summary>Defines operations that for changing registry, and checking if something exist in registry.</summary>
public interface IRegistrator
{
    /// <summary>Rules for defining resolution/registration behavior throughout container.</summary>
    Rules Rules { get; }

    /// <summary>Stores factory into container using <paramref name="serviceType"/> and <paramref name="serviceKey"/> as key for later lookup.</summary>
    /// <param name="factory">Any subtypes of <see cref="Factory"/>.</param>
    /// <param name="serviceType">Type of service to resolve later.</param>
    /// <param name="serviceKey">(optional) Service key of any type with <see cref="object.GetHashCode"/> and <see cref="object.Equals(object)"/>
    /// implemented.</param>
    /// <param name="ifAlreadyRegistered">(optional) Says how to handle existing registration with the same
    /// <paramref name="serviceType"/> and <paramref name="serviceKey"/>.</param>
    /// <param name="isStaticallyChecked">Confirms that service and implementation types are statically checked by compiler.</param>
    /// <returns>True if factory was added to registry, false otherwise.
    /// False may be in case of <see cref="IfAlreadyRegistered.Keep"/> setting and already existing factory.</returns>
    void Register(Factory factory, Type serviceType, object serviceKey, IfAlreadyRegistered? ifAlreadyRegistered, bool isStaticallyChecked);

    /// <summary>Register without validating factory and its implementation type against 
    /// the passed <paramref name="serviceType"/> and <paramref name="serviceKey"/></summary>
    void RegisterWithoutValidation(Factory factory, Type serviceType, object serviceKey, IfAlreadyRegistered? ifAlreadyRegistered);

    /// <summary>Returns true if expected factory is registered with specified service key and type.
    /// Not provided or <c>null</c> <paramref name="serviceKey"/> means to check the <paramref name="serviceType"/> 
    /// alone with any service key.</summary>
    bool IsRegistered(Type serviceType, object serviceKey, FactoryType factoryType, Func<Factory, bool> condition);

    /// <summary>Removes factory with specified service type and key from registry and cache.
    /// BUT consuming services may still hold on the resolved service instance.
    /// The cache of consuming services may also hold on the unregistered service. Use `IContainer.ClearCache` to clear all cache.</summary>
    void Unregister(Type serviceType, object serviceKey, FactoryType factoryType, Func<Factory, bool> condition);

    /// <summary>Returns registrations with their Type and optional Key. Decorators and Wrappers excluded.</summary>
    IEnumerable<ServiceRegistrationInfo> GetServiceRegistrations();

    /// <summary>Returns matched result of registrations with their Type and optional Key. Decorators and Wrappers excluded.</summary>
    IEnumerable<R> GetServiceRegistrations<S, R>(S state, MatchOp<S, ServiceRegistrationInfo, R> match);

    /// <summary>Returns the curretnly registered decorators. There maybe multiple entries for a specific DecoratorRegistrationInfo.DecoratorTy`pe`</summary>
    IEnumerable<DecoratorRegistrationInfo> GetDecoratorRegistrations();

    /// <summary>Searches for registered factories by type, and key (if specified),
    /// and by factory type (by default uses <see cref="FactoryType.Service"/>).
    /// May return empty, 1 or multiple factories.</summary>
    Factory[] GetRegisteredFactories(Type serviceType, object serviceKey, FactoryType factoryType);

    /// <summary>Puts instance created via the passed factory on demand into the current or singleton scope</summary>
    void Use(Type serviceType, object instance);
}

/// <summary>What to do with registrations when creating the new container from the existent one.</summary>
public enum RegistrySharing : byte
{
    /// <summary>Shares both registrations and resolution cache if any</summary>
    Share = 0,
    /// <summary>Clones the registrations but preserves the resolution cache</summary>
    CloneButKeepCache,
    /// <summary>Clones the registrations and drops the cache -- full reset!</summary>
    CloneAndDropCache
}

/// <summary>Combines registrator and resolver roles, plus rules and scope management.</summary>
public interface IContainer : IRegistrator, IResolverContext
{
    /// <summary>The rules object defines policies per container for registration and resolution.</summary>
    new Rules Rules { get; }

    /// <summary>Creates new container from the current one by specifying the listed parameters.
    /// If the null or default values are provided then the default or new values will be applied.
    /// Nothing will be inherited from the current container. If you want to inherit something you need to provide it as parameter.</summary>
    IContainer With(IResolverContext parent, Rules rules, IScopeContext scopeContext,
        RegistrySharing registrySharing, IScope singletonScope, IScope currentScope, IsRegistryChangePermitted? isRegistryChangePermitted);

    /// <summary>Helps to find potential problems when resolving the <paramref name="roots"/>.
    /// Method will collect the exceptions when resolving or injecting the specific root. Does not create any actual service objects.
    /// You must specify <paramref name="roots"/> to define your resolution roots, otherwise container will try to resolve all registrations, 
    /// which usually is not realistic case to validate.</summary>
    KeyValuePair<ServiceInfo, ContainerException>[] Validate(IEnumerable<ServiceInfo> roots);

    /// <summary>Generates expressions for specified roots and their "Resolve-call" dependencies.
    /// Wraps exceptions into errors. The method does not create any actual services.
    /// You may use Factory <see cref="Setup.AsResolutionRoot"/>.</summary>
    GeneratedExpressions GenerateResolutionExpressions(Func<IEnumerable<ServiceRegistrationInfo>, IEnumerable<ServiceInfo>> getRoots = null, bool allowRuntimeState = false);

    /// <summary>Searches for the requested factory in registry or in the Dynamic registrations.
    /// Plus generates the closed-generic factory for the found open-generic one.</summary>
    /// <returns>Resolved factory, otherwise null if <see cref="Request.IfUnresolved"/> is set to <see cref="IfUnresolved.ReturnDefault"/>.</returns>
    Factory ResolveFactory(Request request);

    /// <summary>Searches for the requested factory specified by the `ServiceInfo` in registry or in the Dynamic registrations.
    /// Plus generates the closed-generic factory for the found open-generic one.</summary>
    /// <returns>Resolved factory, otherwise null if <see cref="Request.IfUnresolved"/> is set to <see cref="IfUnresolved.ReturnDefault"/>.</returns>
    Factory ResolveFactory(ServiceInfo serviceInfo);

    /// <summary>Resolves the factory and then gets the result expression</summary>
    /// <returns>Resolved expression, otherwise null if <see cref="Request.IfUnresolved"/> is set to <see cref="IfUnresolved.ReturnDefault"/>.</returns>
    Expression ResolveExpression(ServiceInfo serviceInfo);

    /// <summary>Searches for registered service factory and returns it, or null if not found.
    /// Will use <see cref="DryIoc.Rules.FactorySelector"/> if specified.</summary>
    /// <param name="request">Factory request.</param>
    /// <returns>Found factory or null.</returns>
    Factory GetServiceFactoryOrDefault(Request request);

    /// <summary>Finds all registered default and keyed service factories and returns them. Skips decorators and wrappers.
    /// If the service type is closed-generic, the method will find and append the open-generic factories to the result.</summary>
    /// <remarks>Returned Key item should not be null - it should be <see cref="DefaultKey.Value"/>.</remarks>
    KV<object, Factory>[] GetAllServiceFactoriesPlusForOpenGeneric(Type serviceType); // todo: @perf try replace KV with ImHashMapEntry to avoid conversion cost

    /// <summary>Finds all registered default and keyed service factories and returns them. Skips decorators and wrappers.</summary>
    KV<object, Factory>[] GetAllServiceFactories(Type serviceType);

    /// <summary>Searches for registered wrapper factory and returns it, or null if not found.</summary>
    /// <param name="serviceType">Service type to look for.</param> <returns>Found wrapper factory or null.</returns>
    Factory GetWrapperFactoryOrDefault(Type serviceType);

    /// <summary>Faster lookups for the type and its generic type definition in the registered Wrappers.</summary>
    bool IsWrapper(Type serviceType, Type openGenericServiceType = null);

    /// <summary>Returns all decorators registered for the service type.</summary>
    Factory[] GetDecoratorFactoriesOrDefault(Type serviceType);

    /// <summary>Returns all decorators registered for the service type.</summary>
    Factory[] GetDecoratorFactoriesOrDefault(int serviceTypeHash, Type serviceType);

    /// <summary>Creates decorator expression: it could be either Func{TService,TService},
    /// or service expression for replacing decorators.</summary>
    /// <param name="request">Decorated service request.</param>
    /// <returns>Decorator expression.</returns>
    Expression GetDecoratorExpressionOrDefault(Request request);

    /// <summary>If <paramref name="serviceType"/> is generic type then this method checks if the type registered as generic wrapper,
    /// and recursively unwraps and returns its type argument. This type argument is the actual service type we want to find.
    /// Otherwise, method returns the input <paramref name="serviceType"/>.</summary>
    /// <param name="serviceType">Type to unwrap. Method will return early if type is not generic.</param>
    /// <param name="requiredServiceType">Required service type or null if don't care.</param>
    /// <returns>Unwrapped service type in case it corresponds to registered generic wrapper, or input type in all other cases.</returns>
    Type GetWrappedType(Type serviceType, Type requiredServiceType);

    /// <summary>If <paramref name="serviceType"/> is generic type then this method checks if the type registered as generic wrapper,
    /// and recursively unwraps and returns its type argument. This type argument is the actual service type we want to find.
    /// Otherwise, method returns the input <paramref name="serviceType"/>.</summary>
    Type GetWrappedType(Type serviceType);

    /// <summary>Converts known items into custom expression or wraps in a constant expression.</summary>
    /// <param name="item">Item to convert.</param>
    /// <param name="itemType">(optional) Type of item, otherwise item <see cref="object.GetType()"/>.</param>
    /// <param name="throwIfStateRequired">(optional) Throws for non-primitive and not-recognized items,
    /// identifying that result expression require run-time state. For compiled expression it means closure in lambda delegate.</param>
    /// <returns>Returns constant or state access expression for added items.</returns>
    Expression GetConstantExpression(object item, Type itemType = null, bool throwIfStateRequired = false);

    /// <summary>Clears cache for specified service(s). But does not clear instances of already resolved/created singletons and scoped services!</summary>
    /// <param name="serviceType">Target service type.</param>
    /// <param name="factoryType">(optional) If not specified, clears cache for all <see cref="FactoryType"/>.</param>
    /// <param name="serviceKey">(optional) If omitted, the cache will be cleared for all registrations of <paramref name="serviceType"/>.</param>
    /// <returns>True if target service was found, false - otherwise.</returns>
    bool ClearCache(Type serviceType, FactoryType? factoryType, object serviceKey);

    /// <summary>Puts instance created via the passed factory on demand into the current or singleton scope</summary>
    new void Use(Type serviceType, object instance);
}

/// <summary>Identifies the service when resolving collection</summary>
public struct ResolveManyResult
{
    /// <summary>Factory, the required part</summary>
    public Func<IResolverContext, object> FactoryDelegate;

    /// <summary>Optional key</summary>
    public object ServiceKey;

    /// <summary>Optional required service type, can be an open-generic type.</summary>
    public Type RequiredServiceType;

    /// <summary>Constructs the struct.</summary>
    public static ResolveManyResult Of(Func<IResolverContext, object> factoryDelegate, object serviceKey = null, Type requiredServiceType = null) =>
        new ResolveManyResult
        {
            FactoryDelegate = factoryDelegate,
            ServiceKey = serviceKey,
            RequiredServiceType = requiredServiceType
        };
}

/// <summary>The interface for the compile-time container, mostly for the resolution</summary>
public interface ICompileTimeContainer
{
    /// <summary>Check if service is registered by type</summary>
    bool IsRegistered(Type serviceType);

    /// <summary>Check if service is registered by type and the key</summary>
    bool IsRegistered(Type serviceType, object serviceKey);

    /// <summary>Returns the service object if it can be resolved</summary>
    bool TryResolve(out object service, IResolverContext r, Type serviceType);

    /// <summary>Returns the dependency object if it can be resolved</summary>
    bool TryResolve(out object service, IResolverContext r, Type serviceType, object serviceKey, Type requiredServiceType, Request preRequestParent, object[] args);

    /// <summary>Resolve many services or none at all (if no registerations found)</summary>
    IEnumerable<ResolveManyResult> ResolveMany(IResolverContext r, Type serviceType);
}

/// <summary>Resolves all registered services of <typeparamref name="TService"/> type on demand,
/// when enumerator <see cref="IEnumerator.MoveNext"/> called. If service type is not found, empty returned.</summary>
/// <typeparam name="TService">Service type to resolve.</typeparam>
public sealed class LazyEnumerable<TService> : IEnumerable<TService>
{
    /// <summary>Exposes internal items enumerable.</summary>
    public readonly IEnumerable<TService> Items;

    /// <summary>Wraps lazy resolved items.</summary> <param name="items">Lazy resolved items.</param>
    public LazyEnumerable(IEnumerable<TService> items) => Items = items.ThrowIfNull();

    /// <summary>Return items enumerator.</summary> 
    public IEnumerator<TService> GetEnumerator() => Items.GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

/// <summary>Wrapper type to box service with associated arbitrary metadata object.</summary>
/// <typeparam name="T">Service type.</typeparam>
/// <typeparam name="TMetadata">Arbitrary metadata object type.</typeparam>
public sealed class Meta<T, TMetadata>
{
    /// <summary>Value or object with associated metadata.</summary>
    public readonly T Value;

    /// <summary>Associated metadata object. Could be anything.</summary>
    public readonly TMetadata Metadata;

    /// <summary>Boxes value and its associated metadata together.</summary>
    public Meta(T value, TMetadata metadata)
    {
        Value = value;
        Metadata = metadata;
    }
}

/// <summary>Exception that container throws in case of error. Dedicated exception type simplifies
/// filtering or catching container relevant exceptions from client code.</summary>
[Serializable]
public class ContainerException : InvalidOperationException
{
    /// <summary>Error code of exception, possible values are listed in <see cref="Error"/> class.</summary>
    public readonly int Error;

    /// <summary>Simplifies the access to the error name.</summary>
    public string ErrorName => DryIoc.Error.NameOf(Error);

    /// <summary>Many collected exceptions</summary>
    public readonly ContainerException[] CollectedExceptions;

    /// <summary>Creates exception by wrapping <paramref name="errorCode"/> and its message,
    /// optionally with <paramref name="innerException"/> exception.</summary>
    public static ContainerException Of(ErrorCheck errorCheck, int errorCode,
        object arg0, object arg1 = null, object arg2 = null, object arg3 = null, Exception innerException = null) =>
        new ContainerException(errorCode,
            string.Format(GetMessage(errorCheck, errorCode), Print(arg0), Print(arg1), Print(arg2), Print(arg3)),
            innerException);

    /// <summary>Gets error message based on provided args.</summary> <param name="errorCheck"></param> <param name="errorCode"></param>
    protected static string GetMessage(ErrorCheck errorCheck, int errorCode) =>
        errorCode == -1 ? Throw.GetDefaultMessage(errorCheck) : DryIoc.Error.Messages[errorCode];

    /// <summary>Prints argument for formatted message.</summary> <param name="arg">To print.</param> <returns>Printed string.</returns>
    protected static string Print(object arg) => arg == null ? string.Empty : arg.Print();

    /// <summary>Collects many exceptions.</summary>
    public ContainerException(int error, ContainerException[] exceptions)
        : this(error, GetMessage(ErrorCheck.CollectedExceptions, error), null) =>
        CollectedExceptions = exceptions;

    /// <summary>Creates exception with message describing cause and context of error.</summary>
    public ContainerException(int error, string message)
        : this(error, message, null) { }

    /// <summary>The optional additional exception data.</summary>
    public readonly object Details;
    private ContainerException(object details, int error, string message)
        : this(error, message, null) => Details = details;

    /// <summary>Creates exception with details object and the message.</summary>
    public static object WithDetails(object details, int error, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null)
    {
        throw new ContainerException(details, error,
            string.Format(GetMessage(ErrorCheck.Unspecified, error), Print(arg0), Print(arg1), Print(arg2), Print(arg3)));
    }

    /// <summary>Creates exception with message describing cause and context of error,
    /// and leading/system exception causing it.</summary>
    public ContainerException(int errorCode, string message, Exception innerException)
        : this(errorCode, message, innerException, (e, m, _) => FormatMessage(DryIoc.Error.NameOf(e), m)) { }

    /// <summary>The default exception message format.</summary>
    protected static string FormatMessage(string errorName, string message) =>
        $"code: Error.{errorName};{NewLine}message: {message}";

    /// <summary>Allows the formatting of the final exception message.</summary>
    protected ContainerException(int errorCode, string message, Exception innerException,
        Func<int, string, Exception, string> formatMessage)
        : base(formatMessage(errorCode, message, innerException), innerException) =>
        Error = errorCode;

#if !NET8_0_OR_GREATER
    /// <inheritdoc />
    protected ContainerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
        : base(info, context) { }
#endif

    /// <summary>Tries to explain the specific exception based on the passed container</summary>
    public string TryGetDetails(IRegistrator container)
    {
        var e = Error;
        if (e == DryIoc.Error.WaitForScopedServiceIsCreatedTimeoutExpired)
        {
            var factoryId = (int)Details;
            string decoratorMessage = null;

            // check `Request.CombineDecoratorWithDecoratedFactoryID()` for why is this logic
            if (factoryId > ushort.MaxValue)
            {
                var decoratorFactoryId = factoryId & ushort.MaxValue;
                factoryId >>= 16; // should be logical `>>>` but C# <- 11 does not support it yet
                decoratorMessage = GetDecoratorMessage(container, decoratorFactoryId);
                static string GetDecoratorMessage(IRegistrator container, int decoratorFactoryId)
                {
                    foreach (var decoratorReg in container.GetDecoratorRegistrations())
                    {
                        var f = decoratorReg.Factory;
                        if (f.FactoryID == decoratorFactoryId)
                            return $"Decorator registration related to the problem is:{NewLine}{decoratorReg}";
                        var genFactories = f.GeneratedFactories;
                        if (genFactories != null)
                            foreach (var genEntry in f.GeneratedFactories.Enumerate())
                            {
                                var generatedFactory = genEntry.Value;
                                if (generatedFactory.FactoryID == decoratorFactoryId)
                                    return $"Decorator registration related to the problem is:{NewLine}{decoratorReg}{NewLine}Specifically, the generated closed-generic factory is:{NewLine}{generatedFactory}";
                            }
                    }
                    return $"Unable to find the Decorator registration for the problematic factory with FactoryID={decoratorFactoryId}";
                }
            }

            var serviceMessage = GetServiceMessage(container, factoryId);
            static string GetServiceMessage(IRegistrator container, int factoryId)
            {
                foreach (var serviceReg in container.GetServiceRegistrations())
                {
                    var f = serviceReg.Factory;
                    if (f.FactoryID == factoryId)
                        return $"Service registration related to the problem is:{NewLine}{serviceReg}";
                    var genFactories = f.GeneratedFactories;
                    if (genFactories != null)
                        foreach (var genEntry in f.GeneratedFactories.Enumerate())
                        {
                            var generatedFactory = genEntry.Value;
                            if (generatedFactory.FactoryID == factoryId)
                                return $"Service registration related to the problem is:{NewLine}{serviceReg}{NewLine}Specifically, the generated closed-generic factory is:{NewLine}{generatedFactory}";
                        }
                }
                return $"Unable to find the Service registration for the problematic factory with FactoryID={factoryId}";
            }

            return decoratorMessage == null ? serviceMessage : decoratorMessage + NewLine + serviceMessage;
        }
        return string.Empty;
    }
}

/// <summary>Defines error codes and error messages for all DryIoc exceptions (DryIoc extensions may define their own.)</summary>
public static class Error
{
    private static int _errorIndex = -1;

    /// <summary>List of error messages indexed with code.</summary>
    public static readonly string[] Messages = new string[100];

#pragma warning disable 1591 // "Missing XML-comment"
    public static readonly int
        UnableToResolveUnknownService = Of(
            "Unable to resolve {0}" + NewLine +
            "Where no service registrations found" + NewLine +
            "  and no dynamic registrations found in {1} of Rules.DynamicServiceProviders" + NewLine +
            "  and nothing found in {2} of Rules.UnknownServiceResolvers"),

        UnableToResolveFromRegisteredServices = Of(
            "Unable to resolve {0}" + NewLine +
            "  with normal and dynamic registrations:" + NewLine + "{1}"),

        ExpectedSingleDefaultFactory = Of(
            "Expecting a single default registration but found many:" + NewLine + "{0}" + NewLine +
            "when resolving {1}." + NewLine +
            "Please identify service with key, or metadata, or use Rules.WithFactorySelector to specify single registered factory."),

        RegisteringImplementationNotAssignableToServiceType = Of(
            "Registering implementation type {0} is not assignable to service type {1}."),
        RegisteredFactoryMethodResultTypesIsNotAssignableToImplementationType = Of(
            "Registered factory method return type {1} should be assignable Or castable to implementation type {0} but it is not."),
        ImpossibleToRegisterOpenGenericWithRegisterDelegate = Of( // todo: @naming Improve the naming to say something about open-generic
            "Unable to register delegate factory for open-generic service {0}." + NewLine +
            "You need to specify concrete (closed) service type returned by delegate."),
        RegisteringOpenGenericImplWithNonGenericService = Of(
            "Unable to register open-generic implementation {0} with non-generic service {1}."),
        RegisteringOpenGenericServiceWithMissingTypeArgs = Of(
            "Unable to register open-generic implementation {0} because service {1} should specify all type arguments, but specifies only {2}."),
        RegisteringNotAGenericTypedefImplType = Of(
            "Unsupported registration of implementation {0} which is not a generic type definition but contains generic parameters." + NewLine +
            "Consider to register generic type definition {1} instead."),
        RegisteringNotAGenericTypedefServiceType = Of(
            "Unsupported registration of service {0} which is not a generic type definition but contains generic parameters." + NewLine +
            "Consider to register generic type definition {1} instead."),
        RegisteringNullImplementationTypeAndNoFactoryMethod = Of(
            "Registering without implementation type and without FactoryMethod to use instead."),
        RegisteringObjectTypeAsImplementationIsNotSupported = Of(
            "Registering `System.Object` type as implementation without a factory method is not supported."),
        RegisteringAbstractImplementationTypeAndNoFactoryMethod = Of(
            "Registering abstract implementation type {0} when it is should be concrete. Also there is not FactoryMethod to use instead."),
        UnableToSelectSinglePublicConstructorFromMultiple = Of(
            "Unable to select single public constructor from implementation type {0}:" + NewLine +
            "{1}"),
        UnableToSelectSinglePublicConstructorFromNone = Of(
            "Unable to select a single public constructor from the implementation type '{0}' because the type does not have public constructors."),
        NoMatchedImplementedTypesWithServiceType = Of(
            "Unable to match service with open-generic {0} implementing {1} when resolving {2}."),
        NoMatchedFactoryMethodDeclaringTypeWithServiceTypeArgs = Of(
            "Unable to match open-generic factory method Declaring type {0} with requested service type arguments <{1}> when resolving {2}."),
        NoMatchedFactoryMethodWithServiceTypeArgs = Of(
            "Unable to match open-generic factory method {0} with requested service type arguments <{1}> when resolving {2}."),
        OpenGenericFactoryMethodDeclaringTypeIsNotSupportedOnThisPlatform = Of(
            "[Specific to this .NET version] Unable to match method or constructor {0} from open-generic declaring type {1} to closed-generic type {2}, " +
            NewLine +
            "Please give the method an unique name to distinguish it from other overloads."),
        ResolvingOpenGenericServiceTypeIsNotPossible = Of(
            "Resolving open-generic service type is not possible for type: {0}."),
        RecursiveDependencyDetected = Of(
            "Recursive dependency is detected when resolving " + NewLine + "{0}."),
        ScopeIsDisposed = Of(
            "Scope {0} is disposed and scoped instances are disposed and no longer available." + NewLine +
            "Dispose stack-trace: " + NewLine + "{1}"),
        NotFoundOpenGenericImplTypeArgInService = Of(
            "Unable to find for open-generic implementation {0} the type argument {1} when resolving {2}."),
        UnableToSelectCtor = Of(
            "Unable to get constructor of {0} using provided constructor selector when resolving {1}."),
        UnableToFindCtorWithAllResolvableArgs = Of(
            "Unable to find most resolvable constructor also including passed input arguments `{0}` " +
            NewLine + " when resolving: {1}."),
        RegisteredDelegateResultIsNotOfServiceType = Of(
            "Registered factory delegate returns service {0} is not assignable to desired service {1}."),
        NotFoundSpecifiedWritablePropertyOrField = Of(
            "Unable to find writable property or field {0} when resolving: {1}."),
        PushingToRequestWithoutFactory = Of(
            "Pushing the next request `{0}` into parent request not yet resolved to factory: {1}"),
        NoMatchedGenericParamConstraints = Of(
            "Open-generic service does not match with registered open-generic implementation constraints {0} when resolving: {1}."),
        GenericWrapperWithMultipleTypeArgsShouldSpecifyArgIndex = Of(
            "Generic wrapper type {0} should specify what type argument is wrapped, but it does not."),
        GenericWrapperTypeArgIndexOutOfBounds = Of(
            "Registered generic wrapper {0} specified type argument index {1} is out of type argument list."),
        DependencyHasShorterReuseLifespan = Of(
            "Dependency {0} with reuse {1} has a shorter lifespan than its parent's {2}" + NewLine +
            "If you know what you're doing you may disable this error with the rule `new Container(rules => rules.WithoutThrowIfDependencyHasShorterReuseLifespan())`."),
        WeakRefReuseWrapperGCed = Of(
            "Reused service wrapped in WeakReference is Garbage Collected and no longer available."),
        ServiceIsNotAssignableFromFactoryMethod = Of(
            "Service of {0} is not assignable from factory method {1} when resolving: {2}."),
        GotNullConstructorFromFactoryMethod = Of(
            "Got null constructor when resolving {0}"),
        UnableToRegisterDuplicateDefault = Of(
            "The default service {0} without key {1} is already registered as {2}."),
        UnableToRegisterDuplicateKey = Of(
            "Unable to register service with duplicate service key '{0}' for the already present service key '{1}'" + NewLine +
            " The already present factory is: {2}."),
        NoCurrentScope = Of(
            "No current scope is available - probably you are registering to or resolving from outside of the scope. " + NewLine +
            "It also may be because of the scoped dependency has singletons in its parent chain so the dependency is resolved from the root container resolver." + NewLine +
            "Current resolver context is: {0}."),
        ContainerIsDisposed = Of(
            "Container is disposed and should not be used: {0}"),
        NoMatchedScopeFound = Of(
            "Unable to find matching scope with name {0} starting from the current scope {1}."),
        NotSupportedMadeOfExpression = Of(
            "Expected expression of method call, property getter, or new statement (with optional property initializer), " +
            "but found this Made.Of expression: {0}"),
        UnexpectedFactoryMemberExpressionInMadeOf = Of(
            "Expected property getter, but found not supported `{0}` " + NewLine +
            "in Made.Of expression: `{1}`"),
        UnexpectedExpressionInsteadOfArgMethodInMadeOf = Of(
            "Expected `Arg.Of` method call to specify parameter, property or field, but found `{0}` " + NewLine +
            "in Made.Of expression: `{1}`"),
        UnexpectedExpressionInsteadOfConstantInMadeOf = Of(
            "Expected `ConstantExpression` for value of parameter, property, or field, but found `{0}` " + NewLine +
            "in Made.Of expression: `{1}`"),
        InjectedCustomValueIsOfDifferentType = Of(
            "Injected value {0} is not assignable to {1} when resolving: {2}"),
        NoConversionOperatorFoundWhenInterpretingTheConvertExpression = Of(
            "There is no explicit or implicit conversion operator found when interpreting {0} to {1} in expression: {2}"),
        StateIsRequiredToUseItem = Of(
            "Runtime state is required to inject (or use) the object of type `{0}` and value: `{1}`. " + NewLine +
            "The reason is using RegisterDelegate, Use, RegisterInitializer/Disposer, or registering with non-primitive service key, or metadata." + NewLine +
            "You can convert run-time value to expression via container.With(rules => rules.WithItemToExpressionConverter(YOUR_ITEM_TO_EXPRESSION_CONVERTER))."),
        ArgValueIndexIsProvidedButNoArgValues = Of(
            "`Arg.Index` is provided but no values are passed in Made.Of expression: " + NewLine +
            "{0}"),
        ArgValueIndexIsOutOfProvidedArgValues = Of(
            "`Arg.Index` {0} is outside of provided values [{1}] in Made.Of expression: " + NewLine +
            "{2}"),
        ResolutionNeedsRequiredServiceType = Of(
            "Expecting required service type but it is not specified when resolving: {0}"),
        RegisterMappingNotFoundRegisteredService = Of(
            "When registering mapping, Container is unable to find factory of registered service type {0} and key {1}."),
        RegisterMappingUnableToSelectFromMultipleFactories = Of(
            "RegisterMapping selected more than 1 factory with provided type {0} and key {1}: {2}"),
        RegisteringInstanceNotAssignableToServiceType = Of(
            "Registered instance of type {0} is not assignable to serviceType {1}."),
        NoMoreRegistrationsAllowed = Of(
            "Container does not allow further registrations." + NewLine +
            "Attempting to register {0}{1} with implementation factory {2}."),
        NoMoreUnregistrationsAllowed = Of(
            "Container does not allow further registry modification." + NewLine +
            "Attempting to Unregister {0}{1} with factory type {2}."),
        GotNullFactoryWhenResolvingService = Of(
            "Got null factory method when resolving {0}"),
        RegisteredDisposableTransientWontBeDisposedByContainer = Of(
            "Registered Disposable Transient service {0} with key {1} registered as {2} won't be disposed by container." +
            " DryIoc does not hold reference to resolved transients, and therefore does not control their dispose." +
            " To silence this exception Register<YourService>(setup: Setup.With(allowDisposableTransient: true)) " +
            " or set the rule Container(rules => rules.WithoutThrowOnRegisteringDisposableTransient())." +
            " To enable tracking use Register<YourService>(setup: Setup.With(trackDisposableTransient: true)) " +
            " or set the rule Container(rules => rules.WithTrackingDisposableTransients())"),
        NotFoundMetaCtorWithTwoArgs = Of(
            "Expecting Meta wrapper public constructor with two arguments {0} but not found when resolving: {1}"),
        UnableToSelectFromManyRegistrationsWithMatchingMetadata = Of(
            "Unable to select from multiple registrations matching the Metadata type {0}:" + NewLine +
            "{1}" + NewLine +
            "When resolving: {2}"),
        ImplTypeIsNotSpecifiedForAutoCtorSelection = Of(
            "Implementation type is not specified when using automatic constructor selection: {0}"),
        NoImplementationForPlaceholder = Of(
            "There is no real implementation, only a placeholder for the service {0}." + NewLine +
            "Please Register the implementation with the ifAlreadyRegistered.Replace parameter to fill the placeholder."),
        InjectedIntoFactoryDummy = Of(
            "This is not a real factory but a dummy for the instance where properties and fields are injected into"),
        DecoratorShouldNotBeRegisteredWithServiceKey = Of(
            "Registering Decorator {0} with service key {1} is not supported," + NewLine +
            "because instead of decorator with the key you actually want a decorator for service registered with the key." + NewLine +
            "To apply decorator for service with the key, please use `Setup.DecoratorOf(decorateeServiceKey: \"a service key\")`"),
        PassedCtorOrMemberIsNull = Of(
            "The constructor of member info passed to `Made.Of` or `FactoryMethod.Of` is null"),
        PassedMemberIsNotStaticButInstanceFactoryIsNull = Of(
            "The member info {0} passed to `Made.Of` or `FactoryMethod.Of` is NOT static, but instance factory is not provided or null"),
        PassedMemberIsStaticButInstanceFactoryIsNotNull = Of(
            "You are passing constructor or STATIC member info {0} to `Made.Of` or `FactoryMethod.Of`, but then why are you passing factory INSTANCE: {1}"),
        MadeOfCallExpressionParameterDoesNotCorrespondToTheFactoryInfo = Of(
            "Made.Of factory method uses parameter expression `{0}` which is not corresponding to the factory info for that parameter: {1}"),
        UndefinedMethodWhenGettingTheSingleMethod = Of(
            "Undefined Method '{0}' in Type {1} (including non-public={2})"),
        UndefinedMethodWhenGettingMethodWithSpecifiedParameters = Of(
            "Undefined Method '{0}' in Type {1} with parameters {2}."),
        UndefinedPropertyWhenGettingProperty = Of("Undefined property {0} in type {1}"),
        UndefinedFieldWhenGettingField = Of("Undefined field {0} in type {1}"),
        UnableToFindConstructorWithArgs = Of("Unable to find a constructor in Type {0} with args: {1}"),
        UnableToFindSingleConstructor = Of(
            "Unable to find a single constructor in Type {0} (including non-public={1})"),
        DisposerTrackForDisposeError = Of("Something is {0} already."),
        NoServicesWereRegisteredByRegisterMany = Of(
            "No service types were discovered in `RegisterMany` (or in `RegisterInstanceMany`) for the specified implementation types: " + NewLine +
            "[{0}]" + NewLine +
            "Maybe you missed the implementation or service type(s), " +
            "e.g. provided only abstract or compiler-generated implementation types, " +
            "or specified a wrong `serviceTypeCondition`," +
            "or did not specify to use `nonPublicServiceTypes`, etc."),
        FoundNoRootsToValidate = Of(
            "No roots to Validate found. Check the `condition` passed to Validate method for container: {0}" + NewLine +
            "You may also examine all container registrations via `container.container.GetServiceRegistrations()` method."),
        NoServiceTypesToValidate = Of(
            "The `serviceTypes` passed to Validate method is null or empty. Please pass the type(s) you want to Validate."),
        ValidateFoundErrors = Of(
            "Validate method found the errors, please check the ContainerException.CollectedExceptions for the details." + NewLine +
            "If you see too many (unexpected) errors, try narrowing the resolution roots by passing the selected service types or the condition to the Validate(AndThrow) method." + NewLine +
            "Or alternatively, mark the service registrations with `setup: Setup.With(asResolutionRoot: true)`."),
        UnableToInterpretTheNestedLambda = Of(
            "Unable to interpret the nested lambda with Body:" + NewLine + "{0}"),
        WaitForScopedServiceIsCreatedTimeoutExpired = Of(
            $"Waited for the creation of the Scoped or Singleton service by \"other party\" for {{0}}(actual) > {Scope.WaitForScopedServiceIsCreatedTimeoutMilliseconds}(max) ms without the completion. " + NewLine +
            "You may call `exception.TryGetDetails(container)` to get more the details of the problematic service registration." + NewLine +
            "The error means that either the \"other party\" is the parallel thread which has started but is unable to finish the creation of the service in time. " + NewLine +
            "Or more likely the \"other party\" is the same thread and there is an undetected recursive dependency or, " + NewLine +
            "service creation is failed with the exception and the exception was catched, but you're trying to resolve the failed service again. " + NewLine +
            "For all those reasons DryIoc has a timeout to prevent the infinite waiting. " + NewLine +
            $"You may change the default timeout via setting the static `Scope.{nameof(Scope.WaitForScopedServiceIsCreatedTimeoutMilliseconds)}`"),
        ServiceTypeIsNull = Of("Registered service type is null");

#pragma warning restore 1591 // "Missing XML-comment"

    private static int Of(string message)
    {
        var errorIndex = Interlocked.Increment(ref _errorIndex);
        Messages[errorIndex] = message;
        return errorIndex;
    }

    /// <summary>Returns the name of error with the provided error code.</summary>
    public static string NameOf(int error) =>
        error == -1 ? "ErrorCheck" :
        typeof(Error).GetTypeInfo().DeclaredFields
            .Where(f => f.FieldType == typeof(int)).Where((_, i) => i == error + 1)
            .FirstOrDefault()?.Name;
}

/// <summary>Checked error condition, possible error sources.</summary>
public enum ErrorCheck
{
    /// <summary>Unspecified, just throw.</summary>
    Unspecified,
    /// <summary>Predicate evaluated to false.</summary>
    InvalidCondition,
    /// <summary>Checked object is null.</summary>
    IsNull,
    /// <summary>Checked object is of unexpected type.</summary>
    IsNotOfType,
    /// <summary>Checked type is not assignable to expected type</summary>
    TypeIsNotOfType,
    /// <summary>Invoked operation throws, it is source of inner exception.</summary>
    OperationThrows,
    /// <summary>Just stores many collected exceptions.</summary>
    CollectedExceptions,
}

/// <summary>Enables more clean error message formatting and a bit of code contracts.</summary>
public static class Throw
{
    private static string[] CreateDefaultMessages()
    {
        var messages = new string[(int)ErrorCheck.CollectedExceptions + 1];
        messages[(int)ErrorCheck.Unspecified] = "The error reason is unspecified, which is bad thing.";
        messages[(int)ErrorCheck.InvalidCondition] = "Argument {0} of type {1} has invalid condition.";
        messages[(int)ErrorCheck.IsNull] = "Argument of type {0} is null.";
        messages[(int)ErrorCheck.IsNotOfType] = "Argument {0} is not of type {1}.";
        messages[(int)ErrorCheck.TypeIsNotOfType] = "Type argument {0} is not assignable from type {1}.";
        messages[(int)ErrorCheck.OperationThrows] = "Invoked operation throws the inner exception {0}.";
        messages[(int)ErrorCheck.CollectedExceptions] = "Please check the `ContainerException.CollectedExceptions` for the details";
        return messages;
    }

    private static readonly string[] _defaultMessages = CreateDefaultMessages();

    /// <summary>Returns the default message specified for <see cref="ErrorCheck"/> code.</summary>
    public static string GetDefaultMessage(ErrorCheck error) =>
        _defaultMessages[(int)error];

    /// <summary>Declares mapping between <see cref="ErrorCheck"/> type and <paramref name="error"/> code to specific <see cref="Exception"/>.</summary>
    public delegate Exception GetMatchedExceptionHandler(ErrorCheck errorCheck, int error, object arg0, object arg1, object arg2, object arg3, Exception inner);

    /// <summary>Returns matched exception for error check and error code.</summary>
    public static GetMatchedExceptionHandler GetMatchedException
    {
        get => _getMatchedException ?? ContainerException.Of;
        set => _getMatchedException = value;
    }
    private static GetMatchedExceptionHandler _getMatchedException;

    /// <summary>Throws matched exception with provided error code if throw condition is true.</summary>
    public static void If(bool throwCondition, int error = -1, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null)
    {
        if (throwCondition)
            throw GetMatchedException(ErrorCheck.InvalidCondition, error, arg0, arg1, arg2, arg3, null);
    }

    /// <summary>Throws matched exception with provided error code if throw condition is true.
    /// Otherwise returns source <paramref name="arg0"/>.</summary>
    public static T ThrowIf<T>(this T arg0, bool throwCondition, int error = -1, object arg1 = null, object arg2 = null, object arg3 = null)
    {
        if (!throwCondition) return arg0;
        throw GetMatchedException(ErrorCheck.InvalidCondition, error, arg0, arg1, arg2, arg3, null);
    }

    /// <summary>Throws exception if <paramref name="arg"/> is null, otherwise returns <paramref name="arg"/>.</summary>
    public static T ThrowIfNull<T>(this T arg, int error = -1, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null)
        where T : class
    {
        if (arg != null) return arg;
        throw GetMatchedException(ErrorCheck.IsNull, error, arg0 ?? typeof(T), arg1, arg2, arg3, null);
    }

    /// <summary>Throws exception if <paramref name="arg0"/> is not assignable to type specified by <paramref name="arg1"/>,
    /// otherwise just returns <paramref name="arg0"/>.</summary>
    public static T ThrowIfNotInstanceOf<T>(this T arg0, Type arg1, int error = -1, object arg2 = null, object arg3 = null)
    {
        if (ReferenceEquals(arg0, null) && (!arg1.IsValueType || arg1.IsGenericType && arg1.GetGenericTypeDefinition() == typeof(Nullable<>)) ||
            arg1.IsAssignableFrom(arg0.GetType()))
            return arg0;
        throw GetMatchedException(ErrorCheck.IsNotOfType, error, arg0, arg1, arg2, arg3, null);
    }

    /// <summary>Throws if <paramref name="arg0"/> is not assignable from <paramref name="arg1"/>.</summary>
    public static Type ThrowIfNotImplementedBy(this Type arg0, Type arg1, int error = -1, object arg2 = null, object arg3 = null)
    {
        if (arg0.IsAssignableFrom(arg1)) return arg0;
        throw GetMatchedException(ErrorCheck.TypeIsNotOfType, error, arg0, arg1, arg2, arg3, null);
    }

    /// <summary>Invokes <paramref name="operation"/> and in case of <typeparamref name="TEx"/> re-throws it as inner-exception.</summary>
    public static T IfThrows<TEx, T>(Func<T> operation, bool throwCondition, int error, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null) where TEx : Exception
    {
        try
        {
            return operation();
        }
        catch (TEx ex)
        {
            if (throwCondition)
                throw GetMatchedException(ErrorCheck.OperationThrows, error, arg0, arg1, arg2, arg3, ex);
            return default(T);
        }
    }

    /// <summary>Just throws the exception with the <paramref name="error"/> code.</summary>
    public static object It(int error, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null)
    {
        throw GetMatchedException(ErrorCheck.Unspecified, error, arg0, arg1, arg2, arg3, null);
    }

    /// <summary>Just throws the exception with the <paramref name="error"/> code.</summary>
    public static object WithDetails(object details, int error, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null) =>
        ContainerException.WithDetails(details, error, arg0, arg1, arg2, arg3);

    /// <summary>Throws <paramref name="error"/> instead of returning value of <typeparamref name="T"/>.
    /// Supposed to be used in expression that require some return value.</summary>
    public static T For<T>(int error, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null)
    {
        throw GetMatchedException(ErrorCheck.Unspecified, error, arg0, arg1, arg2, arg3, null);
    }

    /// <summary>Throws if contidion is true, otherwise returns the `default(T)` value</summary>
    public static T For<T>(bool throwCondition, int error,
        object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null)
    {
        if (!throwCondition) return default(T);
        throw GetMatchedException(ErrorCheck.Unspecified, error, arg0, arg1, arg2, arg3, null);
    }

    /// <summary>Throws if contidion is true, and returns the false if not throwing</summary>
    public static bool When(bool throwIfInvalid, int error, object arg0 = null, object arg1 = null, object arg2 = null, object arg3 = null)
    {
        if (!throwIfInvalid) return false;
        throw GetMatchedException(ErrorCheck.Unspecified, error, arg0, arg1, arg2, arg3, null);
    }

    /// <summary>Throws the one with manyh collected exceptions</summary>
    public static void Many(int error, params ContainerException[] errors) =>
        throw new ContainerException(error, errors);

    /// <summary>Throws the exception with info about the disposed scope and 
    /// the dispose stack trace if it is supported by resolver context.</summary>
    public static void ScopeIsDisposed(IScope scope, IResolverContext r) =>
        It(Error.ScopeIsDisposed, scope.ToString(), r?.DisposeInfo ?? "<not available>");

    /// <summary>Print the d*mn exception</summary>
    public static void StateIsRequiredToUseItem(object item, Type itemType = null) =>
        It(Error.StateIsRequiredToUseItem, itemType ?? item.GetType(), item);
}

/// <summary>Called from the generated code to check if WeakReference.Value is GCed.</summary>
public static class ThrowInGeneratedCode
{
    /// <summary>Throws if the object is null.</summary>
    public static object WeakRefReuseWrapperGCed(this object obj)
    {
        if (obj == null) Throw.It(Error.WeakRefReuseWrapperGCed);
        return obj;
    }

    internal static readonly MethodInfo WeakRefReuseWrapperGCedMethod =
        typeof(ThrowInGeneratedCode).GetMethod(nameof(WeakRefReuseWrapperGCed));
}

/// <summary>Contains helper methods to work with Type: for instance to find Type implemented base types and interfaces, etc.</summary>
public static class ReflectionTools
{
    internal static readonly PropertyInfo WeakReferenceValueProperty =
        typeof(WeakReference).GetProperty(nameof(WeakReference.Target));

    internal static readonly ConstructorInfo WeakReferenceCtor =
        typeof(WeakReference).GetConstructor(new[] { typeof(object) });

    // todo: @perf preserve the stack trace by the modern means, e.g. via ExceptionDispatchInfo.Capture
    private const string InternalPreserveStackTraceMethod = nameof(InternalPreserveStackTrace);
#if NET8_0_OR_GREATER
    [UnsafeAccessor(UnsafeAccessorKind.Method, Name = InternalPreserveStackTraceMethod)]
    private static extern void InternalPreserveStackTrace(Exception exception);
#else
    private static Lazy<Action<Exception>> _preserveExceptionStackTraceAction = new Lazy<Action<Exception>>(() =>
        typeof(Exception).GetMethod(InternalPreserveStackTraceMethod, BindingFlags.Instance | BindingFlags.NonPublic)
        ?.To(static x => x.CreateDelegate(typeof(Action<Exception>)).To<Action<Exception>>()));
    private static void InternalPreserveStackTrace(Exception exception) =>
        _preserveExceptionStackTraceAction.Value?.Invoke(exception);
#endif

    /// <summary>Preserves the stack trace before re-throwing.</summary>
    public static Exception TryRethrowWithPreservedStackTrace(this Exception ex)
    {
        InternalPreserveStackTrace(ex);
        return ex;
    }

    /// <summary>Flags for <see cref="GetImplementedTypes"/> method.</summary>
    [Flags]
    public enum AsImplementedType
    {
        /// <summary>Include nor object not source type.</summary>
        None = 0,
        /// <summary>Include source type to list of implemented types.</summary>
        SourceType = 1,
        /// <summary>Include <see cref="Object"/> type to list of implemented types.</summary>
        ObjectType = 2
    }

    internal static Type[] GetImplementedTypesExcludingItselfAndObject(this Type sourceType)
    {
        Type[] results;

        var interfaces = sourceType.GetInterfaces();
        var interfaceCount = interfaces.Length;

        var baseType = sourceType.BaseType;
        if (baseType == null || baseType == typeof(object))
            results = new Type[interfaceCount];
        else
        {
            Type baseBaseType = null;
            List<Type> baseBaseTypes = null;
            for (var bb = baseType.BaseType; bb != null && bb != typeof(object); bb = bb.BaseType)
                if (baseBaseTypes != null)
                    baseBaseTypes.Add(bb);
                else if (baseBaseType != null)
                    baseBaseTypes = new List<Type>(2) { baseBaseType, bb };
                else
                    baseBaseType = bb;

            if (baseBaseType == null)
                results = new Type[interfaceCount + 1];
            else if (baseBaseTypes != null)
            {
                results = new Type[interfaceCount + baseBaseTypes.Count + 1];
                baseBaseTypes.CopyTo(results, interfaceCount + 1);
            }
            else
            {
                results = new Type[interfaceCount + 2];
                results[interfaceCount + 1] = baseBaseType;
            }
            results[interfaceCount] = baseType;
        }

        if (interfaceCount == 1)
            results[0] = interfaces[0];
        else if (interfaceCount > 1)
            Array.Copy(interfaces, 0, results, 0, interfaces.Length);

        return results;
    }

    /// <summary>Returns all interfaces and all base types (in that order) implemented by <paramref name="sourceType"/>.
    /// Specify <paramref name="asImplementedType"/> to include <paramref name="sourceType"/> itself as first item and
    /// <see cref="object"/> type as the last item.</summary>
    public static Type[] GetImplementedTypes(this Type sourceType, AsImplementedType asImplementedType = AsImplementedType.None)
    {
        if (asImplementedType == AsImplementedType.None)
            return sourceType.GetImplementedTypesExcludingItselfAndObject();

        Type[] results;

        var interfaces = sourceType.GetInterfaces();
        var interfaceStartIndex = (asImplementedType & AsImplementedType.SourceType) == 0 ? 0 : 1;
        var includingObjectType = (asImplementedType & AsImplementedType.ObjectType) == 0 ? 0 : 1;
        var sourcePlusInterfaceCount = interfaceStartIndex + interfaces.Length;

        var baseType = sourceType.BaseType;
        if (baseType == null || baseType == typeof(object))
            results = new Type[sourcePlusInterfaceCount + includingObjectType];
        else
        {
            List<Type> baseBaseTypes = null; // todo: @perf optimize list away
            for (var bb = baseType.BaseType; bb != null && bb != typeof(object); bb = bb.BaseType)
                (baseBaseTypes ?? (baseBaseTypes = new List<Type>(2))).Add(bb);

            if (baseBaseTypes == null)
                results = new Type[sourcePlusInterfaceCount + includingObjectType + 1];
            else
            {
                results = new Type[sourcePlusInterfaceCount + includingObjectType + baseBaseTypes.Count + 1];
                baseBaseTypes.CopyTo(results, sourcePlusInterfaceCount + 1);
            }

            results[sourcePlusInterfaceCount] = baseType;
        }

        if (interfaces.Length == 1)
            results[interfaceStartIndex] = interfaces[0];
        else if (interfaces.Length > 1)
            Array.Copy(interfaces, 0, results, interfaceStartIndex, interfaces.Length);

        if (interfaceStartIndex == 1)
            results[0] = sourceType;
        if (includingObjectType == 1)
            results[results.Length - 1] = typeof(object);

        return results;
    }

    /// <summary>Gets all declared and if specified, the base members too.</summary>
    public static IEnumerable<MemberInfo> GetAllMembers(this Type type, bool includeBase = false) =>
        type.GetMembers(t =>
            t.DeclaredMethods.Cast<MemberInfo>().Concat(
            t.DeclaredProperties.Cast<MemberInfo>().Concat(
            t.DeclaredFields.Cast<MemberInfo>())),
            includeBase);

    /// <summary>Returns true if the <paramref name="openGenericType"/> contains all generic parameters
    /// from <paramref name="genericParameters"/>.</summary>
    public static bool ContainsAllGenericTypeParameters(this Type openGenericType, Type[] genericParameters)
    {
        if (!openGenericType.IsOpenGeneric())
            return false;

        var matchedParamIndexesBitMask = ClearGenericParametersReferencedInConstraints(genericParameters);
        matchedParamIndexesBitMask = ClearMatchesFoundInGenericParameters(matchedParamIndexesBitMask, genericParameters, openGenericType.GetGenericArguments());

        // to return `true` we expect that bit mask hash all N bits set (where N is generic paramaters count)
        // e.g. for 2 generic parameters we expect `b11`, and if have `b10` bit mask we check that b10 + 1 >= b1 << 2 -> b11 >= b100 -> false
        // but for `b11` we have b11 + 1 >= b1 << 2 -> b100 >= b100 -> true
        return (matchedParamIndexesBitMask + 1) >= (1 << genericParameters.Length);
    }

    /// <summary>Where the `T` should be either Type or MethodInfo</summary>
    internal static T TryCloseGenericTypeOrMethod<T>(this T openGenericTypeOrMethod,
        Type[] typeArgs, Func<T, Type[], T> closeGeneric, bool throwCondition, int error, Request r)
    {
        try
        {
            return closeGeneric(openGenericTypeOrMethod, typeArgs);
        }
        catch (ArgumentException ex)
        {
            if (throwCondition)
                throw Throw.GetMatchedException(ErrorCheck.OperationThrows, error, openGenericTypeOrMethod, r, null, null, ex);
            return default(T);
        }
    }

    /// <summary>Returns true if type is closed generic: does not have open generic parameters, only closed/concrete ones.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static bool IsClosedGeneric(this Type type) => type.IsGenericType && !type.ContainsGenericParameters;

    /// <summary>Returns true if type if open generic: contains at list one open generic parameter. Could be generic type definition as well.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static bool IsOpenGeneric(this Type type) => type.IsGenericType && type.ContainsGenericParameters;

    /// <summary>Returns generic type definition if type is generic and null otherwise.</summary>
    /// [MethodImpl((MethodImplOptions)256)]
    public static Type GetGenericDefinitionOrNull(this Type type) => type.IsGenericType ? type.GetGenericTypeDefinition() : null;

    /// <summary>If type is array returns is element type, otherwise returns null.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static Type GetArrayElementTypeOrNull(this Type type) => type.IsArray ? type.GetElementType() : null;

    /// <summary>Checks if type is public or nested public in public type.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static bool IsPublicOrNestedPublic(this Type type) =>
        type.IsPublic || type.IsNestedPublic && type.DeclaringType.IsPublicOrNestedPublic();

    /// <summary>Returns true if type is static.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static bool IsStatic(this Type type) => type.IsAbstract && type.IsSealed;

    /// <summary>Returns true if type can be casted with conversion operators.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static bool HasConversionOperatorTo(this Type sourceType, Type targetType) =>
        sourceType.GetConversionOperatorOrNull(targetType) != null;

    /// <summary>Finds the conversion operator or returns null</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static MethodInfo GetConversionOperatorOrNull(this Type sourceType, Type targetType) =>
        sourceType.FindConvertOperator(sourceType, targetType) ??
        targetType.FindConvertOperator(sourceType, targetType);

    internal static MethodInfo FindConvertOperator(this Type type, Type sourceType, Type targetType)
    {
        if (sourceType == typeof(object) | targetType == typeof(object))
            return null;

        // conversion operators should be declared as static and public 
        var methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public);
        foreach (var m in methods)
            if (m.IsSpecialName && m.ReturnType == targetType)
            {
                var n = m.Name;
                if ((n == "op_Implicit" || n == "op_Explicit") &&
                    m.GetParameters()[0].ParameterType == sourceType)
                    return m;
            }

        return null;
    }

    /// <summary>Returns true if type is assignable to <paramref name="other"/> type.</summary>
    public static bool IsAssignableTo(this Type type, Type other) =>
        type != null && other != null && other.IsAssignableFrom(type);

    /// <summary>Returns true if type is assignable to <typeparamref name="T"/> type.</summary>
    public static bool IsAssignableTo<T>(this Type type) =>
        type != null && typeof(T).IsAssignableFrom(type);

    /// <summary>`to` should be the closed-generic type</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsAssignableVariantGenericTypeFrom(this Type to, Type from) =>
        from != to && from.IsGenericType && from.GetGenericTypeDefinition() == to.GetGenericTypeDefinition() && to.IsAssignableFrom(from);

    /// <summary>Returns true if provided type IsPrimitive in .Net terms, or enum, or string,
    /// or array of primitives if <paramref name="orArrayOfPrimitives"/> is true.</summary>
    public static bool IsPrimitive(this Type type, bool orArrayOfPrimitives = false) =>
        type.IsPrimitive || type.IsEnum || type == typeof(string) || orArrayOfPrimitives &&
        type.IsArray && type.GetElementType().IsPrimitive(true);

    /// <summary>Returns all attributes defined on <paramref name="type"/>.</summary>
    public static Attribute[] GetAttributes(this Type type, Type attributeType = null, bool inherit = false) =>
        type.GetCustomAttributes(attributeType ?? typeof(Attribute), inherit)
            // ReSharper disable once RedundantEnumerableCastCall
            .Cast<Attribute>() // required in .NET 4.5
            .ToArrayOrSelf();

    /// <summary>Recursive method to enumerate all input type and its base types for specific details.
    /// Details are returned by <paramref name="getMembers"/> delegate.</summary>
    public static IEnumerable<TMember> GetMembers<TMember>(
        this Type type, Func<TypeInfo, IEnumerable<TMember>> getMembers, bool includeBase = false)
    {
        var typeInfo = type.GetTypeInfo();
        var members = getMembers(typeInfo);
        if (!includeBase || typeInfo.BaseType == null || typeInfo.BaseType == typeof(object))
            return members;
        return members.Append(typeInfo.BaseType.GetMembers(getMembers, true));
    }

    /// <summary>Returns all public instance constructors for the type</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ConstructorInfo[] PublicConstructors(this Type type) =>
        type.GetConstructors(BindingFlags.Public | BindingFlags.Instance);

    /// <summary>Returns all instance constructors for the type</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static IEnumerable<ConstructorInfo> PublicAndNonPublicInstanceConstructors(this Type type) =>
        type.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);

    /// <summary>Enumerates all constructors from input type.</summary>
    public static IEnumerable<ConstructorInfo> Constructors(this Type type, bool includeNonPublic = false, bool includeStatic = false)
    {
        var flags = BindingFlags.Public | BindingFlags.Instance;
        if (includeNonPublic)
            flags |= BindingFlags.NonPublic;
        if (includeStatic)
            flags |= BindingFlags.Static;
        return type.GetConstructors(flags);
    }

    /// <summary>Searches and returns the first constructor by its signature, e.g. with the same number of parameters of the same type.</summary>
    public static ConstructorInfo GetConstructorOrNull(this Type type, bool includeNonPublic = false, params Type[] args)
    {
        var argsLength = args.Length;
        var flags = BindingFlags.Public | BindingFlags.Instance;
        if (includeNonPublic)
            flags |= BindingFlags.NonPublic;
        return type.GetConstructor(flags, null, args, null);
    }

    /// <summary>Searches and returns constructor by its signature.</summary>
    public static ConstructorInfo GetConstructorOrNull(this Type type, params Type[] args) =>
        type.GetConstructorOrNull(true, args);

    /// <summary>Searches and returns constructor by its signature, or throws if not found</summary>
    public static ConstructorInfo Constructor(this Type type, params Type[] args) =>
        type.GetConstructorOrNull(includeNonPublic: true, args: args).ThrowIfNull(Error.UnableToFindConstructorWithArgs, type, args);

    /// <summary>Returns single constructor otherwise (if no constructor or more than one) returns null.</summary>
    public static ConstructorInfo GetSingleConstructorOrNull(this Type type, bool includeNonPublic = false)
    {
        ConstructorInfo ctor = null;
        var ctors = Constructors(type, includeNonPublic, includeStatic: false).ToArrayOrSelf();
        for (var i = 0; i < ctors.Length; i++)
        {
            var x = ctors[i];
            if (ctor != null) // if multiple constructors
                return null;
            if (includeNonPublic || x.IsPublic)
                ctor = x;
        }

        return ctor;
    }

    /// <summary>Returns single constructor otherwise (if no or more than one) throws an exception</summary>
    public static ConstructorInfo SingleConstructor(this Type type, bool includeNonPublic = false) =>
        type.GetSingleConstructorOrNull(includeNonPublic).ThrowIfNull(Error.UnableToFindSingleConstructor, type, includeNonPublic);

    /// <summary>Looks up for single declared method with the specified name. Returns null if method is not found.</summary>
    public static MethodInfo GetSingleMethodOrNull(this Type type, string name, bool includeNonPublic = false)
    {
        if (includeNonPublic)
        {
            foreach (var method in type.GetTypeInfo().DeclaredMethods)
                if (method.Name == name)
                    return method;
        }
        else
        {
            foreach (var method in type.GetTypeInfo().DeclaredMethods)
                if (method.IsPublic && method.Name == name)
                    return method;
        }

        return null;
    }

    /// <summary>Looks for single declared (not inherited) method by name, and throws if not found.</summary>
    public static MethodInfo SingleMethod(this Type type, string name, bool includeNonPublic = false) =>
        type.GetSingleMethodOrNull(name, includeNonPublic).ThrowIfNull(
            Error.UndefinedMethodWhenGettingTheSingleMethod, name, type, includeNonPublic);

    /// <summary>Looks up for method with and specified parameter types.</summary>
    public static MethodInfo Method(this Type type, string name, params Type[] args) =>
        type.GetMethodOrNull(name, args).ThrowIfNull(
            Error.UndefinedMethodWhenGettingMethodWithSpecifiedParameters, name, type, args);

    /// <summary>Looks up for method with and specified parameter types.</summary>
    public static MethodInfo GetMethodOrNull(this Type type, string name, params Type[] paramTypes)
    {
        var pTypesCount = paramTypes.Length;
        var methods = type.GetTypeInfo().DeclaredMethods.ToArrayOrSelf();
        foreach (var method in methods)
        {
            if (method.Name == name)
            {
                var ps = method.GetParameters();
                if (ps.Length == pTypesCount)
                {
                    var p = 0;
                    for (; p < pTypesCount; ++p)
                    {
                        var paramType = ps[p].ParameterType;
                        if (paramType != paramTypes[p] && paramType.GetGenericDefinitionOrNull() != paramTypes[p])
                            break;
                    }

                    if (p == pTypesCount)
                        return method;
                }
            }
        }

        return null;
    }

    /// <summary>Returns property by name, including inherited. Or null if not found.</summary>
    public static PropertyInfo Property(this Type type, string name, bool includeBase = false) =>
        type.GetPropertyOrNull(name, includeBase).ThrowIfNull(Error.UndefinedPropertyWhenGettingProperty, name, type);

    /// <summary>Returns property by name, including inherited. Or null if not found.</summary>
    public static PropertyInfo GetPropertyOrNull(this Type type, string name, bool includeBase = false)
    {
        var props = type.GetTypeInfo().DeclaredProperties.ToArrayOrSelf();
        for (var i = 0; i < props.Length; i++)
        {
            var p = props[i];
            if (p.Name == name)
                return p;
        }

        return !includeBase ? null : type.BaseType?.GetPropertyOrNull(name, includeBase);
    }

    /// <summary>Returns field by name, including inherited. Or null if not found.</summary>
    public static FieldInfo Field(this Type type, string name, bool includeBase = false) =>
        type.GetFieldOrNull(name, includeBase).ThrowIfNull(Error.UndefinedFieldWhenGettingField, name, type);

    /// <summary>Returns field by name, including inherited. Or null if not found.</summary>
    public static FieldInfo GetFieldOrNull(this Type type, string name, bool includeBase = false)
    {
        var fields = type.GetTypeInfo().DeclaredFields.ToArrayOrSelf();
        for (var i = 0; i < fields.Length; i++)
        {
            var f = fields[i];
            if (f.Name == name)
                return f;
        }

        return !includeBase ? null : type.BaseType?.GetFieldOrNull(name, includeBase);
    }

    /// <summary>Returns type assembly.</summary>
    public static Assembly GetAssembly(this Type type) => type.Assembly;

    /// <summary>Is <c>true</c> for interface declared property explicitly implemented, e.g. <c>IInterface.Prop</c></summary>
    public static bool IsExplicitlyImplemented(this PropertyInfo property) => property.Name.Contains(".");

    /// <summary>Returns true if member is static, otherwise returns false.</summary>
    public static bool IsStatic(this MemberInfo member) =>
            member is MethodInfo method ? method.IsStatic
        : member is FieldInfo field ? field.IsStatic
        : member is PropertyInfo prop && !prop.IsExplicitlyImplemented() && prop.IsStatic(true);

    /// Find if property is static
    public static bool IsStatic(this PropertyInfo property, bool includeNonPublic = false)
    {
        // e.g.: set_Blah or get_Blah
        var propName = property.Name;
        var methods = property.DeclaringType.GetTypeInfo().DeclaredMethods.ToArrayOrSelf();
        for (var index = 0; index < methods.Length; index++)
        {
            var m = methods[index];
            if (m.IsSpecialName && (includeNonPublic || m.IsPublic))
            {
                var name = m.Name;
                var nameLength = name.Length;
                if (nameLength > 4 && name[3] == '_' && nameLength - 4 == propName.Length)
                {
                    var i = 4;
                    for (var j = 0; i < nameLength; i++, j++)
                        if (name[i] != propName[j])
                            break;
                    if (i == nameLength)
                        return m.IsStatic;
                }
            }
        }

        return false;
    }

    /// <summary>Return either <see cref="PropertyInfo.PropertyType"/>, or <see cref="FieldInfo.FieldType"/>, 
    /// <see cref="MethodInfo.ReturnType"/>.</summary>
    public static Type GetReturnTypeOrDefault(this MemberInfo member) =>
        member is ConstructorInfo ? member.DeclaringType
        : member is MethodInfo m ? m.ReturnType
        : member is PropertyInfo p ? p.PropertyType
        : ((FieldInfo)member).FieldType;

    /// <summary>Returns true if field is backing field for property.</summary>
    public static bool IsBackingField(this FieldInfo field) =>
        field.Name[0] == '<';

    /// <summary>Returns true if property is indexer: aka this[].</summary>
    public static bool IsIndexer(this PropertyInfo property) =>
        property.GetIndexParameters().Length != 0;

    /// <summary>Returns true if type is generated type of hoisted closure.</summary>
    public static bool IsClosureType(this Type type) =>
        type.Name.Contains("<>c__DisplayClass");

    /// <summary>Returns attributes defined for the member/method.</summary>
    public static IEnumerable<Attribute> GetAttributes(this MemberInfo member, Type attributeType = null, bool inherit = false) =>
        member.GetCustomAttributes(attributeType ?? typeof(Attribute), inherit).Cast<Attribute>();

    /// <summary>Returns attributes defined for parameter.</summary>
    public static IEnumerable<Attribute> GetAttributes(this ParameterInfo parameter, Type attributeType = null, bool inherit = false) =>
        parameter.GetCustomAttributes(attributeType ?? typeof(Attribute), inherit).Cast<Attribute>();

    /// <summary>Get types from assembly that are loaded successfully.
    /// Hacks the <see cref="ReflectionTypeLoadException"/>to get failing to load types metadata.</summary>
    public static Type[] GetLoadedTypes(this Assembly assembly)
    {
        try
        {
            return Portable.GetAssemblyTypes(assembly).ToArrayOrSelf();
        }
        catch (ReflectionTypeLoadException ex)
        {
            return ex.Types.Where(type => type != null).ToArray();
        }
    }

    private static int ClearGenericParametersReferencedInConstraints(Type[] genericParams)
    {
        var matchedParamIndexesBitMask = 0;
        for (var i = 0; i < genericParams.Length; i++)
        {
            var genericParam = genericParams[i];
            if (genericParam == null)
                continue;

            var genericConstraints = genericParam.GetGenericParameterConstraints();
            for (var j = 0; j < genericConstraints.Length; j++)
            {
                var genericConstraint = genericConstraints[j];
                if (genericConstraint.IsOpenGeneric())
                {
                    var constraintGenericParams = genericConstraint.GetGenericArguments();
                    for (var k = 0; k < constraintGenericParams.Length; k++)
                    {
                        var constraintGenericParam = constraintGenericParams[k];
                        if (constraintGenericParam != genericParam)
                        {
                            for (var g = 0; g < genericParams.Length; ++g)
                                if (genericParams[g] == constraintGenericParam)
                                {
                                    matchedParamIndexesBitMask |= 1 << g;
                                    break;
                                }
                        }
                    }
                }
            }
        }
        return matchedParamIndexesBitMask;
    }

    private static int ClearMatchesFoundInGenericParameters(int matchedParamIndexesBitMask, Type[] genericParams, Type[] genericArgs)
    {
        for (var i = 0; i < genericArgs.Length; i++)
        {
            var genericArg = genericArgs[i];
            if (genericArg.IsGenericParameter)
            {
                for (var j = 0; j < genericParams.Length; ++j)
                    if (genericParams[j] == genericArg)
                    {
                        matchedParamIndexesBitMask |= 1 << j;
                        break;
                    }
            }
            else if (genericArg.IsOpenGeneric())
                matchedParamIndexesBitMask = ClearMatchesFoundInGenericParameters(matchedParamIndexesBitMask, genericParams, genericArg.GetGenericArguments());
        }
        return matchedParamIndexesBitMask;
    }

    internal static T GetDefault<T>() => default(T);
    internal static readonly MethodInfo GetDefaultMethod =
        typeof(ReflectionTools).SingleMethod(nameof(GetDefault), true);

    /// <summary>Creates default(T) expression for provided <paramref name="type"/>.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static Expression GetDefaultValueExpression(this Type type) =>
        !type.IsValueType
            ? ContainerTools.NullTypeConstant
            : Call(GetDefaultMethod.MakeGenericMethod(type));

    internal static bool EmitConvertObjectTo(this ILGenerator il, Type t)
    {
        if (t != typeof(object))
            if (t.IsValueType)
                il.Demit(OpCodes.Unbox_Any, t);
#if NETFRAMEWORK
            // The cast is required only for Full CLR starting from NET45, e.g.
            // .NET Core does not seem to care about verifiability and it's faster without the explicit cast
            else
                il.Demit(OpCodes.Castclass, t);
#endif
        return true;
    }

    /// <summary>Optimized version of the map GetValueOrDefault for the Type key and object value</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static object GetValueOrDefault(this ImHashMap<Type, object> map, Type t) =>
        map.GetValueOrDefaultByReferenceEquals(RuntimeHelpers.GetHashCode(t), t);

    /// <summary>Optimized version of the map AddOrUpdate for the Type key and object value</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ImHashMap<Type, object> AddOrUpdate(this ImHashMap<Type, object> map, Type t, object value) =>
        map.AddOrUpdateByReferenceEquals(RuntimeHelpers.GetHashCode(t), t, value);

    [MethodImpl((MethodImplOptions)256)]
    internal static ImHashMapEntry<Type, object> Entry(this Type t, object value) =>
        ImHashMap.Entry(RuntimeHelpers.GetHashCode(t), t, value);
}

/// <summary>Provides pretty printing/debug view for number of types using the FEC CodePrinter.</summary>
public static class PrintTools
{
    /// <summary>Control the type Namespace display</summary>
    public static bool StripNamespace
#if DEBUG
        = true;
#else
        = false;
#endif
    /// <summary>Controls the final type display given the source type and ts calculated string representation</summary>
    public static Func<Type, string, string> TypePrinter
#if DEBUG
        = CodePrinter.PrintTypeStripOuterClasses;
#else
        // strip the System namespaces from the names for brevity
        = (t, s) => t.Namespace?.StartsWith("System") == true && s.StartsWith(t.Namespace) ? s.Substring(t.Namespace.Length + 1) : s;
#endif

    /// <summary>Prints input object by using corresponding Print methods for know types.</summary>
    public static StringBuilder Print(this StringBuilder s, object x) =>
        x is IPrintable p
            ? p.Print(s, static (s_, a) => s_.Append(a.ToCode(null, StripNamespace, TypePrinter)))
            : s.Append(x.ToCode(null, StripNamespace, TypePrinter));

    /// <summary>Prints input object by using corresponding Print methods for know types.</summary>
    public static string Print(this object x) => new StringBuilder().Print(x).ToString();
}

// todo: @wip @comptime
/// <summary>Put it on the method like `GetContainerWithRegistrations` to generate CompileTimeDI</summary>
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
public class CompileTimeRegisterAttribute : Attribute
{
}

/// <summary>Ports some methods from .Net 4.0/4.5</summary>
public static partial class Portable
{
    /// <summary>Portable version of Assembly.GetTypes or Assembly.DefinedTypes.</summary>
    public static IEnumerable<Type> GetAssemblyTypes(Assembly a) => _getAssemblyTypes.Value(a);

    private static readonly Lazy<Func<Assembly, IEnumerable<Type>>> _getAssemblyTypes = Lazy.Of(GetAssemblyTypesMethod);
    private static Func<Assembly, IEnumerable<Type>> GetAssemblyTypesMethod()
    {
        var asmExpr = ParameterOf<Assembly>("a");

        var definedTypesProperty = typeof(Assembly).GetTypeInfo().GetDeclaredProperty("DefinedTypes");
        if (definedTypesProperty != null)
            return definedTypesProperty.PropertyType == typeof(IEnumerable<TypeInfo>)
                ? a => ((IEnumerable<TypeInfo>)definedTypesProperty.GetValue(a, null)).Select(t => t.AsType())
                : a => (IEnumerable<Type>)definedTypesProperty.GetValue(a, null);

        var getTypesMethod = typeof(Assembly).GetTypeInfo().GetDeclaredMethod("GetTypes");
        return a => (IEnumerable<Type>)getTypesMethod.Invoke(a, Empty<object>());
    }

    /// <summary>Portable version of PropertyInfo.GetGetMethod.</summary>
    public static MethodInfo GetGetMethodOrNull(this PropertyInfo p, bool includeNonPublic = false)
    {
        var name = "get_" + p.Name;
        var methods = p.DeclaringType.GetTypeInfo().DeclaredMethods.ToArrayOrSelf();
        for (var i = 0; i < methods.Length; i++)
        {
            var m = methods[i];
            if (m.IsSpecialName && (includeNonPublic || m.IsPublic) && m.Name == name)
                return m;
        }

        return null;
    }

    /// <summary>Portable version of PropertyInfo.GetSetMethod.</summary>
    public static MethodInfo GetSetMethodOrNull(this PropertyInfo p, bool includeNonPublic = false)
    {
        var name = "set_" + p.Name;
        var methods = p.DeclaringType.GetTypeInfo().DeclaredMethods.ToArrayOrSelf();
        for (var i = 0; i < methods.Length; i++)
        {
            var m = methods[i];
            if (m.IsSpecialName && (includeNonPublic || m.IsPublic) && m.Name == name)
                return m;
        }

        return null;
    }

    private static readonly Lazy<Func<int>> _getEnvCurrentManagedThreadId = Lazy.Of<Func<int>>(() =>
    {
        var method = typeof(Environment).GetMethodOrNull("get_CurrentManagedThreadId", Empty<Type>());
        if (method == null)
            return null;
        return () => (int)method.Invoke(null, (Empty<object>()));
    });

    /// <summary>Returns managed Thread ID either from Environment or Thread.CurrentThread whichever is available.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int GetCurrentManagedThreadID()
    {
        var resultID = -1;
        GetCurrentManagedThreadID(ref resultID);
        if (resultID == -1)
            resultID = _getEnvCurrentManagedThreadId.Value();
        return resultID;
    }

    static partial void GetCurrentManagedThreadID(ref int threadID);
}


#if SUPPORTS_ASYNC_LOCAL
/// <summary>Stores scopes propagating through async-await boundaries.</summary>
public sealed class AsyncExecutionFlowScopeContext : IScopeContext
{
    /// <summary>Statically known name of root scope in this context.</summary>
    public static readonly string ScopeContextName = typeof(AsyncExecutionFlowScopeContext).FullName;

    /// It is fine to use a default instance, cause the async local scope are actually a static one
    public static readonly AsyncExecutionFlowScopeContext Default = new AsyncExecutionFlowScopeContext();

    private static readonly AsyncLocal<IScope> _ambientScope = new AsyncLocal<IScope>();

    /// <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
    /// <returns>Current scope or null.</returns>
    public IScope GetCurrentOrDefault() => _ambientScope.Value;

    /// <summary>Changes current scope using provided delegate. Delegate receives current scope as input and  should return new current scope.</summary>
    /// <param name="changeCurrentScope">Delegate to change the scope.</param>
    /// <remarks>Important: <paramref name="changeCurrentScope"/> may be called multiple times in concurrent environment.
    /// Make it predictable by removing any side effects.</remarks>
    /// <returns>New current scope. It is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
    public IScope SetCurrent(SetCurrentScopeHandler changeCurrentScope) =>
        _ambientScope.Value = changeCurrentScope(_ambientScope.Value);

    /// <summary>Nothing to dispose.</summary>
    public void Dispose() { }
}
#endif

#if !SUPPORTS_ASYNC_LOCAL && !NETSTANDARD2_0
/// <summary>Stores scopes propagating through async-await boundaries.</summary>
public sealed class AsyncExecutionFlowScopeContext : IScopeContext
{
    /// <summary>Statically known name of root scope in this context.</summary>
    public static readonly string ScopeContextName = typeof(AsyncExecutionFlowScopeContext).FullName;

    /// It is fine to use a default instance, cause the async local scope are actually a static one
    public static readonly AsyncExecutionFlowScopeContext Default = new AsyncExecutionFlowScopeContext();

    [Serializable]
    internal sealed class ScopeEntry<T> : MarshalByRefObject
    {
        public readonly T Value;
        public ScopeEntry(T value) { Value = value; }
    }

    private static int _seedKey;
    private readonly string _scopeEntryKey = ScopeContextName + Interlocked.Increment(ref _seedKey);

    /// <summary>Returns current scope or null if no ambient scope available at the moment.</summary>
    /// <returns>Current scope or null.</returns>
    public IScope GetCurrentOrDefault() =>
        ((ScopeEntry<IScope>)System.Runtime.Remoting.Messaging.CallContext.LogicalGetData(_scopeEntryKey))?.Value;

    /// <summary>Changes current scope using provided delegate. Delegate receives current scope as input and  should return new current scope.</summary>
    /// <param name="changeCurrentScope">Delegate to change the scope.</param>
    /// <remarks>Important: <paramref name="changeCurrentScope"/> may be called multiple times in concurrent environment.
    /// Make it predictable by removing any side effects.</remarks>
    /// <returns>New current scope. It is convenient to use method in "using (var newScope = ctx.SetCurrent(...))".</returns>
    public IScope SetCurrent(SetCurrentScopeHandler changeCurrentScope)
    {
        var newScope = changeCurrentScope(GetCurrentOrDefault());
        var scopeEntry = newScope == null ? null : new ScopeEntry<IScope>(newScope);
        System.Runtime.Remoting.Messaging.CallContext.LogicalSetData(_scopeEntryKey, scopeEntry);
        return newScope;
    }

    /// <summary>Nothing to dispose.</summary>
    public void Dispose() { }
}
#endif

/// <summary>Common abstraction to run the tests</summary>
public interface ITest
{
    /// <summary>Runs the tests and should return the number of running tests</summary>
    int Run();
}
#nullable restore
