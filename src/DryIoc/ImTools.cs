// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2021 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// ReSharper disable once InconsistentNaming

namespace DryIoc.ImTools
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Diagnostics;
    using System.Runtime.CompilerServices; // For [MethodImpl(AggressiveInlining)]

    /// <summary>Helpers for functional composition</summary>
    public static class Fun
    {
        /// <summary>
        /// Always a true condition.
        /// </summary> 
        public static bool Always<T>(T _) => true;

        /// <summary>
        /// Identity function returning passed argument as result.
        /// </summary> 
        public static T Id<T>(T x) => x;

        /// <summary>
        /// Forward pipe operator (`|>` in F#)
        /// </summary> 
        public static R To<T, R>(this T x, Func<T, R> map) => map(x);

        /// <summary>
        /// Forward pipe operator (`|>` in F#) with the additional state A for two arguments function
        /// </summary> 
        public static R To<T, S, R>(this T x, S state, Func<T, S, R> map) => map(x, state);

        /// <summary>
        /// Cast to the R type with the forward pipe operator (`|>` in F#)
        /// </summary> 
        public static R To<R>(this object x) => (R)x;

        /// <summary>
        /// Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value
        /// </summary> 
        public static T Do<T>(this T x, Action<T> effect)
        {
            effect(x);
            return x;
        }

        /// <summary>
        /// Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value and the state object
        /// </summary> 
        public static T Do<T, S>(this T x, S state, Action<T, S> effect)
        {
            effect(x, state);
            return x;
        }

        /// <summary>
        /// Lifts argument to Func without allocations ignoring the first argument.
        /// For example if you have `Func{T, R} = _ => instance`,
        /// you may rewrite it without allocations as `instance.ToFunc{A, R}`
        /// </summary> 
        public static R ToFunc<T, R>(this R result, T ignoredArg) => result;

        /// <summary>Performant swapper</summary>
        [MethodImpl(256)]
        public static void Swap<T>(ref T a, ref T b)
        {
            var t = a;
            a = b;
            b = t;
        }
    }

    /// <summary>Helpers for lazy instantiations</summary>
    public static class Lazy
    {
        /// <summary>Provides result type inference for creation of lazy.</summary>
        public static Lazy<T> Of<T>(Func<T> valueFactory) => new Lazy<T>(valueFactory);
    }

    /// <summary>Just a helper state with the number of mutable fields with the nice names ;) Maybe used together with Fold or other methods required state</summary>
    public sealed class St<A> 
    {
        /// <summary>A</summary>
        public A a;

        /// <summary>Puts the pooled instance back replacing the old one</summary>
        [MethodImpl((MethodImplOptions)256)]
        public void Pool() => Pooled = this;

        /// <summary>Puts the pooled instance back replacing the old one</summary>
        [MethodImpl((MethodImplOptions)256)]
        public void Reset() 
        {
            a = default;
            Pooled = this; // we don't need to do the atomic update here because we don't care what instance is ended up to be pooled
        }

        /// <summary>Puts the pooled instance back replacing the old one</summary>
        [MethodImpl((MethodImplOptions)256)]
        public A ResetButGetA() 
        {
            var a1 = a;
            a = default;
            Pooled = this; // we don't need to do the atomic update here because we don't care what instance is ended up to be pooled
            return a1;
        }

        internal static St<A> Pooled;
    } 

    /// <summary>Just a helper state with the number of mutable fields with the nice names ;) Maybe used together with Fold or other methods required state</summary>
    public sealed class St<A, B> 
    {
        /// <summary>A</summary>
        public A a;
        /// <summary>B</summary>
        public B b;

        /// <summary>Puts the pooled instance back replacing the old one</summary>
        [MethodImpl((MethodImplOptions)256)]
        public St<A, B> Pool() => Pooled = this;

        /// <summary>Puts the pooled instance back replacing the old one</summary>
        [MethodImpl((MethodImplOptions)256)]
        public void Reset() 
        {
            a = default;
            b = default;
            Pooled = this; // we don't need to do the atomic update here because we don't care what instance is ended up to be pooled
        }

        /// <summary>Puts the pooled instance back replacing the old one</summary>
        [MethodImpl((MethodImplOptions)256)]
        public A ResetButGetA() 
        {
            var a1 = a;
            a = default;
            b = default;
            Pooled = this; // we don't need to do the atomic update here because we don't care what instance is ended up to be pooled
            return a1;
        }

        /// <summary>Puts the pooled instance back replacing the old one</summary>
        [MethodImpl((MethodImplOptions)256)]
        public B ResetButGetB() 
        {
            var b1 = b;
            a = default;
            b = default;
            Pooled = this; // we don't need to do the atomic update here because we don't care what instance is ended up to be pooled
            return b1;
        }

        internal static St<A, B> Pooled;
    } 

    /// <summary>State factory and helper methods</summary>
    public static class St 
    {
        /// <summary>Creates the state out of the passed arguments</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static St<A> Of<A>(A a) => new St<A> { a = a };

        /// <summary>Atomically pops the pooled instance (if exist) or creates the new one and sets the fields to the passed arguments</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static St<A> Rent<A>(A a) 
        {
            var st = Interlocked.Exchange(ref St<A>.Pooled, null) ?? new St<A>();
            st.a = a;
            return st;
        } 

        /// <summary>Creates the state out of the passed arguments</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static St<A, B> Of<A, B>(A a, B b) => new St<A, B> { a = a, b = b };

        /// <summary>Atomically pops the pooled instance (if exist) or creates the new one and sets the fields to the passed arguments</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static St<A, B> Rent<A, B>(A a, B b) 
        {
            var st = Interlocked.Exchange(ref St<A, B>.Pooled, null) ?? new St<A, B>();
            st.a = a; st.b = b;
            return st;
        } 
    }

    /// <summary>Replacement for `Void` type which can be used as a type argument and value.
    /// In traditional functional languages this type is a singleton empty record type,
    /// e.g. `()` in Haskell https://en.wikipedia.org/wiki/Unit_type </summary>
    public struct Unit : IEquatable<Unit>
    {
        /// Singleton unit value - making it a lower-case so you could import `using static ImTools.Unit;` and write `return unit;`
        public static readonly Unit unit = new Unit();

        /// <inheritdoc />
        public override string ToString() => "(unit)";

        /// Equals to any other Unit
        public bool Equals(Unit other) => true;

        /// <inheritdoc />
        public override bool Equals(object obj) => obj is Unit;

        /// Using type hash code for the value
        public override int GetHashCode() => typeof(Unit).GetHashCode();
    }

    /// Simple value provider interface - useful for the type pattern matching via `case I{T} x: ...`
    public interface I<out T>
    {
        /// The value in this case ;)
        T Value { get; }
    }

    /// Helpers for `Is` and `Union`
    public static class UnionTools
    {
        /// Pretty prints the Union using the type information
        internal static string ToString<TName, T>(T value, string prefix = "case(", string suffix = ")")
        {
            if (typeof(TName) == typeof(Unit))
                return prefix + value + suffix;

            var typeName = typeof(TName).Name;
            var i = typeName.IndexOf('`');
            var name = i == -1 ? typeName : typeName.Substring(0, i);
            return name + prefix + value + suffix;
        }
    }

    /// Wraps the `T` in a typed `TItem` struct value in a one-line declaration,
    /// so the <c><![CDATA[class Name : Case<Name, string>]]></c>
    /// is different from the <c><![CDATA[class Address : Case<Address, string>]]></c> 
    public abstract class Item<TItem, T> where TItem : Item<TItem, T>
    {
        /// Creation method for the consistency with other types
        public static item Of(T x) => new item(x);

        /// Nested structure that hosts a value.
        /// All nested types by convention here are lowercase
        public readonly struct item : IEquatable<item>, I<T>
        {
            /// <inheritdoc />
            public T Value { [MethodImpl((MethodImplOptions)256)] get => Item; }

            /// The value
            public readonly T Item;

            /// Constructor
            public item(T x) => Item = x;

            /// <inheritdoc />
            public bool Equals(item other) => EqualityComparer<T>.Default.Equals(Value, other.Value);

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is item c && Equals(c);

            /// <inheritdoc />
            public override int GetHashCode() => EqualityComparer<T>.Default.GetHashCode(Value);

            /// <inheritdoc />
            public override string ToString() => UnionTools.ToString<TItem, T>(Value);
        }
    }

    /// Item without the data payload
    public abstract class Item<TItem> where TItem : Item<TItem>
    {
        /// Single item value
        public static readonly item Value = new item();

        /// Nested structure that hosts a value.
        /// All nested types by convention here are lowercase
        public readonly struct item : IEquatable<item>
        {
            /// <inheritdoc />
            public bool Equals(item other) => true;

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is item;

            /// <inheritdoc />
            public override int GetHashCode() => typeof(TItem).GetHashCode();

            /// <inheritdoc />
            public override string ToString() => "(" + typeof(TItem).Name + ")";
        }
    }

    /// Wraps the `T` in a named `TBox` class in a one-line declaration,
    /// so the <c><![CDATA[class Name : Box<Name, string>]]></c>
    /// is different from the <c><![CDATA[class Address : Box<Address, string>]]></c> 
    public abstract class Box<TBox, T> : I<T>, IEquatable<Box<TBox, T>>
        where TBox : Box<TBox, T>, new()
    {
        /// Wraps the value
        public static TBox Of(T x) => new TBox { Value = x };

        /// <inheritdoc />
        public T Value { get; private set; }

        /// <inheritdoc />
        public bool Equals(Box<TBox, T> other) =>
            other != null && EqualityComparer<T>.Default.Equals(Value, other.Value);

        /// <inheritdoc />
        public override bool Equals(object obj) => obj is Box<TBox, T> c && Equals(c);

        // ReSharper disable once NonReadonlyMemberInGetHashCode
        /// <inheritdoc />
        public override int GetHashCode() => EqualityComparer<T>.Default.GetHashCode(Value);

        /// <inheritdoc />
        public override string ToString() => UnionTools.ToString<TBox, T>(Value, "box(");
    }

    /// Unnamed discriminated union (with Empty name), shorter name for simplified inline usage
    public class U<T1, T2> : Union<Unit, T1, T2> { }

    /// Discriminated union
    public abstract class Union<TUnion, T1, T2>
    {
        /// To tag the cases with enum value for efficient pattern matching of required -
        /// otherwise we need to use `is CaseN` pattern or similar which is less efficient
        public enum Tag : byte
        {
            /// Tags Case1
            Case1,
            /// Tags Case2
            Case2
        }

        /// The base interface for the cases to operate.
        /// The naming is selected to start from the lower letter, cause we need to use the nested type.
        /// It is an unusual case, that's why using the __union__ will be fine to highlight this.
        // ReSharper disable once InconsistentNaming
        public interface union
        {
            /// The tag
            Tag Tag { get; }

            /// Matches the union cases to the R value
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2);
        }

        /// Creates the respective case
        public static union Of(T1 x) => new case1(x);

        /// Creates the respective case
        public static union Of(T2 x) => new case2(x);

        /// Wraps the respective case
        public readonly struct case1 : union, IEquatable<case1>, I<T1>
        {
            /// Implicit conversion
            public static implicit operator case1(T1 x) => new case1(x);

            /// <inheritdoc />
            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            /// <inheritdoc />
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2) => map1(Case);

            /// <inheritdoc />
            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            /// The case value
            public readonly T1 Case;

            /// Wraps the value
            public case1(T1 x) => Case = x;

            /// <inheritdoc />
            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Value, other.Value);

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is case1 x && Equals(x);

            /// <inheritdoc />
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Value);

            /// <inheritdoc />
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Value);
        }

        /// Wraps the respective case
        public readonly struct case2 : union, IEquatable<case2>, I<T2>
        {
            /// Conversion
            public static implicit operator case2(T2 x) => new case2(x);

            /// <inheritdoc />
            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }

            /// <inheritdoc />
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2) => map2(Value);

            /// <inheritdoc />
            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            /// The case value
            public readonly T2 Case;

            /// Wraps the value
            public case2(T2 x) => Case = x;

            /// <inheritdoc />
            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Value, other.Value);

            /// <inheritdoc />
            public override bool Equals(object obj) => obj is case2 x && Equals(x);

            /// <inheritdoc />
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Value);

            /// <inheritdoc />
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Value);
        }
    }

#pragma warning disable 1591
    public class U<T1, T2, T3> : Union<Unit, T1, T2, T3> { }

    public abstract class Union<TUnion, T1, T2, T3>
    {
        public enum Tag : byte { Case1, Case2, Case3 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }
    }

    public class U<T1, T2, T3, T4> : Union<Unit, T1, T2, T3, T4> { }
    public abstract class Union<TUnion, T1, T2, T3, T4>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }
    }

    public class U<T1, T2, T3, T4, T5> : Union<Unit, T1, T2, T3, T4, T5> { }
    public abstract class Union<TUnion, T1, T2, T3, T4, T5>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }
    }

    public class U<T1, T2, T3, T4, T5, T6> : Union<Unit, T1, T2, T3, T4, T5, T6> { }
    public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);
        public static union Of(T6 x) => new case6(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }

        public struct case6 : union, IEquatable<case6>, I<T6>
        {
            public static implicit operator case6(T6 x) => new case6(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6) => map6(Case);

            public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T6 Case;
            public case6(T6 x) => Case = x;

            public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
        }
    }

    public class U<T1, T2, T3, T4, T5, T6, T7> : Union<Unit, T1, T2, T3, T4, T5, T6, T7> { }
    public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);
        public static union Of(T6 x) => new case6(x);
        public static union Of(T7 x) => new case7(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }

        public struct case6 : union, IEquatable<case6>, I<T6>
        {
            public static implicit operator case6(T6 x) => new case6(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map6(Case);

            public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T6 Case;
            public case6(T6 x) => Case = x;

            public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
        }

        public struct case7 : union, IEquatable<case7>, I<T7>
        {
            public static implicit operator case7(T7 x) => new case7(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7) => map7(Case);

            public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T7 Case;
            public case7(T7 x) => Case = x;

            public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case7 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
        }
    }

    public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7, Case8 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);
        public static union Of(T6 x) => new case6(x);
        public static union Of(T7 x) => new case7(x);
        public static union Of(T8 x) => new case8(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }

        public struct case6 : union, IEquatable<case6>, I<T6>
        {
            public static implicit operator case6(T6 x) => new case6(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map6(Case);

            public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T6 Case;
            public case6(T6 x) => Case = x;

            public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
        }

        public struct case7 : union, IEquatable<case7>, I<T7>
        {
            public static implicit operator case7(T7 x) => new case7(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map7(Case);

            public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T7 Case;
            public case7(T7 x) => Case = x;

            public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case7 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
        }

        public struct case8 : union, IEquatable<case8>, I<T8>
        {
            public static implicit operator case8(T8 x) => new case8(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case8; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8) => map8(Case);

            public T8 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T8 Case;
            public case8(T8 x) => Case = x;

            public bool Equals(case8 other) => EqualityComparer<T8>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case8 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T8>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T8>(Case);
        }
    }

    public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7, Case8, Case9 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, 
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);
        public static union Of(T6 x) => new case6(x);
        public static union Of(T7 x) => new case7(x);
        public static union Of(T8 x) => new case8(x);
        public static union Of(T9 x) => new case9(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, 
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, 
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, 
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, 
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, 
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }

        public struct case6 : union, IEquatable<case6>, I<T6>
        {
            public static implicit operator case6(T6 x) => new case6(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, 
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map6(Case);

            public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T6 Case;
            public case6(T6 x) => Case = x;

            public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
        }

        public struct case7 : union, IEquatable<case7>, I<T7>
        {
            public static implicit operator case7(T7 x) => new case7(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, 
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map7(Case);

            public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T7 Case;
            public case7(T7 x) => Case = x;

            public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case7 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
        }

        public struct case8 : union, IEquatable<case8>, I<T8>
        {
            public static implicit operator case8(T8 x) => new case8(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case8; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5, 
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map8(Case);

            public T8 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T8 Case;
            public case8(T8 x) => Case = x;

            public bool Equals(case8 other) => EqualityComparer<T8>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case8 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T8>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T8>(Case);
        }

        public struct case9 : union, IEquatable<case9>, I<T9>
        {
            public static implicit operator case9(T9 x) => new case9(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case9; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9) => map9(Case);

            public T9 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T9 Case;
            public case9(T9 x) => Case = x;

            public bool Equals(case9 other) => EqualityComparer<T9>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case9 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T9>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T9>(Case);
        }
    }

    public abstract class Union<TUnion, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
    {
        public enum Tag : byte { Case1, Case2, Case3, Case4, Case5, Case6, Case7, Case8, Case9, Case10 }

        public interface union
        {
            Tag Tag { get; }
            R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10);
        }

        public static union Of(T1 x) => new case1(x);
        public static union Of(T2 x) => new case2(x);
        public static union Of(T3 x) => new case3(x);
        public static union Of(T4 x) => new case4(x);
        public static union Of(T5 x) => new case5(x);
        public static union Of(T6 x) => new case6(x);
        public static union Of(T7 x) => new case7(x);
        public static union Of(T8 x) => new case8(x);
        public static union Of(T9 x) => new case9(x);
        public static union Of(T10 x) => new case10(x);

        public struct case1 : union, IEquatable<case1>, I<T1>
        {
            public static implicit operator case1(T1 x) => new case1(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case1; }

            [MethodImpl((MethodImplOptions)256)]
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map1(Case);

            public T1 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T1 Case;
            public case1(T1 x) => Case = x;

            public bool Equals(case1 other) => EqualityComparer<T1>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case1 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T1>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T1>(Case);
        }

        public struct case2 : union, IEquatable<case2>, I<T2>
        {
            public static implicit operator case2(T2 x) => new case2(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case2; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map2(Case);

            public T2 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T2 Case;
            public case2(T2 x) => Case = x;

            public bool Equals(case2 other) => EqualityComparer<T2>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case2 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T2>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T2>(Case);
        }

        public struct case3 : union, IEquatable<case3>, I<T3>
        {
            public static implicit operator case3(T3 x) => new case3(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case3; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map3(Case);

            public T3 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T3 Case;
            public case3(T3 x) => Case = x;

            public bool Equals(case3 other) => EqualityComparer<T3>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case3 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T3>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T3>(Case);
        }

        public struct case4 : union, IEquatable<case4>, I<T4>
        {
            public static implicit operator case4(T4 x) => new case4(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case4; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map4(Case);

            public T4 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T4 Case;
            public case4(T4 x) => Case = x;

            public bool Equals(case4 other) => EqualityComparer<T4>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case4 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T4>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T4>(Case);
        }

        public struct case5 : union, IEquatable<case5>, I<T5>
        {
            public static implicit operator case5(T5 x) => new case5(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case5; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map5(Case);

            public T5 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T5 Case;
            public case5(T5 x) => Case = x;

            public bool Equals(case5 other) => EqualityComparer<T5>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case5 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T5>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T5>(Case);
        }

        public struct case6 : union, IEquatable<case6>, I<T6>
        {
            public static implicit operator case6(T6 x) => new case6(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case6; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map6(Case);

            public T6 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T6 Case;
            public case6(T6 x) => Case = x;

            public bool Equals(case6 other) => EqualityComparer<T6>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case6 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T6>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T6>(Case);
        }

        public struct case7 : union, IEquatable<case7>, I<T7>
        {
            public static implicit operator case7(T7 x) => new case7(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case7; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map7(Case);

            public T7 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T7 Case;
            public case7(T7 x) => Case = x;

            public bool Equals(case7 other) => EqualityComparer<T7>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case7 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T7>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T7>(Case);
        }

        public struct case8 : union, IEquatable<case8>, I<T8>
        {
            public static implicit operator case8(T8 x) => new case8(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case8; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map8(Case);

            public T8 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T8 Case;
            public case8(T8 x) => Case = x;

            public bool Equals(case8 other) => EqualityComparer<T8>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case8 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T8>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T8>(Case);
        }

        public struct case9 : union, IEquatable<case9>, I<T9>
        {
            public static implicit operator case9(T9 x) => new case9(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case9; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map9(Case);

            public T9 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T9 Case;
            public case9(T9 x) => Case = x;

            public bool Equals(case9 other) => EqualityComparer<T9>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case9 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T9>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T9>(Case);
        }

        public struct case10 : union, IEquatable<case10>, I<T10>
        {
            public static implicit operator case10(T10 x) => new case10(x);

            public Tag Tag { [MethodImpl((MethodImplOptions)256)] get => Tag.Case10; }
            public R Match<R>(Func<T1, R> map1, Func<T2, R> map2, Func<T3, R> map3, Func<T4, R> map4, Func<T5, R> map5,
                Func<T6, R> map6, Func<T7, R> map7, Func<T8, R> map8, Func<T9, R> map9, Func<T10, R> map10) => map10(Case);

            public T10 Value { [MethodImpl((MethodImplOptions)256)] get => Case; }

            public readonly T10 Case;
            public case10(T10 x) => Case = x;

            public bool Equals(case10 other) => EqualityComparer<T10>.Default.Equals(Case, other.Case);
            public override bool Equals(object obj) => obj is case10 x && Equals(x);
            public override int GetHashCode() => EqualityComparer<T10>.Default.GetHashCode(Case);
            public override string ToString() => UnionTools.ToString<TUnion, T10>(Case);
        }
    }

#pragma warning restore 1591

    /// <summary>Methods to work with immutable arrays and some sugar.</summary>
    public static class ArrayTools
    {
        private static class EmptyArray<T>
        {
            public static readonly T[] Value = new T[0];
        }

        /// <summary>Returns singleton empty array of provided type.</summary> 
        /// <typeparam name="T">Array item type.</typeparam> <returns>Empty array.</returns>
        public static T[] Empty<T>() => EmptyArray<T>.Value;

        /// <summary>Wraps item in array.</summary>
        public static T[] One<T>(this T one) => new[] { one };

        /// <summary>Returns true if array is null or have no items.</summary> <typeparam name="T">Type of array item.</typeparam>
        /// <param name="source">Source array to check.</param> <returns>True if null or has no items, false otherwise.</returns>
        public static bool IsNullOrEmpty<T>(this T[] source) => source == null || source.Length == 0;

        /// <summary>Returns empty array instead of null, or source array otherwise.</summary> <typeparam name="T">Type of array item.</typeparam>
        public static T[] EmptyIfNull<T>(this T[] source) => source ?? Empty<T>();

        /// Returns source enumerable if it is array, otherwise converts source to array or an empty array if null.
        public static T[] ToArrayOrSelf<T>(this IEnumerable<T> source) =>
            source == null ? Empty<T>() : (source as T[] ?? source.ToArray());

        /// Returns source enumerable if it is list, otherwise converts source to IList or an empty array if null.
        public static IList<T> ToListOrSelf<T>(this IEnumerable<T> source) =>
            source == null ? Empty<T>() : source as IList<T> ?? source.ToList();

        /// <summary>Array copy</summary>
        public static T[] Copy<T>(this T[] items)
        {
            if (items == null || items.Length == 0)
                return items;
            var count = items.Length;
            var copy = new T[count];
            if (count < 6)
                for (var i = 0; i < count; ++i)
                    copy[i] = items[i];
            else
                Array.Copy(items, copy, count);
            return copy;
        }

        /// <summary>Array copy without checking the items for the null or the emptyness</summary>
        public static T[] CopyNonEmpty<T>(this T[] items)
        {
            var count = items.Length;
            var copy = new T[count];
            if (count < 6)
                for (var i = 0; i < count; ++i)
                    copy[i] = items[i];
            else
                Array.Copy(items, copy, count);
            return copy;
        }

        /// <summary>Returns the new array consisting from all items from source array then the all items from added array.
        /// If source is null or empty then the added array will be returned. If added is null or empty then the source will be returned.</summary>
        public static T[] Append<T>(this T[] source, params T[] added)
        {
            if (added == null || added.Length == 0)
                return source;
            if (source == null || source.Length == 0)
                return added;
            var sourceCount = source.Length;
            var addedCount  = added.Length;
            var result = new T[sourceCount + addedCount];
            if (sourceCount < 6)
                for (var i = 0; i < sourceCount; ++i)
                    result[i] = source[i];
            else
                Array.Copy(source, 0, result, 0, sourceCount);
            if (addedCount < 6)
                for (var i = 0; i < addedCount; ++i)
                    result[sourceCount + i] = added[i];
            else
                Array.Copy(added, 0, result, sourceCount, addedCount);
            return result;
        }

        /// <summary>Performant concat of enumerables in case of arrays. But performance will degrade if you use Concat().Where().</summary>
        public static T[] Append<T>(this IEnumerable<T> source, IEnumerable<T> other) =>
            source.ToArrayOrSelf().Append(other.ToArrayOrSelf());

        /// <summary>Returns new array with <paramref name="value"/> appended, 
        /// or <paramref name="value"/> at <paramref name="index"/>, if specified.
        /// If source array could be null or empty, then single value item array will be created despite any index.</summary>
        public static T[] AppendOrUpdate<T>(this T[] source, T value, int index = -1)
        {
            if (source == null || source.Length == 0)
                return new[] { value };
            var sourceCount = source.Length;
            index = index < 0 ? sourceCount : index;
            var result = new T[index < sourceCount ? sourceCount : sourceCount + 1];
            if (sourceCount < 6)
                for (var i = 0; i < sourceCount; ++i)
                    result[i] = source[i];
            else
                Array.Copy(source, 0, result, 0, sourceCount);
            result[index] = value;
            return result;
        }

        /// <summary>Updates the item in the copy of the array. The array should be non-empty.</summary>
        public static T[] UpdateNonEmpty<T>(this T[] source, T value, int index)
        {
            var sourceCount = source.Length;
            var result = new T[sourceCount];
            if (sourceCount < 6)
                for (var i = 0; i < sourceCount; ++i)
                    result[i] = source[i];
            else
                Array.Copy(source, 0, result, 0, sourceCount);
            result[index] = value;
            return result;
        }

        /// <summary>Returns the new array consisting from all items from source array then the all items from added array.
        /// Assumes that both arrays are non-empty to avoid the checks.</summary>
        public static T[] AppendNonEmpty<T>(this T[] source, params T[] added)
        {
            var sourceCount = source.Length;
            var addedCount  = added.Length;
            var result = new T[sourceCount + addedCount];
            if (sourceCount < 6)
                for (var i = 0; i < sourceCount; ++i)
                    result[i] = source[i];
            else
                Array.Copy(source, 0, result, 0, sourceCount);
            if (addedCount < 6)
                for (var i = 0; i < addedCount; ++i)
                    result[sourceCount + i] = added[i];
            else
                Array.Copy(added, 0, result, sourceCount, addedCount);
            return result;
        }

        /// <summary>Returns new array with <paramref name="value"/> appended. Assumes that `source` is not empty to avoid the checks.</summary>
        public static T[] AppendToNonEmpty<T>(this T[] source, T value)
        {
            var count = source.Length;
            var result = new T[count + 1];
            if (count < 6)
                for (var i = 0; i < count; ++i)
                    result[i] = source[i];
            else
                Array.Copy(source, 0, result, 0, count);
            result[count] = value;
            return result;
        }

        /// <summary>Returns new array with <paramref name="value"/> prepended. Assumes that `source` is not empty to avoid the checks.</summary>
        public static T[] PrependToNonEmpty<T>(this T[] source, T value)
        {
            var count = source.Length;
            var result = new T[count + 1];
            if (count < 6)
                for (var i = 0; i < count; ++i)
                    result[i + 1] = source[i];
            else
                Array.Copy(source, 0, result, 1, count);
            result[0] = value;
            return result;
        }

        /// <summary>Calls predicate on each item in <paramref name="source"/> array until predicate returns true,
        /// then method will return this item index, or if predicate returns false for each item, method will return -1.</summary>
        public static int IndexOf<T>(this T[] source, Func<T, bool> predicate)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                    if (predicate(source[i]))
                        return i;
            return -1;
        }

        /// <summary>Minimizes the allocations for closure in predicate lambda with the provided <paramref name="state"/></summary>
        public static int IndexOf<T, S>(this T[] source, S state, Func<S, T, bool> predicate)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                    if (predicate(state, source[i]))
                        return i;
            return -1;
        }

        /// <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.</summary>
        public static int IndexOf<T>(this T[] source, T value)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (Equals(item, value))
                        return i;
                }

            return -1;
        }

        /// <summary>The same as `IndexOf` but searching for the item by reference</summary>
        public static int IndexOfReference<T>(this T[] source, T reference) where T : class
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                    if (ReferenceEquals(source[i], reference))
                        return i;
            return -1;
        }

        /// <summary>Produces new array without item at specified <paramref name="index"/>. 
        /// Will return <paramref name="source"/> array if index is out of bounds, or source is null/empty.</summary>
        public static T[] RemoveAt<T>(this T[] source, int index)
        {
            if (source == null || source.Length == 0 || index < 0 || index >= source.Length)
                return source;
            if (index == 0 && source.Length == 1)
                return new T[0];
            var result = new T[source.Length - 1];
            if (index != 0)
                Array.Copy(source, 0, result, 0, index);
            if (index != result.Length)
                Array.Copy(source, index + 1, result, index, result.Length - index);
            return result;
        }

        /// <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.</summary>
        public static T[] Remove<T>(this T[] source, T value) =>
            source.RemoveAt(source.IndexOf(value));

        /// <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
        public static T FindFirst<T>(this T[] source, Func<T, bool> predicate)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (predicate(item))
                        return item;
                }

            return default(T);
        }

        /// <summary>Version of FindFirst with the fixed state used by predicate to prevent allocations by predicate lambda closure</summary>
        public static T FindFirst<T, S>(this T[] source, S state, Func<S, T, bool> predicate)
        {
            if (source != null && source.Length != 0)
                for (var i = 0; i < source.Length; ++i)
                {
                    var item = source[i];
                    if (predicate(state, item))
                        return item;
                }

            return default(T);
        }

        /// <summary>Returns first item matching the <paramref name="predicate"/>, or default item value.</summary>
        public static T FindFirst<T>(this IEnumerable<T> source, Func<T, bool> predicate) =>
            source is T[] sourceArr ? sourceArr.FindFirst(predicate) : source.FirstOrDefault(predicate);

        /// <summary>Returns element if collection consist on single element, otherwise returns default value.
        /// It does not throw for collection with many elements</summary>
        public static T SingleOrDefaultIfMany<T>(this IEnumerable<T> source)
        {
            if (source is IList<T> list)
                return list.Count == 1 ? list[0] : default(T);

            if (source == null)
                return default(T);

            using (var e = source.GetEnumerator())
            {
                if (!e.MoveNext())
                    return default(T);
                var it = e.Current;
                return !e.MoveNext() ? it : default(T);
            }
        }

        /// <summary>Does <paramref name="action"/> for each item</summary>
        public static void ForEach<T>(this T[] source, Action<T> action)
        {
            if (!source.IsNullOrEmpty())
                for (var i = 0; i < source.Length; i++)
                    action(source[i]);
        }

        /// Appends source to results
        public static T[] AppendTo<T>(T[] source, int sourcePos, int count, T[] results = null)
        {
            if (results == null)
            {
                var newResults = new T[count];
                if (count == 1)
                    newResults[0] = source[sourcePos];
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = source[j];
                return newResults;
            }

            var matchCount = results.Length;
            var appendedResults = new T[matchCount + count];
            if (matchCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, matchCount);

            if (count == 1)
                appendedResults[matchCount] = source[sourcePos];
            else
                Array.Copy(source, sourcePos, appendedResults, matchCount, count);

            return appendedResults;
        }

        private static R[] AppendTo<T, R>(T[] source, int sourcePos, int count, Func<T, R> map, R[] results = null)
        {
            if (results == null || results.Length == 0)
            {
                var newResults = new R[count];
                if (count == 1)
                    newResults[0] = map(source[sourcePos]);
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = map(source[j]);
                return newResults;
            }

            var oldResultsCount = results.Length;
            var appendedResults = new R[oldResultsCount + count];
            if (oldResultsCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);

            if (count == 1)
                appendedResults[oldResultsCount] = map(source[sourcePos]);
            else
            {
                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)
                    appendedResults[i] = map(source[j]);
            }

            return appendedResults;
        }

        private static R[] AppendTo<S, T, R>(T[] source, S state, int sourcePos, int count, Func<S, T, R> map, R[] results = null)
        {
            if (results == null || results.Length == 0)
            {
                var newResults = new R[count];
                if (count == 1)
                    newResults[0] = map(state, source[sourcePos]);
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = map(state, source[j]);
                return newResults;
            }

            var oldResultsCount = results.Length;
            var appendedResults = new R[oldResultsCount + count];
            if (oldResultsCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);

            if (count == 1)
                appendedResults[oldResultsCount] = map(state, source[sourcePos]);
            else
            {
                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)
                    appendedResults[i] = map(state, source[j]);
            }

            return appendedResults;
        }

        private static R[] AppendTo<A, B, T, R>(T[] source, A a, B b, int sourcePos, int count, Func<A, B, T, R> map, R[] results = null)
        {
            if (results == null || results.Length == 0)
            {
                var newResults = new R[count];
                if (count == 1)
                    newResults[0] = map(a, b, source[sourcePos]);
                else
                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)
                        newResults[i] = map(a, b, source[j]);
                return newResults;
            }

            var oldResultsCount = results.Length;
            var appendedResults = new R[oldResultsCount + count];
            if (oldResultsCount == 1)
                appendedResults[0] = results[0];
            else
                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);

            if (count == 1)
                appendedResults[oldResultsCount] = map(a, b, source[sourcePos]);
            else
            {
                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)
                    appendedResults[i] = map(a, b, source[j]);
            }

            return appendedResults;
        }

        /// <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
        /// It returns source array and does Not create new one if all items match the condition.</summary>
        public static T[] Match<T>(this T[] source, Func<T, bool> condition)
        {
            if (source == null || source.Length == 0)
                return source;

            if (source.Length == 1)
                return condition(source[0]) ? source : Empty<T>();

            if (source.Length == 2)
            {
                var c0 = condition(source[0]);
                var c1 = condition(source[1]);
                return c0 && c1 ? source : c0 ? new[] { source[0] } : c1 ? new[] { source[1] } : Empty<T>();
            }

            var matchStart = 0;
            T[] matches = null;
            var matchFound = false;
            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(source[i]))) // todo: @unclear check what will happen if the `matchFound` is set back to false
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, matches);

            return matches ?? (matchStart != 0 ? Empty<T>() : source);
        }

        /// <summary>Match with the additional state to use in <paramref name="condition"/> to minimize the allocations 
        /// in <paramref name="condition"/> lambda closure</summary> 
        public static T[] Match<S, T>(this T[] source, S state, Func<S, T, bool> condition)
        {
            if (source == null || source.Length == 0)
                return source;

            if (source.Length == 1)
                return condition(state, source[0]) ? source : Empty<T>();

            if (source.Length == 2)
            {
                var c0 = condition(state, source[0]);
                var c1 = condition(state, source[1]);
                return c0 && c1 ? source : c0 ? new[] { source[0] } : c1 ? new[] { source[1] } : Empty<T>();
            }

            var matchStart = 0;
            T[] matches = null;
            var matchFound = false;
            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(state, source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, matches);

            return matches ?? (matchStart != 0 ? Empty<T>() : source);
        }

        /// <summary>Match with the additional state to use in <paramref name="condition"/> to minimize the allocations 
        /// in <paramref name="condition"/> lambda closure</summary> 
        public static T[] Match<A, B, T>(this T[] source, A a, B b, Func<A, B, T, bool> condition)
        {
            if (source == null || source.Length == 0)
                return source;

            if (source.Length == 1)
                return condition(a, b, source[0]) ? source : Empty<T>();

            if (source.Length == 2)
            {
                var c0 = condition(a, b, source[0]);
                var c1 = condition(a, b, source[1]);
                return c0 && c1 ? source : c0 ? new[] { source[0] } : c1 ? new[] { source[1] } : Empty<T>();
            }

            var matchStart = 0;
            T[] matches = null;
            var matchFound = false;
            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(a, b, source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, matches);

            return matches ?? (matchStart != 0 ? Empty<T>() : source);
        }

        /// <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.
        /// It returns source array and does Not create new one if all items match the condition.</summary>
        public static R[] Match<T, R>(this T[] source, Func<T, bool> condition, Func<T, R> map)
        {
            if (source == null)
                return null;

            if (source.Length == 0)
                return Empty<R>();

            if (source.Length == 1)
            {
                var item = source[0];
                return condition(item) ? new[] { map(item) } : Empty<R>();
            }

            if (source.Length == 2)
            {
                var c0 = condition(source[0]);
                var c1 = condition(source[1]);
                return c0 && c1 ? new[] { map(source[0]), map(source[1]) } : c0 ? new[] { map(source[0]) } : c1 ? new[] { map(source[1]) } : Empty<R>();
            }

            var matchStart = 0;
            R[] matches = null;
            var matchFound = false;

            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, matchStart, i - matchStart, map, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, matchStart, i - matchStart, map, matches);

            return matches ?? (matchStart == 0 ? AppendTo(source, 0, source.Length, map) : Empty<R>());
        }

        /// <summary>Match with the additional state to use in <paramref name="condition"/> and <paramref name="map"/> 
        /// to minimize the allocations in <paramref name="condition"/> lambda closure </summary>
        public static R[] Match<S, T, R>(this T[] source, S state, Func<S, T, bool> condition, Func<S, T, R> map)
        {
            if (source == null)
                return null;
            if (source.Length == 0)
                return Empty<R>();

            if (source.Length == 1)
            {
                var item = source[0];
                return condition(state, item) ? new[] { map(state, item) } : Empty<R>();
            }

            if (source.Length == 2)
            {
                var condition0 = condition(state, source[0]);
                var condition1 = condition(state, source[1]);
                return condition0 && condition1 ? new[] { map(state, source[0]), map(state, source[1]) }
                    : condition0 ? new[] { map(state, source[0]) }
                    : condition1 ? new[] { map(state, source[1]) }
                    : Empty<R>();
            }

            var matchStart = 0;
            R[] matches = null;
            var matchFound = false;

            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(state, source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, state, matchStart, i - matchStart, map, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, state, matchStart, i - matchStart, map, matches);

            return matches ?? (matchStart == 0 ? AppendTo(source, state, 0, source.Length, map) : Empty<R>());
        }

        /// <summary>Match with the additional state to use in <paramref name="condition"/> and <paramref name="map"/> 
        /// to minimize the allocations in <paramref name="condition"/> lambda closure </summary>
        public static R[] Match<A, B, T, R>(this T[] source, A a, B b, Func<A, B, T, bool> condition, Func<A, B, T, R> map)
        {
            if (source == null)
                return null;
            if (source.Length == 0)
                return Empty<R>();

            if (source.Length == 1)
            {
                var item = source[0];
                return condition(a, b, item) ? new[] { map(a, b, item) } : Empty<R>();
            }

            if (source.Length == 2)
            {
                var condition0 = condition(a, b, source[0]);
                var condition1 = condition(a, b, source[1]);
                return condition0 && condition1 ? new[] { map(a, b, source[0]), map(a, b, source[1]) }
                    : condition0 ? new[] { map(a, b, source[0]) }
                    : condition1 ? new[] { map(a, b, source[1]) }
                    : Empty<R>();
            }

            var matchStart = 0;
            R[] matches = null;
            var matchFound = false;

            var i = 0;
            for (; i < source.Length; ++i)
                if (!(matchFound = condition(a, b, source[i])))
                {
                    // for accumulated matched items
                    if (i != 0 && i > matchStart)
                        matches = AppendTo(source, a, b, matchStart, i - matchStart, map, matches);
                    matchStart = i + 1; // guess the next match start will be after the non-matched item
                }

            // when last match was found but not all items are matched (hence matchStart != 0)
            if (matchFound && matchStart != 0)
                return AppendTo(source, a, b, matchStart, i - matchStart, map, matches);

            return matches ?? (matchStart == 0 ? AppendTo(source, a, b, 0, source.Length, map) : Empty<R>());
        }

        /// <summary>Maps all items from source to result array.</summary>
        /// <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
        /// <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
        /// <returns>Converted items</returns>
        public static R[] Map<T, R>(this T[] source, Func<T, R> map)
        {
            if (source == null)
                return null;

            var sourceCount = source.Length;
            if (sourceCount == 0)
                return Empty<R>();

            if (sourceCount == 1)
                return new[] { map(source[0]) };

            if (sourceCount == 2)
                return new[] { map(source[0]), map(source[1]) };

            var results = new R[sourceCount];
            for (var i = 0; i < source.Length; i++)
                results[i] = map(source[i]);
            return results;
        }

        /// Map with additional state to use in <paramref name="map"/> to minimize allocations in <paramref name="map"/> lambda closure 
        public static R[] Map<T, S, R>(this T[] source, S state, Func<S, T, R> map)
        {
            if (source == null)
                return null;

            var sourceCount = source.Length;
            if (sourceCount == 0)
                return Empty<R>();

            if (sourceCount == 1)
                return new[] { map(state, source[0]) };

            if (sourceCount == 2)
                return new[] { map(state, source[0]), map(state, source[1]) };

            var results = new R[sourceCount];
            for (var i = 0; i < source.Length; i++)
                results[i] = map(state, source[i]);
            return results;
        }

        /// <summary>Maps all items from source to result collection. If possible uses fast array Map otherwise Enumerable.Select.</summary>
        /// <typeparam name="T">Source item type</typeparam> <typeparam name="R">Result item type</typeparam>
        /// <param name="source">Source items</param> <param name="map">Function to convert item from source to result.</param>
        /// <returns>Converted items</returns>
        public static IEnumerable<R> Map<T, R>(this IEnumerable<T> source, Func<T, R> map) =>
            source is T[] arr ? arr.Map(map) : source?.Select(map);

        /// <summary>If <paramref name="source"/> is array uses more effective Match for array, otherwise just calls Where</summary>
        /// <typeparam name="T">Type of source items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>
        /// <returns>Result items, may be an array.</returns>
        public static IEnumerable<T> Match<T>(this IEnumerable<T> source, Func<T, bool> condition) =>
            source is T[] arr ? arr.Match(condition) : source?.Where(condition);

        /// <summary>If <paramref name="source"/> is array uses more effective Match for array,
        /// otherwise just calls Where, Select</summary>
        /// <typeparam name="T">Type of source items.</typeparam> <typeparam name="R">Type of result items.</typeparam>
        /// <param name="source">If null, the null will be returned.</param>
        /// <param name="condition">Condition to keep items.</param>  <param name="map">Converter from source to result item.</param>
        /// <returns>Result items, may be an array.</returns>
        public static IEnumerable<R> Match<T, R>(this IEnumerable<T> source, Func<T, bool> condition, Func<T, R> map) =>
            source is T[] arr ? arr.Match(condition, map) : source?.Where(condition).Select(map);
    }

    /// <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref="Ref.Swap{T}"/>.</summary>
    /// <typeparam name="T">Type of object to wrap.</typeparam>
    public sealed class Ref<T> where T : class
    {
        /// <summary>Gets the wrapped value.</summary>
        public T Value => _value;
        private T _value;

        /// <summary>Creates ref to object, optionally with initial value provided.</summary>
        /// <param name="initialValue">(optional) Initial value.</param>
        public Ref(T initialValue = default) => _value = initialValue;

        /// <summary>Exchanges currently hold object with <paramref name="getNewValue"/> - see <see cref="Ref.Swap{T}"/> for details.</summary>
        /// <param name="getNewValue">Delegate to produce new object value from current one passed as parameter.</param>
        /// <returns>Returns old object value the same way as <see cref="Interlocked.Exchange(ref int,int)"/></returns>
        /// <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        public T Swap(Func<T, T> getNewValue) =>
            Ref.Swap(ref _value, getNewValue);

        /// Option without allocation for capturing `a` in closure of `getNewValue`
        public T Swap<A>(A a, Func<T, A, T> getNewValue) => Ref.Swap(ref _value, a, getNewValue);

        /// Option without allocation for capturing `a` and `b` in closure of `getNewValue`
        public T Swap<A, B>(A a, B b, Func<T, A, B, T> getNewValue) => Ref.Swap(ref _value, a, b, getNewValue);

        /// <summary>Just sets new value ignoring any intermingled changes and returns the original value</summary>
        /// <param name="newValue"></param> <returns>old value</returns>
        public T Swap(T newValue) => Interlocked.Exchange(ref _value, newValue);

        /// <summary>Directly sets the value and returns the new value</summary>
        public T SetNonAtomic(T newValue) => _value = newValue;

        /// <summary>Compares current Referred value with <paramref name="currentValue"/> and if equal replaces current with <paramref name="newValue"/></summary>
        /// <param name="currentValue"></param> <param name="newValue"></param>
        /// <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).</returns>
        /// <example><c>[!CDATA[
        /// var value = SomeRef.Value;
        /// if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))
        ///     SomeRef.Swap(v => Update(v)); // fallback to normal Swap with delegate allocation
        /// ]]</c></example>
        public bool TrySwapIfStillCurrent(T currentValue, T newValue) =>
            Interlocked.CompareExchange(ref _value, newValue, currentValue) == currentValue;
    }

    /// <summary>Provides optimistic-concurrency consistent <see cref="Swap{T}"/> operation.</summary>
    public static class Ref
    {
        /// The default max retry count - can be overridden by `Swap` optional parameter 
        public const int RETRY_COUNT_UNTIL_THROW = 50;

        /// <summary>Factory for <see cref="Ref{T}"/> with type of value inference.</summary>
        /// <typeparam name="T">Type of value to wrap.</typeparam>
        /// <param name="value">Initial value to wrap.</param>
        /// <returns>New ref.</returns>
        public static Ref<T> Of<T>(T value) where T : class => new Ref<T>(value);

        /// <summary>Creates new ref to the value of original ref.</summary> <typeparam name="T">Ref value type.</typeparam>
        /// <param name="original">Original ref.</param> <returns>New ref to original value.</returns>
        public static Ref<T> NewRef<T>(this Ref<T> original) where T : class => Of(original.Value);

        /// <summary>First, it evaluates new value using <paramref name="getNewValue"/> function. 
        /// Second, it checks that original value is not changed. 
        /// If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name="getNewValue"/>).</summary>
        /// <typeparam name="T">Type of value to swap.</typeparam>
        /// <param name="value">Reference to change to new value</param>
        /// <param name="getNewValue">Delegate to get value from old one.</param>
        /// <param name="retryCountUntilThrow">(optional)</param>
        /// <returns>Old/original value. By analogy with <see cref="Interlocked.Exchange(ref int,int)"/>.</returns>
        /// <remarks>Important: <paramref name="getNewValue"/> May be called multiple times to retry update with value concurrently changed by other code.</remarks>
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T>(ref T value, Func<T, T> getNewValue,
            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)
            where T : class
        {
            var spinWait = new SpinWait();
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;

                if (++retryCount > retryCountUntilThrow)
                    ThrowRetryCountExceeded(retryCountUntilThrow);
                spinWait.SpinOnce();
            }
        }

        private static void ThrowRetryCountExceeded(int retryCountExceeded) =>
            throw new InvalidOperationException(
                $"Ref retried to Update for {retryCountExceeded} times But there is always someone else intervened.");

        /// <summary>Swap with the additional state <paramref name="a"/> required for the delegate <paramref name="getNewValue"/>.
        /// May prevent closure creation for the delegate</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T, A>(ref T value, A a, Func<T, A, T> getNewValue, 
            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW) 
            where T : class
        {
            var spinWait = new SpinWait();
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue, a);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;
                if (++retryCount > retryCountUntilThrow)
                    ThrowRetryCountExceeded(retryCountUntilThrow);
                spinWait.SpinOnce();
            }
        }

        /// <summary>Swap with the additional state <paramref name="a"/> required for the delegate <paramref name="getNewValue"/>.
        /// May prevent closure creation for the delegate</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static T SwapAndGetNewValue<T, A>(ref T value, A a, Func<T, A, T> getNewValue,
            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)
            where T : class
        {
            var spinWait = new SpinWait();
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue, a);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return newValue;
                if (++retryCount > retryCountUntilThrow)
                    ThrowRetryCountExceeded(retryCountUntilThrow);
                spinWait.SpinOnce();
            }
        }

        /// <summary>Swap with the additional state <paramref name="a"/>, <paramref name="b"/> required for the delegate <paramref name="getNewValue"/>.
        /// May prevent closure creation for the delegate</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T, A, B>(ref T value, A a, B b, Func<T, A, B, T> getNewValue,
            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)
            where T : class
        {
            var spinWait = new SpinWait();
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue, a, b);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;

                if (++retryCount > retryCountUntilThrow)
                    ThrowRetryCountExceeded(retryCountUntilThrow);

                spinWait.SpinOnce();
            }
        }

        /// <summary>Swap with the additional state <paramref name="a"/>, <paramref name="b"/>, <paramref name="c"/> required for the delegate <paramref name="getNewValue"/>.
        /// May prevent closure creation for the delegate</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static T Swap<T, A, B, C>(ref T value, A a, B b, C c, Func<T, A, B, C, T> getNewValue,
            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)
            where T : class
        {
            var spinWait = new SpinWait();
            var retryCount = 0;
            while (true)
            {
                var oldValue = value;
                var newValue = getNewValue(oldValue, a, b, c);
                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)
                    return oldValue;

                if (++retryCount > retryCountUntilThrow)
                    ThrowRetryCountExceeded(retryCountUntilThrow);

                spinWait.SpinOnce();
            }
        }
    }

    /// <summary>Printable thing via provided printer </summary>
    public interface IPrintable
    {
        /// <summary>Print to the provided string builder via the provided printer.</summary>
        StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer);
    }

    /// <summary>Produces good enough hash codes for the fields</summary>
    public static class Hasher
    {
        /// <summary>Combines hashes of two fields</summary>
        public static int Combine<T1, T2>(T1 a, T2 b) =>
            Combine(a?.GetHashCode() ?? 0, b?.GetHashCode() ?? 0);

        /// <summary>Inspired by System.Tuple.CombineHashCodes</summary>
        public static int Combine(int h1, int h2)
        {
            if (h1 == 0) return h2;
            unchecked
            {
                return (h1 << 5) + h1 ^ h2;
            }
        }
    }

    /// Simple unbounded object pool
    public sealed class StackPool<T> where T : class
    {
        /// <summary>Give me an object</summary>
        [MethodImpl((MethodImplOptions)256)]
        public T RentOrDefault() =>
            Interlocked.Exchange(ref _s, _s?.Tail)?.Head;

        /// <summary>Give it back</summary>
        [MethodImpl((MethodImplOptions)256)]
        public void Return(T x) =>
            Interlocked.Exchange(ref _s, new Stack(x, _s));

        private Stack _s;

        private sealed class Stack
        {
            public readonly T Head;
            public readonly Stack Tail;
            public Stack(T h, Stack t)
            {
                Head = h;
                Tail = t;
            }
        }
    }

    /// <summary>Immutable Key-Value pair. It is reference type (could be check for null), 
    /// which is different from System value type <see cref="KeyValuePair{TKey,TValue}"/>.
    /// In addition provides <see cref="Equals"/> and <see cref="GetHashCode"/> implementations.</summary>
    /// <typeparam name="K">Type of Key.</typeparam><typeparam name="V">Type of Value.</typeparam>
    public class KV<K, V> : IPrintable
    {
        /// <summary>Key.</summary>
        public readonly K Key;

        /// <summary>Value.</summary>
        public readonly V Value;

        /// <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.</summary>
        /// <param name="key">key.</param><param name="value">value.</param>
        public KV(K key, V value)
        {
            Key = key;
            Value = value;
        }

        /// <inheritdoc />
        public StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer) =>
            s.Append("(").To(b => Key == null ? b : printer(b, Key))
                .Append(", ").To(b => Value == null ? b : printer(b, Value))
                .Append(')');

        /// <summary>Creates nice string view.</summary><returns>String representation.</returns>
        public override string ToString() =>
            Print(new StringBuilder(), (s, x) => s.Append(x)).ToString();

        /// <summary>Returns true if both key and value are equal to corresponding key-value of other object.</summary>
        public override bool Equals(object obj)
        {
            var other = obj as KV<K, V>;
            return other != null
                   && (ReferenceEquals(other.Key, Key) || Equals(other.Key, Key))
                   && (ReferenceEquals(other.Value, Value) || Equals(other.Value, Value));
        }

        /// <summary>Combines key and value hash code</summary>
        public override int GetHashCode() => Hasher.Combine(Key, Value);
    }

    /// <summary>Helpers for <see cref="KV{K,V}"/>.</summary>
    public static class KV
    {
        /// <summary>Creates the key value pair.</summary>
        public static KV<K, V> Of<K, V>(K key, V value) => new KV<K, V>(key, value);

        /// <summary>Creates the pair with the new value</summary>
        public static KV<K, V> WithValue<K, V>(this KV<K, V> kv, V value) => new KV<K, V>(kv.Key, value);
    }

    /// Simple helper for creation of the pair of two parts.
    public static class KeyValuePair
    {
        /// Pairs key with value.
        public static KeyValuePair<K, V> Pair<K, V>(this K key, V value) => new KeyValuePair<K, V>(key, value);
    }

    /// <summary>Helper structure which allows to distinguish null value from the default value for optional parameter.</summary>
    public struct Opt<T>
    {
        /// <summary>Allows to transparently convert parameter argument to opt structure.</summary>
        public static implicit operator Opt<T>(T value) => new Opt<T>(value);

        /// <summary>Argument value.</summary>
        public readonly T Value;

        /// <summary>Indicates that value is provided.</summary>
        public readonly bool HasValue;

        /// <summary>Wraps passed value in structure. Sets the flag that value is present.</summary>
        public Opt(T value)
        {
            HasValue = true;
            Value = value;
        }

        /// <summary>Helper to get value or default value if value is not present.</summary>
        public T OrDefault(T defaultValue = default) => HasValue ? Value : defaultValue;
    }

    /// <summary>Ever growing list</summary>
    public struct GrowingList<T>
    {
        /// <summary>Default initial capacity </summary>
        public const int DefaultInitialCapacity = 2;

        /// <summary>The items array</summary>
        public T[] Items;

        /// <summary>The count</summary>
        public int Count;

        /// <summary>Constructs the thing</summary>
        public GrowingList(T[] items, int count = 0)
        {
            Items = items;
            Count = count;
        }

        /// <summary>Push the new slot and return the ref to it</summary>
        public ref T PushSlot()
        {
            if (Items == null)
                Items = new T[DefaultInitialCapacity];
            else if (Count >= Items.Length)
                Items = Expand(Items);
            return ref Items[Count++];
        }

        /// <summary>Adds the new item possibly extending the item collection</summary>
        public void PushSlot(T item)
        {
            if (Items == null)
                Items = new T[DefaultInitialCapacity];
            else if (Count >= Items.Length)
                Items = Expand(Items);
            Items[Count++] = item;
        }

        /// <summary>Pops the item - just moving the counter back</summary>
        public void Pop() => --Count;

        // todo: @naming think of the better name
        /// <summary>Pops the item - just moving the counter back</summary>
        public T PopItem() => Items[--Count];

        /// <summary>Expands the items starting with 2</summary>
        private static T[] Expand(T[] items)
        {
            var count = items.Length;
            var newItems = new T[count << 1]; // count x 2
            Array.Copy(items, 0, newItems, 0, count);
            return newItems;
        }

        /// <inheritdoc />
        public override string ToString() =>
            $"Count {Count} of {(Count == 0 || Items == null || Items.Length == 0 ? "empty" : "first (" + Items[0] + ") and last (" + Items[Count - 1] + ")")}";
    }

    /// <summary>Immutable list - simplest linked list with the Head and the Tail.</summary>
    public sealed class ImList<T>
    {
        /// <summary>Empty list to Push to.</summary>
        public static readonly ImList<T> Empty = new ImList<T>();

        /// <summary>True for empty list.</summary>
        public bool IsEmpty => Tail == null;

        /// <summary>First value in a list.</summary>
        public readonly T Head;

        /// <summary>The rest of values or Empty if list has a single value.</summary>
        public readonly ImList<T> Tail;

        /// <summary>Prepends new value and returns new list.</summary>
        public ImList<T> Push(T head) => new ImList<T>(head, this);

        /// <summary>Enumerates the list.</summary>
        public IEnumerable<T> Enumerate()
        {
            if (IsEmpty)
                yield break;
            for (var list = this; !list.IsEmpty; list = list.Tail)
                yield return list.Head;
        }

        /// <summary>String representation for debugging purposes</summary>
        public override string ToString() => IsEmpty
            ? "[]" : Tail.IsEmpty
            ? "[" + Head + "]" : Tail.Tail.IsEmpty
            ? "[" + Head + "," + Tail.Head + "]" : Tail.Tail.Tail.IsEmpty
            ? "[" + Head + "," + Tail.Head + "," + Tail.Tail.Head + "]"
            : "[" + Head + "," + Tail.Head + "," + Tail.Tail.Head + ", ...]";

        private ImList() { }

        private ImList(T head, ImList<T> tail)
        {
            Head = head;
            Tail = tail;
        }
    }

    /// <summary>Extension methods providing basic operations on a list.</summary>
    public static class ImList
    {
        /// Split list into (Head, Tail, IsEmpty) tuple
        public static void Deconstruct<T>(this ImList<T> list, out T head, out ImList<T> tail, out bool isEmpty)
        {
            head = list.Head;
            tail = list.Tail;
            isEmpty = list.IsEmpty;
        }

        /// <summary>
        /// Constructs the reversed list from the parameter array of items
        /// </summary>
        public static ImList<T> List<T>(params T[] items)
        {
            var l = ImList<T>.Empty;
            if (items != null)
                for (var i = items.Length - 1; i >= 0; --i)
                    l = l.Push(items[i]);
            return l;
        }

        /// <summary>
        /// Constructs the list as the reversed input list
        /// </summary>
        public static ImList<T> ToImList<T>(this IList<T> source)
        {
            var l = ImList<T>.Empty;
            if (source != null)
                for (var i = source.Count - 1; i >= 0; --i)
                    l = l.Push(source[i]);
            return l;
        }

        /// <summary>
        /// Constructs the list as the reversed enumerable
        /// </summary>
        public static ImList<T> ToImList<T>(this IEnumerable<T> source)
        {
            if (source is IList<T> list)
                return list.ToImList();
            var l = ImList<T>.Empty;

            if (source != null)
                foreach (var item in source)
                    l = l.Push(item);
            return l.Reverse();
        }

        /// <summary>Constructs list of one element</summary>
        public static ImList<T> List<T>(this T head) => ImList<T>.Empty.Push(head);

        /// <summary>Constructs list from head and tail</summary>
        public static ImList<T> List<T>(this T head, ImList<T> tail) => tail.Push(head);

        /// <summary>Apples some effect action to each element</summary>
        public static void ForEach<T>(this ImList<T> list, Action<T> effect)
        {
            for (; !list.IsEmpty; list = list.Tail)
                effect(list.Head);
        }

        /// <summary>Fold list to a single value. The respective name for it in LINQ is Aggregate</summary>
        public static S Fold<T, S>(this ImList<T> list, S state, Func<T, S, S> handler)
        {
            if (list.IsEmpty)
                return state;
            var result = state;
            for (; !list.IsEmpty; list = list.Tail)
                result = handler(list.Head, result);
            return result;
        }

        /// <summary>Fold list to a single value with index of item. The respective name for it in LINQ is Aggregate.</summary>
        public static S Fold<T, S>(this ImList<T> list, S state, Func<T, int, S, S> handler)
        {
            if (list.IsEmpty)
                return state;
            var result = state;
            for (var i = 0; !list.IsEmpty; list = list.Tail, ++i)
                result = handler(list.Head, i, result);
            return result;
        }

        /// <summary>Returns new list in reverse order.</summary>
        public static ImList<T> Reverse<T>(this ImList<T> list)
        {
            if (list.IsEmpty || list.Tail.IsEmpty)
                return list;
            var reversed = ImList<T>.Empty;
            for (; !list.IsEmpty; list = list.Tail)
                reversed = reversed.Push(list.Head);
            return reversed;
        }

        /// <summary>Maps the items from the first list to the result list.</summary>
        public static ImList<R> Map<T, R>(this ImList<T> list, Func<T, R> map) =>
            list.Fold(ImList<R>.Empty, (x, r) => List(map(x), r)).Reverse();

        /// <summary>Maps with index</summary>
        public static ImList<R> Map<T, R>(this ImList<T> list, Func<T, int, R> map) =>
            list.Fold(ImList<R>.Empty, (x, i, r) => List(map(x, i), r)).Reverse();

        /// <summary>Copies list to array.</summary>
        public static T[] ToArray<T>(this ImList<T> source) =>
            source.IsEmpty ? ArrayTools.Empty<T>()
            : source.Tail.IsEmpty ? new[] { source.Head } : source.Enumerate().ToArray();
    }

    /// Zipper is an immutable persistent data structure, to represent collection with single focused (selected, active) element.
    /// Consist of REVERSED `Left` immutable list, `Focus` element, and the `Right` immutable list. That's why a Zipper name,
    /// where left and right part are joined / zipped in focus item.
    public sealed class ImZipper<T>
    {
        /// Empty singleton instance to start building your zipper
        public static readonly ImZipper<T> Empty = new ImZipper<T>();

        /// True is zipper does not contain items
        public bool IsEmpty => Count == 0;

        /// Index of Focus item, from `0` to `Count-1`
        public readonly int Index;

        /// Number of items
        public readonly int Count;

        /// Left REVERSED list, so the Head of the list is just prior the Focus item 
        public readonly ImList<T> Left;

        /// Right list, where Head is just after the Focus item
        public readonly ImList<T> Right;

        /// Single focus item
        public readonly T Focus;

        /// <inheritdoc />
        public override string ToString() =>
            IsEmpty ? "[||]" : Count + ":" + Left.Reverse() + "|" + Index + ":" + Focus + "|" + Right;

        /// Sets a new focus and pushes the old focus to the Left list. 
        public ImZipper<T> Append(T focus) => PushLeft(focus);

        /// Sets a new focus and pushes the old focus to the Left list.
        public ImZipper<T> PushLeft(T focus) =>
        IsEmpty ? new ImZipper<T>(ImList<T>.Empty, focus, 0, ImList<T>.Empty, 1)
                : new ImZipper<T>(Left.Push(Focus), focus, Index + 1, Right, Count + 1);

        /// Sets a new focus and pushes the old focus to the right list. 
        public ImZipper<T> Insert(T focus) => PushRight(focus);

        /// Sets a new focus and pushes the old focus to the right list. 
        public ImZipper<T> PushRight(T focus) =>
            IsEmpty ? new ImZipper<T>(ImList<T>.Empty, focus, 0, ImList<T>.Empty, 1)
                : new ImZipper<T>(Left, focus, Index, Right.Push(Focus), Count + 1);

        /// Removes a focus, filling the hole with the item from the left list, or from the right if the left is empty
        public ImZipper<T> PopLeft() =>
            IsEmpty ? this
            : Left.IsEmpty && Right.IsEmpty ? Empty
            : !Left.IsEmpty ? new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right, Count - 1)
            : new ImZipper<T>(Left, Right.Head, Index, Right.Tail, Count - 1);

        /// Removes a focus, filling the hole with the item from the right list, or from the left if the right is empty
        public ImZipper<T> PopRight() =>
            IsEmpty ? this
            : Left.IsEmpty && Right.IsEmpty ? Empty
            : !Right.IsEmpty ? new ImZipper<T>(Left, Right.Head, Index, Right.Tail, Count - 1)
            : new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right, Count - 1);

        /// Shifts focus one element to the left (decrementing its Index).
        public ImZipper<T> ShiftLeft() =>
            IsEmpty || Left.IsEmpty ? this
            : new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right.Push(Focus), Count);

        /// Shifts focus one element to the right (incrementing its Index).
        public ImZipper<T> ShiftRight() =>
            IsEmpty || Right.IsEmpty ? this
            : new ImZipper<T>(Left.Push(Focus), Right.Head, Index + 1, Right.Tail, Count);

        /// Sets a new focus and returns a new zipper with the left and right lists unchanged
        public ImZipper<T> WithFocus(T focus) =>
            IsEmpty ? this : new ImZipper<T>(Left, focus, Index, Right, Count);

        /// Maps over the zipper items producing a new zipper
        public ImZipper<R> Map<R>(Func<T, R> map) =>
            IsEmpty ? ImZipper<R>.Empty
                : new ImZipper<R>(Left.Reverse().Fold(ImList<R>.Empty, (x, r) => r.Push(map(x))),
                    map(Focus), Index, Right.Map(map), Count);

        /// Maps over the zipper items with item index, producing a new zipper
        public ImZipper<R> Map<R>(Func<T, int, R> map) =>
            IsEmpty ? ImZipper<R>.Empty
                : new ImZipper<R>(
                    Left.Reverse().Fold(ImList<R>.Empty, (x, i, r) => r.Push(map(x, i))),
                    map(Focus, Index), Index, Right.Map((x, i) => map(x, Index + 1 + i)), Count);

        private ImZipper() => Index = -1;

        private ImZipper(ImList<T> left, T focus, int index, ImList<T> right, int count)
        {
            Left = left;
            Focus = focus;
            Index = index;
            Right = right;
            Count = count;
        }
    }

    /// Other ImZipper methods
    public static class ImZipper
    {
        /// Appends array items to zipper
        public static ImZipper<T> Zip<T>(params T[] items)
        {
            if (items.IsNullOrEmpty())
                return ImZipper<T>.Empty;
            var z = ImZipper<T>.Empty;
            for (var i = 0; i < items.Length; ++i)
                z = z.PushLeft(items[i]);
            return z;
        }

        /// Converts to array.
        public static T[] ToArray<T>(this ImZipper<T> z)
        {
            if (z.IsEmpty)
                return ArrayTools.Empty<T>();
            var a = new T[z.Count];
            z.Fold(a, (x, i, xs) =>
            {
                xs[i] = x;
                return xs;
            });
            return a;
        }

        /// Shifts focus to a specified index, e.g. a random access
        public static ImZipper<T> ShiftTo<T>(this ImZipper<T> z, int i)
        {
            if (i < 0 || i >= z.Count || i == z.Index)
                return z;
            while (i < z.Index)
                z = z.ShiftLeft();
            while (i > z.Index)
                z = z.ShiftRight();
            return z;
        }

        /// Updates a focus element if it is present, otherwise does nothing.
        /// If the focus item is the equal one, then returns the same zipper back.
        public static ImZipper<T> Update<T>(this ImZipper<T> z, Func<T, T> update)
        {
            if (z.IsEmpty)
                return z;
            var result = update(z.Focus);
            if (ReferenceEquals(z.Focus, result) || result != null && result.Equals(z.Focus))
                return z;
            return z.WithFocus(result);
        }

        /// Update the item at random index, by shifting and updating it
        public static ImZipper<T> UpdateAt<T>(this ImZipper<T> z, int i, Func<T, T> update) =>
            i < 0 || i >= z.Count ? z : z.ShiftTo(i).Update(update);

        /// Update the item at random index, by shifting and updating it
        public static ImZipper<T> RemoveAt<T>(this ImZipper<T> z, int i) =>
            i < 0 || i >= z.Count ? z : z.ShiftTo(i).PopLeft();

        /// Folds zipper to a single value
        public static S Fold<T, S>(this ImZipper<T> z, S state, Func<T, S, S> handler) =>
            z.IsEmpty ? state :
            z.Right.Fold(handler(z.Focus, z.Left.Reverse().Fold(state, handler)), handler);

        /// Folds zipper to a single value by using an item index
        public static S Fold<T, S>(this ImZipper<T> z, S state, Func<T, int, S, S> handler)
        {
            if (z.IsEmpty)
                return state;
            var focusIndex = z.Index;
            var reducedLeft = z.Left.Reverse().Fold(state, handler);
            return z.Right.Fold(handler(z.Focus, focusIndex, reducedLeft),
                (x, i, r) => handler(x, focusIndex + i + 1, r));
        }

        /// <summary>Apply some effect action on each element</summary>
        public static void ForEach<T>(this ImZipper<T> z, Action<T> effect)
        {
            if (!z.IsEmpty)
            {
                if (!z.Left.IsEmpty)
                    z.Left.Reverse().ForEach(effect);
                effect(z.Focus);
                if (!z.Right.IsEmpty)
                    z.Right.ForEach(effect);
            }
        }
    }

    /// Given the old value should and the new value should return result updated value.
    public delegate V Update<V>(V oldValue, V newValue);

    /// Update handler including the key
    public delegate V Update<K, V>(K key, V oldValue, V newValue);

    /// <summary>Entry containing the Key and Value in addition to the Hash</summary>
    public sealed class ImHashMapEntry<K, V> : ImHashMap<K, V>.Entry
    {
        /// <summary>The key</summary>
        public readonly K Key;
        /// <summary>The value. Maybe modified if you need the Ref{Value} semantics. 
        /// You may add the entry with the default Value to the map, and calculate and set it later (e.g. using the CAS).</summary>
        public V Value;
        /// <summary>Constructs the entry with the key and value</summary>
        public ImHashMapEntry(int hash, K key) : base(hash) => Key = key;
        /// <summary>Constructs the entry with the key and value</summary>
        public ImHashMapEntry(int hash, K key, V value) : base(hash) 
        {
            Key   = key;
            Value = value;
        }

        /// <inheritdoc />
        public override int Count() => 1;

        /// <inheritdoc />
        public override ImHashMapEntry<K, V> GetEntryOrNull(int hash, K key) =>
            Hash == hash && Key.Equals(key) ? this : null;

        /// <inheritdoc />
        public override Entry Update(ImHashMapEntry<K, V> newEntry) =>
            Key.Equals(newEntry.Key) ? newEntry : this.WithConflicting(newEntry);

        /// <inheritdoc />
        public override Entry UpdateOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterOrKeeper<S> updateOrKeep)
        {
            if (!Key.Equals(newEntry.Key))
                return this.WithConflicting(newEntry);
            return updateOrKeep(state, this, newEntry) != this ? newEntry : this;
        }

#if !DEBUG
        /// <inheritdoc />
        public override string ToString() => "{H: " + Hash + ", K: " + Key + ", V: " + Value + "}";
#endif
    }

    /// <summary>The composite containing the list of entries with the same conflicting Hash.</summary>
    internal sealed class HashConflictingEntry<K, V> : ImHashMap<K, V>.Entry
    {
        public ImHashMapEntry<K, V>[] Conflicts;
        internal HashConflictingEntry(int hash, params ImHashMapEntry<K, V>[] conflicts) : base(hash) => Conflicts = conflicts;

        public override int Count() => Conflicts.Length;

        /// <inheritdoc />
        public override ImHashMapEntry<K, V> GetEntryOrNull(int hash, K key)
        {
            var cs = Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            return i != -1 ? cs[i] : null;
        }

        /// <inheritdoc />
        public override Entry Update(ImHashMapEntry<K, V> newEntry)
        {
            var key = newEntry.Key;
            var cs = Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            return new HashConflictingEntry<K, V>(Hash, cs.AppendOrUpdate(newEntry, i));
        }

        /// <inheritdoc />
        public override Entry UpdateOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterOrKeeper<S> updateOrKeep)
        {
            var key = newEntry.Key;
            var cs = Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            if (i == -1)
                return new HashConflictingEntry<K, V>(Hash, cs.AppendToNonEmpty(newEntry));

            var oldEntry = cs[i];
            if (updateOrKeep(state, oldEntry, newEntry) != oldEntry)
                return new HashConflictingEntry<K, V>(Hash, cs.UpdateNonEmpty(newEntry, i));

            return this;
        }

#if !DEBUG
        public override string ToString()
        {
            var sb = new System.Text.StringBuilder("HashConflictingEntry: [");
            foreach (var x in Conflicts) 
                sb.Append(x.ToString()).Append(", ");
            return sb.Append("]").ToString();
        }
#endif
    }

    /// <summary>The base and the holder class for the map tree leafs and branches, also defines the Empty tree.
    /// The map implementation is based on the "modified" 2-3 tree.</summary>
    public class ImHashMap<K, V>
    {
        /// <summary>Hide the base constructor to prevent the multiple Empty trees creation</summary>
        protected ImHashMap() { }

        /// <summary>Empty map to start with. Exists as a single instance.</summary>
        public static readonly ImHashMap<K, V> Empty = new ImHashMap<K, V>();

        /// <summary>Prints the map tree in JSON-ish format in release mode and enumerates the keys in DEBUG.</summary>
        public override string ToString()
        {
#if DEBUG
            // for the debug purposes we just output the first N keys in array
            const int n = 50;
            var count = this.Count();
            var keys = this.Enumerate().Take(n).Select(x => x.Key).ToList();
            return $"{{keys: new int[{(count > n ? $"{n}/{count}" : "" + count)}] {{{(string.Join(", ", keys))}}}}}";
#else
            return "{}";
#endif
        }

        /// <summary>Indicates that the map is empty</summary>
        public bool IsEmpty => this == Empty;

        /// <summary>The count of entries in the map</summary>
        public virtual int Count() => 0;

        internal virtual Entry GetMinHashEntryOrDefault() => null;
        internal virtual Entry GetMaxHashEntryOrDefault() => null;

        /// <summary>Lookup for the entry by hash. If nothing the method returns `null`</summary>
        internal virtual Entry GetEntryOrNull(int hash) => null;

        /// <summary>Returns the found entry with the same hash or the new map with added new entry.
        /// Note that the empty map will return the entry the same as if the entry was found - so the consumer should check for the empty map.
        /// Note that the method cannot return the `null` - when the existing entry is not found it will alway be the new map with the added entry.</summary>
        public virtual ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) => entry;

        /// <summary>Returns the new map with old entry replaced by the new entry. Note that the old entry should be present.</summary>
        public virtual ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) => this;

        /// <summary>Removes the certainly present old entry and returns the new map without it.</summary>
        internal virtual ImHashMap<K, V> RemoveEntry(Entry entry) => this;

        /// <summary>The delegate is supposed to return entry different from the oldEntry to update, and return the oldEntry to keep it.</summary>
        public delegate ImHashMapEntry<K, V> UpdaterOrKeeper<S>(S state, ImHashMapEntry<K, V> oldEntry, ImHashMapEntry<K, V> newEntry);

        /// <summary>The base map entry for holding the hash and payload</summary>
        public abstract class Entry : ImHashMap<K, V>
        {
            /// <summary>The Hash</summary>
            public readonly int Hash;
            /// <summary>Constructs the entry with the hash</summary>
            protected Entry(int hash) => Hash = hash;

            internal override Entry GetMinHashEntryOrDefault() => this;
            internal override Entry GetMaxHashEntryOrDefault() => this;

            internal sealed override Entry GetEntryOrNull(int hash) => hash == Hash ? this : null;

            /// <summary>Lookup for the entry by Hash and Key</summary>
            public abstract ImHashMapEntry<K, V> GetEntryOrNull(int hash, K key);

            /// <summary>Updating the entry with the new one</summary>
            public abstract Entry Update(ImHashMapEntry<K, V> newEntry);

            /// <summary>Updating the entry with the new one using the `update` method</summary>
            public abstract Entry UpdateOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterOrKeeper<S> updateOrKeep);

            /// <inheritdoc />
            public sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>
                hash > Hash ? new Leaf2(this, entry) : hash < Hash ? new Leaf2(entry, this) : (ImHashMap<K, V>)this;

            /// <inheritdoc />
            public sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) => 
                this == oldEntry ? newEntry : oldEntry;

            internal sealed override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>
                this == removedEntry ? Empty : this;
        }

        /// <summary>Leaf with 2 hash-ordered entries. Important: the both or either of entries may be null for the removed entries</summary>
        internal sealed class Leaf2 : ImHashMap<K, V>
        {
            public readonly Entry Entry0, Entry1;
            public Leaf2(Entry e0, Entry e1)
            {
                Debug.Assert(e0.Hash < e1.Hash);
                Entry0 = e0; Entry1 = e1;
            }

            public override int Count() => Entry0.Count() + Entry1.Count();

#if !DEBUG
            public override string ToString() => "{L2:{E0:" + Entry0 + ",E1:" + Entry1 + "}}";
#endif

            internal override Entry GetMinHashEntryOrDefault() => Entry0;
            internal override Entry GetMaxHashEntryOrDefault() => Entry1;

            internal override Entry GetEntryOrNull(int hash) => 
                Entry0.Hash == hash ? Entry0 : Entry1.Hash == hash ? Entry1 : null;

            public override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>
                hash == Entry0.Hash ? Entry0 : hash == Entry1.Hash ? Entry1 : (ImHashMap<K, V>)new Leaf2Plus1(entry, this);

            public override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) =>
                oldEntry == Entry0 ? new Leaf2(newEntry, Entry1) : new Leaf2(Entry0, newEntry);

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>
                Entry0 == removedEntry ? Entry1 : Entry0;
        }

        /// <summary>The leaf containing the Leaf2 plus the newest added entry.</summary>
        internal sealed class Leaf2Plus1 : ImHashMap<K, V>
        {
            public readonly Entry Plus;
            public readonly Leaf2 L;
            public Leaf2Plus1(Entry plus, Leaf2 leaf)
            {
                Plus = plus;
                L    = leaf;
            }

            public override int Count() => Plus.Count() + L.Entry0.Count() + L.Entry1.Count();

#if !DEBUG
            public override string ToString() => "{L21:{P:" + Plus + ",L:" + L + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault() => Plus.Hash < L.Entry0.Hash ? Plus : L.Entry0;
            internal sealed override Entry GetMaxHashEntryOrDefault() => Plus.Hash > L.Entry1.Hash ? Plus : L.Entry1;

            internal override Entry GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash) 
                    return Plus;
                Entry e0 = L.Entry0, e1 = L.Entry1;
                return e0.Hash == hash ? e0 : e1.Hash == hash ? e1 : null;
            }

            public sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                if (hash == Plus.Hash) 
                    return Plus;
                Entry e0 = L.Entry0, e1 = L.Entry1;
                return hash == e0.Hash ? e0 : hash == e1.Hash ? e1 : (ImHashMap<K, V>)new Leaf2Plus1Plus1(entry, this);
            }

            public sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) =>
                oldEntry == Plus     ? new Leaf2Plus1(newEntry, L) :
                oldEntry == L.Entry0 ? new Leaf2Plus1(Plus, new Leaf2(newEntry, L.Entry1)) :
                                       new Leaf2Plus1(Plus, new Leaf2(L.Entry0, newEntry));

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>
                removedEntry == Plus ? L :
                removedEntry == L.Entry0 ? 
                    (Plus.Hash < L.Entry1.Hash ? new Leaf2(Plus, L.Entry1) : new Leaf2(L.Entry1, Plus)) :
                    (Plus.Hash < L.Entry0.Hash ? new Leaf2(Plus, L.Entry0) : new Leaf2(L.Entry0, Plus));
        }

        /// <summary>Leaf with the Leaf2 plus added entry, plus added entry</summary>
        internal sealed class Leaf2Plus1Plus1 : ImHashMap<K, V>
        {
            public readonly Entry Plus;
            public readonly Leaf2Plus1 L;

            public Leaf2Plus1Plus1(Entry plus, Leaf2Plus1 l)
            {
                Plus = plus;
                L = l;
            }

            public override int Count() => Plus.Count() + L.Plus.Count() + L.L.Entry0.Count() + L.L.Entry1.Count();

#if !DEBUG
            public override string ToString() => "{L211:{P:" + Plus + ", L:" + L + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault() 
            {
                var m = L.GetMinHashEntryOrDefault();
                return Plus.Hash < m.Hash ? Plus : m;
            }
            internal sealed override Entry GetMaxHashEntryOrDefault() 
            {
                var m = L.GetMaxHashEntryOrDefault();
                return Plus.Hash > m.Hash ? Plus : m;
            }

            internal override Entry GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash) 
                    return Plus;
                if (hash == L.Plus.Hash) 
                    return L.Plus;
                Entry e0 = L.L.Entry0, e1 = L.L.Entry1;
                return e0.Hash == hash ? e0 : e1.Hash == hash ? e1 : null;
            }

            public sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return p;

                var pp = L.Plus;
                var pph = pp.Hash;
                if (pph == hash)
                    return pp;

                var l = L.L;
                Entry e0 = l.Entry0, e1 = l.Entry1;

                if (hash == e0.Hash)
                    return e0;
                if (hash == e1.Hash)
                    return e1;

                if (pph < e1.Hash)
                {
                    Fun.Swap(ref e1, ref pp);
                    if (pph < e0.Hash)
                        Fun.Swap(ref e0, ref e1);
                }

                if (ph < pp.Hash)
                {
                    Fun.Swap(ref p, ref pp);
                    if (ph < e1.Hash)
                    {
                        Fun.Swap(ref pp, ref e1);
                        if (ph < e0.Hash)
                            Fun.Swap(ref e1, ref e0);
                    }
                }

                Entry e = entry;
                if (hash < p.Hash)
                {
                    Fun.Swap(ref e, ref p);
                    if (hash < pp.Hash)
                    {
                        Fun.Swap(ref p, ref pp);
                        if (hash < e1.Hash)
                        {
                            Fun.Swap(ref pp, ref e1);
                            if (hash < e0.Hash)
                                Fun.Swap(ref e1, ref e0);
                        }
                    }
                }

                return new Leaf5(e0, e1, pp, p, e);
            }

            public sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) =>
                oldEntry == Plus       ? new Leaf2Plus1Plus1(newEntry, L) :
                oldEntry == L.Plus     ? new Leaf2Plus1Plus1(Plus, new Leaf2Plus1(newEntry, L.L)) :
                oldEntry == L.L.Entry0 ? new Leaf2Plus1Plus1(Plus, new Leaf2Plus1(L.Plus, new Leaf2(newEntry, L.L.Entry1))) :
                                         new Leaf2Plus1Plus1(Plus, new Leaf2Plus1(L.Plus, new Leaf2(L.L.Entry0, newEntry)));

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>
                removedEntry == Plus ? L : 
                removedEntry == L.Plus ? new Leaf2Plus1(Plus, L.L) :
                removedEntry == L.L.Entry0 ? 
                    (L.Plus.Hash < L.L.Entry1.Hash ? new Leaf2Plus1(Plus, new Leaf2(L.Plus, L.L.Entry1)) : new Leaf2Plus1(Plus, new Leaf2(L.L.Entry1, L.Plus))) :
                    (L.Plus.Hash < L.L.Entry0.Hash ? new Leaf2Plus1(Plus, new Leaf2(L.Plus, L.L.Entry0)) : new Leaf2Plus1(Plus, new Leaf2(L.L.Entry0, L.Plus)));
        }

        /// <summary>Leaf with 5 hash-ordered entries</summary>
        internal sealed class Leaf5 : ImHashMap<K, V>
        {
            public readonly Entry Entry0, Entry1, Entry2, Entry3, Entry4;

            public Leaf5(Entry e0, Entry e1, Entry e2, Entry e3, Entry e4)
            {
                Debug.Assert(e0.Hash < e1.Hash, "e0 < e1");
                Debug.Assert(e1.Hash < e2.Hash, "e1 < e2");
                Debug.Assert(e2.Hash < e3.Hash, "e2 < e3");
                Debug.Assert(e3.Hash < e4.Hash, "e3 < e4");
                Entry0 = e0; Entry1 = e1; Entry2 = e2; Entry3 = e3; Entry4 = e4;
            }

            public override int Count() => Entry0.Count() + Entry1.Count() + Entry2.Count() + Entry3.Count() + Entry4.Count();

#if !DEBUG
            public override string ToString() => 
                "{L2:{E0:" + Entry0 + ", E1:" + Entry1 + ", E2:" + Entry2 + ",E3:" + Entry3 + ",E4:" + Entry4 + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault() => Entry0;
            internal sealed override Entry GetMaxHashEntryOrDefault() => Entry4;

            internal override Entry GetEntryOrNull(int hash) =>
                hash == Entry0.Hash ? Entry0 :
                hash == Entry1.Hash ? Entry1 :
                hash == Entry2.Hash ? Entry2 :
                hash == Entry3.Hash ? Entry3 :
                hash == Entry4.Hash ? Entry4 :
                null;

            public sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>
                hash == Entry0.Hash ? Entry0 :
                hash == Entry1.Hash ? Entry1 :
                hash == Entry2.Hash ? Entry2 :
                hash == Entry3.Hash ? Entry3 :
                hash == Entry4.Hash ? Entry4 :
                (ImHashMap<K, V>)new Leaf5Plus1(entry, this);

            public sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry) =>
                oldEntry == Entry0 ? new Leaf5(newEntry, Entry1, Entry2, Entry3, Entry4) : 
                oldEntry == Entry1 ? new Leaf5(Entry0, newEntry, Entry2, Entry3, Entry4) :
                oldEntry == Entry2 ? new Leaf5(Entry0, Entry1, newEntry, Entry3, Entry4) :
                oldEntry == Entry3 ? new Leaf5(Entry0, Entry1, Entry2, newEntry, Entry4) :
                                     new Leaf5(Entry0, Entry1, Entry2, Entry3, newEntry);

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>
                removedEntry == Entry0 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry3, new Leaf2(Entry1, Entry2))) : 
                removedEntry == Entry1 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry3, new Leaf2(Entry0, Entry2))) :
                removedEntry == Entry2 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry3, new Leaf2(Entry0, Entry1))) :
                removedEntry == Entry3 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry2, new Leaf2(Entry0, Entry1))) :
                                         new Leaf2Plus1Plus1(Entry3, new Leaf2Plus1(Entry2, new Leaf2(Entry0, Entry1)));
        }

        /// <summary>Leaf with 5 existing ordered entries plus 1 newly added entry.</summary>
        internal sealed class Leaf5Plus1 : ImHashMap<K, V>
        {
            public readonly Entry Plus;
            public readonly Leaf5 L;
            public Leaf5Plus1(Entry plus, Leaf5 l)
            {
                Plus = plus;
                L    = l;
            }

            public override int Count() => Plus.Count() + L.Count();

#if !DEBUG
            public override string ToString() => "{L51:{P:" + Plus + ",L:" + L + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault() => Plus.Hash < L.Entry0.Hash ? Plus : L.Entry0; 
            internal sealed override Entry GetMaxHashEntryOrDefault() => Plus.Hash > L.Entry4.Hash ? Plus : L.Entry4; 

            internal override Entry GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash) 
                    return Plus; 
                var l = L;
                return hash == l.Entry0.Hash ? l.Entry0 
                    :  hash == l.Entry1.Hash ? l.Entry1 
                    :  hash == l.Entry2.Hash ? l.Entry2 
                    :  hash == l.Entry3.Hash ? l.Entry3 
                    :  hash == l.Entry4.Hash ? l.Entry4 
                    :  null;
            }

            public sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return p;
                var l = L; 
                return hash == l.Entry0.Hash ? l.Entry0
                    :  hash == l.Entry1.Hash ? l.Entry1 
                    :  hash == l.Entry2.Hash ? l.Entry2
                    :  hash == l.Entry3.Hash ? l.Entry3
                    :  hash == l.Entry4.Hash ? l.Entry4
                    :  (ImHashMap<K, V>)new Leaf5Plus1Plus1(entry, this);
            }

            public sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry)
            {
                var p = Plus;
                if (oldEntry == p)
                    return new Leaf5Plus1(newEntry, L);
                var l = L; 
                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;
                return oldEntry == e0 ? new Leaf5Plus1(p, new Leaf5(newEntry, e1, e2, e3, e4)) 
                    :  oldEntry == e1 ? new Leaf5Plus1(p, new Leaf5(e0, newEntry, e2, e3, e4)) 
                    :  oldEntry == e2 ? new Leaf5Plus1(p, new Leaf5(e0, e1, newEntry, e3, e4)) 
                    :  oldEntry == e3 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, newEntry, e4)) 
                    :                   new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, newEntry));
            }

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)
            {
                var p = Plus;
                if (p == removedEntry)
                    return L;

                var ph = p.Hash;
                var l = L; 
                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;

                if (ph < e4.Hash)
                {
                    swap = e4; e4 = p; p = swap;
                    if (ph < e3.Hash)
                    {
                        swap = e3; e3 = e4; e4 = swap;
                        if (ph < e2.Hash)
                        {
                            swap = e2; e2 = e3; e3 = swap;
                            if (ph < e1.Hash)
                            {
                                swap = e1; e1 = e2; e2 = swap;
                                if (ph < e0.Hash)
                                {
                                    swap = e0; e0 = e1; e1 = swap;
                                }
                            }
                        }
                    }
                }

                return removedEntry == e0 ? new Leaf5(e1, e2, e3, e4, p)
                    :  removedEntry == e1 ? new Leaf5(e0, e2, e3, e4, p)
                    :  removedEntry == e2 ? new Leaf5(e0, e1, e3, e4, p)
                    :  removedEntry == e3 ? new Leaf5(e0, e1, e2, e4, p)
                    :  removedEntry == e4 ? new Leaf5(e0, e1, e2, e3, p)
                    :                       new Leaf5(e0, e1, e2, e3, e4);
            }
        }

        internal abstract class OnTheVergeOfBalance : ImHashMap<K, V>
        {
            internal abstract ImHashMap<K, V> AddOrGetEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight);
        }

        /// <summary>Leaf with 5 existing ordered entries plus 1 newly added, plus 1 newly added.</summary>
        internal sealed class Leaf5Plus1Plus1 : OnTheVergeOfBalance
        {
            public readonly Entry Plus;
            public readonly Leaf5Plus1 L;
            public Leaf5Plus1Plus1(Entry plus, Leaf5Plus1 l)
            {
                Plus = plus;
                L    = l;
            }

            public override int Count() => Plus.Count() + L.Count();

#if !DEBUG
            public override string ToString() => "{L511:{P:" + Plus + ",L:" + L + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault()
            {
                var m = L.GetMinHashEntryOrDefault();
                return Plus.Hash < m.Hash ? Plus : m;
            } 
            internal sealed override Entry GetMaxHashEntryOrDefault()
            {
                var m = L.GetMaxHashEntryOrDefault();
                return Plus.Hash > m.Hash ? Plus : m;
            }

            internal override Entry GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash)
                    return Plus;
                if (hash == L.Plus.Hash)
                    return L.Plus;
                var l = L.L;
                return hash == l.Entry0.Hash ? l.Entry0 
                    :  hash == l.Entry1.Hash ? l.Entry1 
                    :  hash == l.Entry2.Hash ? l.Entry2 
                    :  hash == l.Entry3.Hash ? l.Entry3 
                    :  hash == l.Entry4.Hash ? l.Entry4 
                    :  null;
            }

            public override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                ImHashMap<K, V> splitRight = null;
                var entryOrNewMap = AddOrGetEntry(hash, ref entry, ref splitRight);
                if (splitRight != null)
                    return new Branch2(entryOrNewMap, entry, splitRight);
                return entryOrNewMap;
            }

            internal override ImHashMap<K, V> AddOrGetEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return p;

                var pp = L.Plus;
                var pph = pp.Hash;
                if (pph == hash)
                    return pp;

                var l = L.L;
                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;

                if (hash == e0.Hash)
                    return e0;
                if (hash == e1.Hash)
                    return e1;
                if (hash == e2.Hash)
                    return e2;
                if (hash == e3.Hash)
                    return e3;
                if (hash == e4.Hash)
                    return e4;

                var right = hash > e4.Hash && ph > e4.Hash && pph > e4.Hash;
                var left  = !right && hash < e0.Hash && ph < e0.Hash && pph < e0.Hash;

                Entry swap = null;
                if (pph < e4.Hash)
                {
                    swap = e4; e4 = pp; pp = swap;
                    if (pph < e3.Hash)
                    {
                        swap = e3; e3 = e4; e4 = swap;
                        if (pph < e2.Hash)
                        {
                            swap = e2; e2 = e3; e3 = swap;
                            if (pph < e1.Hash)
                            {
                                swap = e1; e1 = e2; e2 = swap;
                                if (pph < e0.Hash)
                                {
                                    swap = e0; e0 = e1; e1 = swap;
                                }
                            }
                        }
                    }
                }

                if (ph < pp.Hash)
                {
                    swap = pp; pp = p; p = swap;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }
                }

                Entry e = entry;
                if (hash < p.Hash)
                {
                    swap = p; p = e; e = swap;
                    if (hash < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (hash < e4.Hash)
                        {
                            swap = e4; e4 = pp; pp = swap;
                            if (hash < e3.Hash)
                            {
                                swap = e3; e3 = e4; e4 = swap;
                                if (hash < e2.Hash)
                                {
                                    swap = e2; e2 = e3; e3 = swap;
                                    if (hash < e1.Hash)
                                    {
                                        swap = e1; e1 = e2; e2 = swap;
                                        if (hash < e0.Hash)
                                        {
                                            swap = e0; e0 = e1; e1 = swap;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (left)
                {
                    entry = e2;
                    splitRight = l;
                    return new Leaf2(e0, e1);
                }

                entry = pp;
                splitRight = new Leaf2(p, e);
                return right ? l : new Leaf5(e0, e1, e2, e3, e4);
            }


            public sealed override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry)
            {
                var p = Plus;
                if (p == oldEntry)
                    return new Leaf5Plus1Plus1(newEntry, L);

                var pp = L.Plus;
                if (pp == oldEntry)
                    return new Leaf5Plus1Plus1(p, new Leaf5Plus1(newEntry, L.L));

                var l = L.L;
                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;
                return
                    oldEntry == e0 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(newEntry, e1, e2, e3, e4))) :
                    oldEntry == e1 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, newEntry, e2, e3, e4))) :
                    oldEntry == e2 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, e1, newEntry, e3, e4))) :
                    oldEntry == e3 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, e1, e2, newEntry, e4))) :
                                     new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, e1, e2, e3, newEntry)));
            }

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)
            {
                var p = Plus;
                if (p == removedEntry)
                    return L;

                var pp = L.Plus;
                if (pp == removedEntry)
                    return new Leaf5Plus1(p, L.L);

                var l = L.L;
                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;
                int pph = pp.Hash, ph = p.Hash; 
                if (pph < e4.Hash)
                {
                    swap = e4; e4 = pp; pp = swap;
                    if (pph < e3.Hash)
                    {
                        swap = e3; e3 = e4; e4 = swap;
                        if (pph < e2.Hash)
                        {
                            swap = e2; e2 = e3; e3 = swap;
                            if (pph < e1.Hash)
                            {
                                swap = e1; e1 = e2; e2 = swap;
                                if (pph < e0.Hash)
                                {
                                    swap = e0; e0 = e1; e1 = swap;
                                }
                            }
                        }
                    }
                }
                if (ph < pp.Hash)
                {
                    swap = pp; pp = p; p = swap;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }
                }

                return removedEntry == e0 ? new Leaf5Plus1(p, new Leaf5(e1, e2, e3, e4, pp)) 
                    :  removedEntry == e1 ? new Leaf5Plus1(p, new Leaf5(e0, e2, e3, e4, pp))
                    :  removedEntry == e2 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e3, e4, pp))
                    :  removedEntry == e3 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e4, pp))
                    :  removedEntry == e4 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, pp))
                    :  removedEntry == pp ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))
                    :                       new Leaf5Plus1(pp,new Leaf5(e0, e1, e2, e3, e4));
            }
        }

        /// <summary>Branch of 2 leafs or branches with entry in the middle</summary>
        internal class Branch2 : ImHashMap<K, V>
        {
            public readonly ImHashMap<K, V> Left;
            public readonly Entry MidEntry;
            public readonly ImHashMap<K, V> Right;

            public Branch2(ImHashMap<K, V> left, Entry entry, ImHashMap<K, V> right)
            {
                Debug.Assert(left != Empty && right != Empty, $"left:{left} != Empty && right:{right} != Empty");
                MidEntry = entry;
                Left     = left;
                Right    = right;
            }

            public sealed override int Count() => MidEntry.Count() + Left.Count() + Right.Count();

#if !DEBUG
            public override string ToString() => "{B2:{E:" + MidEntry + ",L:" + Left + ",R:" + Right + "}}";
#endif

            internal sealed override Entry GetMinHashEntryOrDefault() => Left .GetMinHashEntryOrDefault();
            internal sealed override Entry GetMaxHashEntryOrDefault() => Right.GetMaxHashEntryOrDefault();

            internal override Entry GetEntryOrNull(int hash) 
            {
                var h = MidEntry.Hash;
                return hash > h ? Right.GetEntryOrNull(hash) 
                    :  hash < h ? Left .GetEntryOrNull(hash) 
                    :  MidEntry;
            }

            public override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                var e = MidEntry;
                ImHashMap<K, V> newBranch = null;
                if (hash > e.Hash)
                {
                    var right = Right;
                    if (right is OnTheVergeOfBalance r) 
                    {
                        ImHashMap<K, V> splitRight = null;
                        newBranch = r.AddOrGetEntry(hash, ref entry, ref splitRight);
                        if (splitRight != null)
                            return new Branch3(Left, e, newBranch, entry, splitRight);
                    }
                    else newBranch = right.AddOrGetEntry(hash, entry);
                    return newBranch is Entry ? newBranch : new Branch2(Left, e, newBranch);
                }

                if (hash < e.Hash)
                {
                    var left = Left;
                    if (left is OnTheVergeOfBalance l) 
                    {
                        ImHashMap<K, V> splitRight = null;
                        newBranch = l.AddOrGetEntry(hash, ref entry, ref splitRight);
                        if (splitRight != null)
                            return new Branch3(newBranch, entry, splitRight, e, Right);
                    }
                    else newBranch = left.AddOrGetEntry(hash, entry);
                    return newBranch is Entry ? newBranch : new Branch2(newBranch, e, Right);
                }

                return e;
            }

            public override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry)
            {
                var h = MidEntry.Hash;
                return hash > h ? new Branch2(Left, MidEntry, Right.ReplaceEntry(hash, oldEntry, newEntry))
                    :  hash < h ? new Branch2(Left.ReplaceEntry(hash, oldEntry, newEntry), MidEntry, Right)
                    :  new Branch2(Left, newEntry, Right);
            }

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) 
            {
                // The downward phase for deleting an element from a 2-3 tree is the same as the downward phase
                // for inserting an element except for the case when the element to be deleted is equal to the value in
                // a 2-node or a 3-node. In this case, if the value is not part of a terminal node, the value is replaced
                // by its in-order predecessor or in-order successor, just as in binary search tree deletion. So in any
                // case, deletion leaves a hole in a terminal node.
                // The goal of the rest of the deletion algorithm is to remove the hole without violating the other
                // invariants of the 2-3 tree.

                var mid = MidEntry;
                if (removedEntry.Hash > mid.Hash)
                {
                    var newRight = Right.RemoveEntry(removedEntry);
                    if (newRight == Empty)
                    {
                        // if the left node is not full yet then merge
                        if (Left is Leaf2Plus1Plus1 == false) 
                            return Left.AddOrGetEntry(mid.Hash, mid);
                        return new Branch2(Left.RemoveEntry(removedEntry = Left.GetMaxHashEntryOrDefault()), removedEntry, mid); //! the height does not change
                    }

                    //*rebalance needed: the branch was merged from Br2 to Br3 or to the leaf and the height decreased 
                    if (Right is Branch2 && newRight is Branch2 == false)
                    {
                        // the the hole has a 2-node as a parent and a 3-node as a sibling.
                        if (Left is Branch3 lb3) //! the height does not change
                            return new Branch2(new Branch2(lb3.Left, lb3.Entry0, lb3.Middle), lb3.Entry1, new Branch2(lb3.Right, mid, newRight));

                        // the the hole has a 2-node as a parent and a 2-node as a sibling.
                        var lb2 = (Branch2)Left; 
                        return new Branch3(lb2.Left, lb2.MidEntry, lb2.Right, mid, newRight);
                    }

                    return new Branch2(Left, mid, newRight);
                }

                // case 1, downward: swap the predecessor entry (max left entry) with the mid entry, then proceed to remove the predecessor from the Left branch
                if (removedEntry == mid)
                    removedEntry = mid = Left.GetMaxHashEntryOrDefault();

                // case 1, upward
                var newLeft = Left.RemoveEntry(removedEntry);
                if (newLeft == Empty)
                {
                    if (Right is Leaf2Plus1Plus1 == false) 
                        return Right.AddOrGetEntry(mid.Hash, mid);
                    return new Branch2(mid, removedEntry = Right.GetMinHashEntryOrDefault(), Right.RemoveEntry(removedEntry)); //! the height does not change
                }

                //*rebalance needed: the branch was merged from Br2 to Br3 or to the leaf and the height decreased 
                if (Left is Branch2 && newLeft is Branch2 == false)
                {
                    // the the hole has a 2-node as a parent and a 3-node as a sibling.
                    if (Right is Branch3 rb3) //! the height does not change
                        return new Branch2(new Branch2(newLeft, mid, rb3.Left), rb3.Entry0, new Branch2(rb3.Middle, rb3.Entry0, rb3.Right));

                    // the the hole has a 2-node as a parent and a 2-node as a sibling.
                    var rb2 = (Branch2)Right;
                    return new Branch3(newLeft, mid, rb2.Left, rb2.MidEntry, rb2.Right);
                }

                return new Branch2(newLeft, mid, Right);
            }
        }

        /// <summary>Branch of 3 with 2 nodes in between</summary>
        internal sealed class Branch3 : OnTheVergeOfBalance
        {
            public readonly Entry Entry0, Entry1;
            public readonly ImHashMap<K, V> Left, Middle, Right;

            public Branch3(ImHashMap<K, V> left, Entry e0, ImHashMap<K, V> middle, Entry e1, ImHashMap<K, V> right) 
            {
                Debug.Assert(e0.Hash < e1.Hash, $"e0.Hash:{e0.Hash} < e1.Hash{e1.Hash}");
                Left   = left;
                Entry0 = e0;
                Middle = middle;
                Entry1 = e1;
                Right  = right;
            }

            public override int Count() => Entry0.Count() + Entry1.Count() + Left.Count() + Middle.Count() + Right.Count();

#if !DEBUG
            public override string ToString() => "{B3:{E0:" + Entry0 + ",E1:" + Entry0 + ",L:" + Left + ",M:" + Middle + ",R:" + Right + "}}";
#endif

            internal override Entry GetMinHashEntryOrDefault() => Left .GetMinHashEntryOrDefault();
            internal override Entry GetMaxHashEntryOrDefault() => Right.GetMaxHashEntryOrDefault();

            internal override Entry GetEntryOrNull(int hash) 
            {
                var h1 = Entry1.Hash;
                if (hash > h1)
                    return Right.GetEntryOrNull(hash);
                var h0 = Entry0.Hash;
                if (hash < h0)
                    return Left.GetEntryOrNull(hash);
                if (h0 == hash)
                    return Entry0;
                if (h1 == hash)
                    return Entry1;
                return Middle.GetEntryOrNull(hash);
            }

            public override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)
            {
                var h1 = Entry1.Hash;
                if (hash > h1)
                {
                    var right = Right;
                    var newRight = right.AddOrGetEntry(hash, entry);
                    if (newRight is Entry)
                        return newRight;
                    if (right is OnTheVergeOfBalance && newRight is Branch2)
                        return new Branch2(new Branch2(Left, Entry0, Middle), Entry1, newRight);
                    return new Branch3(Left, Entry0, Middle, Entry1, newRight);
                }

                var h0 = Entry0.Hash;
                if (hash < h0)
                {
                    var left = Left;
                    var newLeft = left.AddOrGetEntry(hash, entry);
                    if (newLeft is Entry)
                        return newLeft;
                    if (left is OnTheVergeOfBalance && newLeft is Branch2)
                        return new Branch2(newLeft, Entry0, new Branch2(Middle, Entry1, Right));
                    return new Branch3(newLeft, Entry0, Middle, Entry1, Right);
                }

                if (hash > h0 && hash < h1)
                {
                    var middle = Middle;
                    ImHashMap<K, V> newBranch = null;
                    if (middle is OnTheVergeOfBalance m)
                    {
                        ImHashMap<K, V> splitMiddleRight = null;
                        newBranch = m.AddOrGetEntry(hash, ref entry, ref splitMiddleRight);
                        if (splitMiddleRight != null)
                            return new Branch2(new Branch2(Left, Entry0, newBranch), entry, new Branch2(splitMiddleRight, Entry1, Right));
                    }
                    else newBranch = middle.AddOrGetEntry(hash, entry);
                    return newBranch is Entry ? newBranch : new Branch3(Left, Entry0, newBranch, Entry1, Right);
                }

                return hash == h0 ? Entry0 : Entry1;
            }

            internal override ImHashMap<K, V> AddOrGetEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight)
            {
                var h1 = Entry1.Hash;
                if (hash > h1)
                {
                    var right = Right;
                    var newRight = right.AddOrGetEntry(hash, entry);
                    if (newRight is Entry)
                        return newRight;
                    if (right is OnTheVergeOfBalance && newRight is Branch2)
                    {
                        entry = Entry1;
                        splitRight = newRight;
                        return new Branch2(Left, Entry0, Middle);
                    }
                    return new Branch3(Left, Entry0, Middle, Entry1, newRight);
                }

                var h0 = Entry0.Hash;
                if (hash < h0)
                {
                    var left = Left;
                    var newLeft = left.AddOrGetEntry(hash, entry);
                    if (newLeft is Entry)
                        return newLeft;
                    if (left is OnTheVergeOfBalance && newLeft is Branch2)
                    {
                        entry = Entry0;
                        splitRight = new Branch2(Middle, Entry1, Right);
                        return newLeft;
                    }

                    return new Branch3(newLeft, Entry0, Middle, Entry1, Right);
                }

                if (hash > h0 && hash < h1)
                {
                    var middle = Middle;
                    ImHashMap<K, V> newBranch = null;
                    if (middle is OnTheVergeOfBalance m)
                    {
                        ImHashMap<K, V> splitMiddleRight = null;
                        newBranch = m.AddOrGetEntry(hash, ref entry, ref splitMiddleRight);
                        if (splitMiddleRight != null)
                        {
                            // entry = entry; we don't need to assign the entry because it is already containing the proper value
                            splitRight = new Branch2(splitMiddleRight, Entry1, Right);
                            return new Branch2(Left, Entry0, newBranch);
                        }
                    }
                    else
                        newBranch = middle.AddOrGetEntry(hash, entry);
                    if (newBranch is Entry)
                        return newBranch;
                    return new Branch3(Left, Entry0, newBranch, Entry1, Right);
                }

                return hash == h0 ? Entry0 : Entry1;
            }

            public override ImHashMap<K, V> ReplaceEntry(int hash, Entry oldEntry, Entry newEntry)
            {
                int h0 = Entry0.Hash, h1 = Entry1.Hash;
                return hash > h1 ? new Branch3(Left, Entry0, Middle, Entry1, Right.ReplaceEntry(hash, oldEntry, newEntry)) 
                    :  hash < h0 ? new Branch3(Left.ReplaceEntry(hash, oldEntry, newEntry), Entry0, Middle, Entry1, Right)
                    :  hash > h0 && hash < h1 ? new Branch3(Left, Entry0, Middle.ReplaceEntry(hash, oldEntry, newEntry), Entry1, Right)
                    :  oldEntry == Entry0 ? new Branch3(Left, newEntry, Middle, Entry1, Right) : new Branch3(Left, Entry0, Middle, newEntry, Right);
            }

            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)
            {
                var midLeft  = Entry0;
                var middle   = Middle;
                var midRight = Entry1;
                var right    = Right;

                // case 1, downward: swap the predecessor entry (max left entry) with the mid entry, then proceed to remove the predecessor from the Left branch
                if (removedEntry == midLeft)
                    removedEntry = midLeft = Left.GetMaxHashEntryOrDefault();

                if (removedEntry.Hash <= midLeft.Hash)
                {
                    var newLeft = Left.RemoveEntry(removedEntry);
                    if (newLeft == Empty)
                    {
                        if (middle is Leaf2Plus1Plus1 == false) 
                            return new Branch2(middle.AddOrGetEntry(midLeft.Hash, midLeft), midRight, right); //! the height does not change
                        return new Branch3(midLeft, removedEntry = middle.GetMinHashEntryOrDefault(), middle.RemoveEntry(removedEntry), midRight, right); //! the height does not change
                    }

                    // rebalance is needed because the branch was merged from Br2 to Br3 or to Leaf and the height decrease
                    if (Left is Branch2 && newLeft is Branch2 == false)
                    {
                        // the hole has a 3-node as a parent and a 3-node as a sibling.
                        if (middle is Branch3 mb3) //! the height does not change
                            return new Branch3(new Branch2(newLeft, midLeft, mb3.Left), mb3.Entry0, new Branch2(mb3.Middle, mb3.Entry1, mb3.Right), midRight, right);

                        // the hole has a 3-node as a parent and a 2-node as a sibling.
                        var mb2 = (Branch2)middle;
                        return new Branch2(new Branch3(newLeft, midLeft, mb2.Left, mb2.MidEntry, mb2.Right), midRight, right);
                    }

                    return new Branch3(newLeft, midLeft, middle, midRight, right); // no rebalance needed
                }

                if (removedEntry == midRight)
                    removedEntry = midRight = middle.GetMaxHashEntryOrDefault();

                if (removedEntry.Hash <= midRight.Hash)
                {
                    var newMiddle = middle.RemoveEntry(removedEntry);
                    if (newMiddle == Empty)
                    {
                        if (right is Leaf2Plus1Plus1 == false)
                            return new Branch2(Left, midLeft, right.AddOrGetEntry(midLeft.Hash, midLeft)); // the Br3 become the Br2 but the height did not change - so no rebalance needed
                        return new Branch3(Left, midLeft, midRight, removedEntry = right.GetMinHashEntryOrDefault(), right.RemoveEntry(removedEntry)); //! the height does not change
                    }

                    if (middle is Branch2 && newMiddle is Branch2 == false)
                    {
                        // the hole has a 3-node as a parent and a 3-node as a sibling.
                        if (right is Branch3 rb3) //! the height does not change
                            return new Branch3(Left, midLeft, new Branch2(newMiddle, midRight, rb3.Left), rb3.Entry0, new Branch2(rb3.Middle, rb3.Entry1, rb3.Right));

                        // the hole has a 3-node as a parent and a 2-node as a sibling.
                        var rb2 = (Branch2)right;
                        return new Branch2(Left, midLeft, new Branch3(newMiddle, midRight, rb2.Left, rb2.MidEntry, rb2.Right));
                    }

                    return new Branch3(Left, midLeft, newMiddle, midRight, right);
                }

                var newRight = right.RemoveEntry(removedEntry);
                if (newRight == Empty)
                {
                    if (middle is Leaf2Plus1Plus1 == false)
                        return new Branch2(Left, midLeft, middle.AddOrGetEntry(midRight.Hash, midRight));
                    return new Branch3(Left, midLeft, middle.RemoveEntry(removedEntry = middle.GetMaxHashEntryOrDefault()), removedEntry, midRight);
                }

                // right was a Br2 but now is Leaf or Br3 - means the branch height is decrease
                if (right.GetType() == typeof(Branch2) && newRight.GetType() != typeof(Branch2))
                {
                    // the hole has a 3-node as a parent and a 3-node as a sibling.new
                    if (middle is Branch3 mb3) //! the height does not change
                        return new Branch3(Left, midLeft, new Branch2(mb3.Left, mb3.Entry0, mb3.Middle), mb3.Entry1, new Branch2(mb3.Right, midRight, newRight));

                    // the hole has a 3-node as a parent and a 2-node as a sibling.
                    var mb2 = (Branch2)middle;
                    return new Branch2(Left, midLeft, new Branch3(mb2.Left, mb2.MidEntry, mb2.Right, midRight, newRight));
                }

                return new Branch3(Left, midLeft, middle, midRight, newRight);
            }
        }
    }

    /// <summary>Entry containing the Value in addition to the Hash</summary>
    public class ImMapEntry<V> : ImMap<V>
    {
        /// <summary>The hash.</summary>
        public readonly int Hash;
        /// <summary>The Key is actually the Hash for this entry and the vice versa.</summary>
        public int Key => Hash;
        /// <summary>The value. Maybe modified if you need the Ref{Value} semantics. 
        /// You may add the entry with the default Value to the map, and calculate and set it later (e.g. using the CAS).</summary>
        public V Value;

        /// <summary>Constructs the entry with the default value</summary>
        public ImMapEntry(int hash) => Hash = hash;
        /// <summary>Constructs the entry with the value</summary>
        public ImMapEntry(int hash, V value) { Hash = hash; Value = value; }

#if !DEBUG
        /// <inheritdoc />
        public sealed override string ToString() => "{H:" + Hash + ",V:" + Value + "}";
#endif

        /// <inheritdoc />
        public sealed override int Count() => 1;

        internal sealed override ImMapEntry<V> GetMaxHashEntryOrDefault() => this;
        internal sealed override ImMapEntry<V> GetMinHashEntryOrDefault() => this;

        internal sealed override ImMapEntry<V> GetEntryOrNull(int hash) => hash == Hash ? this : null;

        internal sealed override ImMap<V> AddOrGetEntry(int hash, ImMapEntry<V> entry) =>
            hash > Hash ? new Leaf2(this, entry) : hash < Hash ? new Leaf2(entry, this) : (ImMap<V>)this;

        internal sealed override ImMap<V> ReplaceEntry(int hash, ImMapEntry<V> oldEntry, ImMapEntry<V> newEntry) => 
            this == oldEntry ? newEntry : oldEntry;

        internal sealed override ImMap<V> RemoveEntry(ImMapEntry<V> removedEntry) =>
            this == removedEntry ? Empty : this;
    }

    /// <summary>The base and the holder class for the map tree leafs and branches, also defines the Empty tree.
    /// The map implementation is based on the "modified" 2-3 tree.</summary>
    public class ImMap<V>
    {
        /// <summary>Hide the base constructor to prevent the multiple Empty trees creation</summary>
        protected ImMap() { }

        /// <summary>Empty map to start with. Exists as a single instance.</summary>
        public static readonly ImMap<V> Empty = new ImMap<V>();

        /// <summary>Prints the map tree in JSON-ish format in release mode and enumerates the keys in DEBUG.</summary>
        public override string ToString() 
        {
#if DEBUG
            // for the debug purposes we just output the first N keys in array
            const int n = 50;
            var count = this.Count();
            var hashes = this.Enumerate().Take(n).Select(x => x.Hash).ToList();
            return $"{{hashes: new int[{(count > n ? $"{n}/{count}" : "" + count)}] {{{(string.Join(", ", hashes))}}}}}";
#else
            return "{}";
#endif
        }

        /// <summary>Indicates that the map is empty</summary>
        public bool IsEmpty => this == Empty;

        /// <summary>The count of entries in the map</summary>
        public virtual int Count() => 0;

        internal virtual ImMapEntry<V> GetMinHashEntryOrDefault() => null;
        internal virtual ImMapEntry<V> GetMaxHashEntryOrDefault() => null;

        /// <summary>Lookup for the entry by hash. 
        /// You need to check the returned entry type because it maybe the `HashConflictKeyValuesEntry` which contain multiple key value entries for the same hash. For the `int` key you may be sure that the `ImHashMapEntry{V}` is always returned.
        /// If nothing the method returns `null`</summary>
        internal virtual ImMapEntry<V> GetEntryOrNull(int hash) => null;

        /// <summary>Returns the found entry with the same hash or the new map with added new entry.
        /// Note that the empty map will return the entry the same as if the entry was found - so the consumer should check for the empty map.
        /// Note that the method cannot return the `null` - when the existing entry is not found it will alway be the new map with the added entry.</summary>
        internal virtual ImMap<V> AddOrGetEntry(int hash, ImMapEntry<V> entry) => entry;

        /// <summary>Returns the new map with old entry replaced by the new entry. Note that the old entry should be present.</summary>
        internal virtual ImMap<V> ReplaceEntry(int hash, ImMapEntry<V> oldEntry, ImMapEntry<V> newEntry) => this;

        /// <summary>Removes the certainly present old entry and returns the new map without it.</summary>
        internal virtual ImMap<V> RemoveEntry(ImMapEntry<V> entry) => this;

        /// <summary>Leaf with 2 hash-ordered entries. Important: the both or either of entries may be null for the removed entries</summary>
        internal sealed class Leaf2 : ImMap<V>
        {
            public readonly ImMapEntry<V> Entry0, Entry1;
            public Leaf2(ImMapEntry<V> e0, ImMapEntry<V> e1)
            {
                Debug.Assert(e0.Hash < e1.Hash);
                Entry0 = e0; Entry1 = e1;
            }

            public override int Count() => 2;

#if !DEBUG
            public override string ToString() => "{L2:{E0: " + Entry0 + ",E1:" + Entry1 + "}}";
#endif

            internal sealed override ImMapEntry<V> GetMinHashEntryOrDefault() => Entry0;
            internal sealed override ImMapEntry<V> GetMaxHashEntryOrDefault() => Entry1;

            internal override ImMapEntry<V> GetEntryOrNull(int hash) => 
                Entry0.Hash == hash ? Entry0 : Entry1.Hash == hash ? Entry1 : null;

            internal override ImMap<V> AddOrGetEntry(int hash, ImMapEntry<V> entry) =>
                hash == Entry0.Hash ? Entry0 : hash == Entry1.Hash ? Entry1 : (ImMap<V>)new Leaf2Plus1(entry, this);

            internal override ImMap<V> ReplaceEntry(int hash, ImMapEntry<V> oldEntry, ImMapEntry<V> newEntry) =>
                oldEntry == Entry0 ? new Leaf2(newEntry, Entry1) : new Leaf2(Entry0, newEntry);

            internal override ImMap<V> RemoveEntry(ImMapEntry<V> removedEntry) =>
                Entry0 == removedEntry ? Entry1 : Entry0;
        }

        /// <summary>The leaf containing the Leaf2 plus the newest added entry.</summary>
        internal sealed class Leaf2Plus1 : ImMap<V>
        {
            public readonly ImMapEntry<V> Plus;
            public readonly Leaf2 L;

            public Leaf2Plus1(ImMapEntry<V> plus, Leaf2 leaf)
            {
                Plus = plus;
                L    = leaf;
            }

            public override int Count() => 3;

#if !DEBUG
            public override string ToString() => "{L21: {P: " + Plus + ", L: " + L + "}}";
#endif

            internal sealed override ImMapEntry<V> GetMinHashEntryOrDefault() => Plus.Hash < L.Entry0.Hash ? Plus : L.Entry0;
            internal sealed override ImMapEntry<V> GetMaxHashEntryOrDefault() => Plus.Hash > L.Entry1.Hash ? Plus : L.Entry1;

            internal override ImMapEntry<V> GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash) 
                    return Plus;
                ImMapEntry<V> e0 = L.Entry0, e1 = L.Entry1;
                return e0.Hash == hash ? e0 : e1.Hash == hash ? e1 : null;
            }

            internal override ImMap<V> AddOrGetEntry(int hash, ImMapEntry<V> entry)
            {
                var p = Plus;
                if (hash == p.Hash) 
                    return p;
                ImMapEntry<V> e0 = L.Entry0, e1 = L.Entry1;
                return hash == e0.Hash ? e0 : hash == e1.Hash ? e1 : (ImMap<V>)new Leaf2Plus1Plus1(entry, this);
            }

            internal override ImMap<V> ReplaceEntry(int hash, ImMapEntry<V> oldEntry, ImMapEntry<V> newEntry) =>
                oldEntry == Plus     ? new Leaf2Plus1(newEntry, L) :
                oldEntry == L.Entry0 ? new Leaf2Plus1(Plus, new Leaf2(newEntry, L.Entry1)) :
                                       new Leaf2Plus1(Plus, new Leaf2(L.Entry0, newEntry));

            internal override ImMap<V> RemoveEntry(ImMapEntry<V> removedEntry) =>
                removedEntry == Plus ? L :
                removedEntry == L.Entry0 ?
                    (Plus.Hash < L.Entry1.Hash ? new Leaf2(Plus, L.Entry1) : new Leaf2(L.Entry1, Plus)) :
                    (Plus.Hash < L.Entry0.Hash ? new Leaf2(Plus, L.Entry0) : new Leaf2(L.Entry0, Plus));
        }

        /// <summary>Leaf with the Leaf2 plus added entry, plus added entry</summary>
        internal sealed class Leaf2Plus1Plus1 : ImMap<V>
        {
            public readonly ImMapEntry<V> Plus;
            public readonly Leaf2Plus1 L;

            public Leaf2Plus1Plus1(ImMapEntry<V> plus, Leaf2Plus1 l)
            {
                Plus = plus;
                L = l;
            }

            public override int Count() => 4;

#if !DEBUG
            public override string ToString() => "{L211:{P:" + Plus + ",L:" + L + "}}";
#endif

            internal sealed override ImMapEntry<V> GetMinHashEntryOrDefault() 
            {
                var m = L.GetMinHashEntryOrDefault();
                return Plus.Hash < m.Hash ? Plus : m;
            }
            internal sealed override ImMapEntry<V> GetMaxHashEntryOrDefault() 
            {
                var m = L.GetMaxHashEntryOrDefault();
                return Plus.Hash > m.Hash ? Plus : m;
            }

            internal override ImMapEntry<V> GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash) 
                    return Plus;
                if (hash == L.Plus.Hash) 
                    return L.Plus;
                ImMapEntry<V> e0 = L.L.Entry0, e1 = L.L.Entry1;
                return e0.Hash == hash ? e0 : e1.Hash == hash ? e1 : null;
            }

            internal override ImMap<V> AddOrGetEntry(int hash, ImMapEntry<V> entry)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return p;

                var pp = L.Plus;
                var pph = pp.Hash;
                if (pph == hash)
                    return pp;

                var l = L.L;
                ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1;

                if (hash == e0.Hash)
                    return e0;
                if (hash == e1.Hash)
                    return e1;

                ImMapEntry<V> swap = null;
                if (pph < e1.Hash)
                {
                    swap = e1; e1 = pp; pp = swap;
                    if (pph < e0.Hash)
                    {
                        swap = e0; e0 = e1; e1 = swap;
                    }
                }

                if (ph < pp.Hash)
                {
                    swap = pp; pp = p; p = swap;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = pp; pp = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }
                }

                ImMapEntry<V> e = entry;
                if (hash < p.Hash)
                {
                    swap = p; p = e; e = swap;
                    if (hash < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (hash < e1.Hash)
                        {
                            swap = e1; e1 = pp; pp = swap;
                            if (hash < e0.Hash)
                            {
                                swap = e0; e0 = e1; e1 = swap;
                            }
                        }
                    }
                }

                return new Leaf5(e0, e1, pp, p, e);
            }

            internal override ImMap<V> ReplaceEntry(int hash, ImMapEntry<V> oldEntry, ImMapEntry<V> newEntry) =>
                oldEntry == Plus       ? new Leaf2Plus1Plus1(newEntry, L) :
                oldEntry == L.Plus     ? new Leaf2Plus1Plus1(Plus, new Leaf2Plus1(newEntry, L.L)) :
                oldEntry == L.L.Entry0 ? new Leaf2Plus1Plus1(Plus, new Leaf2Plus1(L.Plus, new Leaf2(newEntry, L.L.Entry1))) :
                                         new Leaf2Plus1Plus1(Plus, new Leaf2Plus1(L.Plus, new Leaf2(L.L.Entry0, newEntry)));

            internal override ImMap<V> RemoveEntry(ImMapEntry<V> removedEntry) =>
                removedEntry == Plus ? L : 
                removedEntry == L.Plus ? new Leaf2Plus1(Plus, L.L) :
                removedEntry == L.L.Entry0 ? 
                    (L.Plus.Hash < L.L.Entry1.Hash ? new Leaf2Plus1(Plus, new Leaf2(L.Plus, L.L.Entry1)) : new Leaf2Plus1(Plus, new Leaf2(L.L.Entry1, L.Plus))) :
                    (L.Plus.Hash < L.L.Entry0.Hash ? new Leaf2Plus1(Plus, new Leaf2(L.Plus, L.L.Entry0)) : new Leaf2Plus1(Plus, new Leaf2(L.L.Entry0, L.Plus)));
        }

        /// <summary>Leaf with 5 hash-ordered entries</summary>
        internal sealed class Leaf5 : ImMap<V>
        {
            public readonly ImMapEntry<V> Entry0, Entry1, Entry2, Entry3, Entry4;

            public Leaf5(ImMapEntry<V> e0, ImMapEntry<V> e1, ImMapEntry<V> e2, ImMapEntry<V> e3, ImMapEntry<V> e4)
            {
                Debug.Assert(e0.Hash < e1.Hash, "e0 < e1");
                Debug.Assert(e1.Hash < e2.Hash, "e1 < e2");
                Debug.Assert(e2.Hash < e3.Hash, "e2 < e3");
                Debug.Assert(e3.Hash < e4.Hash, "e3 < e4");
                Entry0 = e0; Entry1 = e1; Entry2 = e2; Entry3 = e3; Entry4 = e4;
            }

            public override int Count() => 5;

#if !DEBUG
            public override string ToString() => 
                "{L2:{E0:" + Entry0 + ",E1:" + Entry1 + ",E2:" + Entry2 + ",E3:" + Entry3 + ",E4:" + Entry4 + "}}";
#endif

            internal sealed override ImMapEntry<V> GetMinHashEntryOrDefault() => Entry0;
            internal sealed override ImMapEntry<V> GetMaxHashEntryOrDefault() => Entry4;

            internal override ImMapEntry<V> GetEntryOrNull(int hash) =>
                hash == Entry0.Hash ? Entry0 :
                hash == Entry1.Hash ? Entry1 :
                hash == Entry2.Hash ? Entry2 :
                hash == Entry3.Hash ? Entry3 :
                hash == Entry4.Hash ? Entry4 :
                null;

            internal override ImMap<V> AddOrGetEntry(int hash, ImMapEntry<V> entry) =>
                hash == Entry0.Hash ? Entry0 :
                hash == Entry1.Hash ? Entry1 :
                hash == Entry2.Hash ? Entry2 :
                hash == Entry3.Hash ? Entry3 :
                hash == Entry4.Hash ? Entry4 :
                (ImMap<V>)new Leaf5Plus1(entry, this);

            internal override ImMap<V> ReplaceEntry(int hash, ImMapEntry<V> oldEntry, ImMapEntry<V> newEntry) =>
                oldEntry == Entry0 ? new Leaf5(newEntry, Entry1, Entry2, Entry3, Entry4) : 
                oldEntry == Entry1 ? new Leaf5(Entry0, newEntry, Entry2, Entry3, Entry4) :
                oldEntry == Entry2 ? new Leaf5(Entry0, Entry1, newEntry, Entry3, Entry4) :
                oldEntry == Entry3 ? new Leaf5(Entry0, Entry1, Entry2, newEntry, Entry4) :
                                     new Leaf5(Entry0, Entry1, Entry2, Entry3, newEntry);

            internal override ImMap<V> RemoveEntry(ImMapEntry<V> removedEntry) =>
                removedEntry == Entry0 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry3, new Leaf2(Entry1, Entry2))) : 
                removedEntry == Entry1 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry3, new Leaf2(Entry0, Entry2))) :
                removedEntry == Entry2 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry3, new Leaf2(Entry0, Entry1))) :
                removedEntry == Entry3 ? new Leaf2Plus1Plus1(Entry4, new Leaf2Plus1(Entry2, new Leaf2(Entry0, Entry1))) :
                                         new Leaf2Plus1Plus1(Entry3, new Leaf2Plus1(Entry2, new Leaf2(Entry0, Entry1)));
        }

        /// <summary>Leaf with 5 existing ordered entries plus 1 newly added entry.</summary>
        internal sealed class Leaf5Plus1 : ImMap<V>
        {
            public readonly ImMapEntry<V> Plus;
            public readonly Leaf5 L;

            public Leaf5Plus1(ImMapEntry<V> plus, Leaf5 l)
            {
                Plus = plus;
                L    = l;
            }

            public override int Count() => 6;

#if !DEBUG
            public override string ToString() => "{L51:{P:" + Plus + ",L:" + L + "}}";
#endif

            internal sealed override ImMapEntry<V> GetMinHashEntryOrDefault() => Plus.Hash < L.Entry0.Hash ? Plus : L.Entry0; 
            internal sealed override ImMapEntry<V> GetMaxHashEntryOrDefault() => Plus.Hash > L.Entry4.Hash ? Plus : L.Entry4; 

            internal override ImMapEntry<V> GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash) 
                    return Plus; 
                var l = L;
                return hash == l.Entry0.Hash ? l.Entry0 
                    :  hash == l.Entry1.Hash ? l.Entry1 
                    :  hash == l.Entry2.Hash ? l.Entry2 
                    :  hash == l.Entry3.Hash ? l.Entry3 
                    :  hash == l.Entry4.Hash ? l.Entry4 
                    :  null;
            }

            internal override ImMap<V> AddOrGetEntry(int hash, ImMapEntry<V> entry)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return p;
                var l = L; 
                return hash == l.Entry0.Hash ? l.Entry0
                    :  hash == l.Entry1.Hash ? l.Entry1 
                    :  hash == l.Entry2.Hash ? l.Entry2
                    :  hash == l.Entry3.Hash ? l.Entry3
                    :  hash == l.Entry4.Hash ? l.Entry4
                    :  (ImMap<V>)new Leaf5Plus1Plus1(entry, this);
            }

            internal override ImMap<V> ReplaceEntry(int hash, ImMapEntry<V> oldEntry, ImMapEntry<V> newEntry)
            {
                var p = Plus;
                if (oldEntry == p)
                    return new Leaf5Plus1(newEntry, L);
                var l = L; 
                ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;
                return oldEntry == e0 ? new Leaf5Plus1(p, new Leaf5(newEntry, e1, e2, e3, e4)) 
                    :  oldEntry == e1 ? new Leaf5Plus1(p, new Leaf5(e0, newEntry, e2, e3, e4)) 
                    :  oldEntry == e2 ? new Leaf5Plus1(p, new Leaf5(e0, e1, newEntry, e3, e4)) 
                    :  oldEntry == e3 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, newEntry, e4)) 
                    :                   new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, newEntry));
            }

            internal override ImMap<V> RemoveEntry(ImMapEntry<V> removedEntry)
            {
                var p = Plus;
                if (p == removedEntry)
                    return L;

                var ph = p.Hash;
                var l = L; 
                ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;

                if (ph < e4.Hash)
                {
                    swap = e4; e4 = p; p = swap;
                    if (ph < e3.Hash)
                    {
                        swap = e3; e3 = e4; e4 = swap;
                        if (ph < e2.Hash)
                        {
                            swap = e2; e2 = e3; e3 = swap;
                            if (ph < e1.Hash)
                            {
                                swap = e1; e1 = e2; e2 = swap;
                                if (ph < e0.Hash)
                                {
                                    swap = e0; e0 = e1; e1 = swap;
                                }
                            }
                        }
                    }
                }

                return removedEntry == e0 ? new Leaf5(e1, e2, e3, e4, p)
                    :  removedEntry == e1 ? new Leaf5(e0, e2, e3, e4, p)
                    :  removedEntry == e2 ? new Leaf5(e0, e1, e3, e4, p)
                    :  removedEntry == e3 ? new Leaf5(e0, e1, e2, e4, p)
                    :  removedEntry == e4 ? new Leaf5(e0, e1, e2, e3, p)
                    :                       new Leaf5(e0, e1, e2, e3, e4);
            }
        }

        internal abstract class OnTheVergeOfBalance : ImMap<V>
        {
            internal abstract ImMap<V> AddOrGetEntry(int hash, ref ImMapEntry<V> entry, ref ImMap<V> splitRight);
        }

        /// <summary>Leaf with 5 existing ordered entries plus 1 newly added, plus 1 newly added.</summary>
        internal sealed class Leaf5Plus1Plus1 : OnTheVergeOfBalance
        {
            public readonly ImMapEntry<V> Plus;
            public readonly Leaf5Plus1 L;

            public Leaf5Plus1Plus1(ImMapEntry<V> plus, Leaf5Plus1 l)
            {
                Plus = plus;
                L    = l;
            }

            public sealed override int Count() => 7;

#if !DEBUG
            public override string ToString() => "{L511:{P:" + Plus + ",L:" + L + "}}";
#endif

            internal sealed override ImMapEntry<V> GetMinHashEntryOrDefault()
            {
                var m = L.GetMinHashEntryOrDefault();
                return Plus.Hash < m.Hash ? Plus : m;
            } 
            internal sealed override ImMapEntry<V> GetMaxHashEntryOrDefault()
            {
                var m = L.GetMaxHashEntryOrDefault();
                return Plus.Hash > m.Hash ? Plus : m;
            }

            internal override ImMapEntry<V> GetEntryOrNull(int hash)
            {
                if (hash == Plus.Hash)
                    return Plus;
                if (hash == L.Plus.Hash)
                    return L.Plus;
                var l = L.L;
                return hash == l.Entry0.Hash ? l.Entry0 
                    :  hash == l.Entry1.Hash ? l.Entry1 
                    :  hash == l.Entry2.Hash ? l.Entry2 
                    :  hash == l.Entry3.Hash ? l.Entry3 
                    :  hash == l.Entry4.Hash ? l.Entry4 
                    :  null;
            }

            internal override ImMap<V> AddOrGetEntry(int hash, ImMapEntry<V> entry)
            {
                ImMap<V> splitRight = null;
                var entryOrNewMap = AddOrGetEntry(hash, ref entry, ref splitRight);
                if (splitRight != null)
                    return new Branch2(entryOrNewMap, entry, splitRight);
                return entryOrNewMap;
            }

            internal override ImMap<V> AddOrGetEntry(int hash, ref ImMapEntry<V> entry, ref ImMap<V> splitRight)
            {
                var p = Plus;
                var ph = p.Hash;
                if (ph == hash)
                    return p;

                var pp = L.Plus;
                var pph = pp.Hash;
                if (pph == hash)
                    return pp;

                var l = L.L;
                ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;

                if (hash == e0.Hash)
                    return e0;
                if (hash == e1.Hash)
                    return e1;
                if (hash == e2.Hash)
                    return e2;
                if (hash == e3.Hash)
                    return e3;
                if (hash == e4.Hash)
                    return e4;

                var right = hash > e4.Hash && ph > e4.Hash && pph > e4.Hash;
                var left  = !right && hash < e0.Hash && ph < e0.Hash && pph < e0.Hash;

                ImMapEntry<V> swap = null;
                if (pph < e4.Hash)
                {
                    swap = e4; e4 = pp; pp = swap;
                    if (pph < e3.Hash)
                    {
                        swap = e3; e3 = e4; e4 = swap;
                        if (pph < e2.Hash)
                        {
                            swap = e2; e2 = e3; e3 = swap;
                            if (pph < e1.Hash)
                            {
                                swap = e1; e1 = e2; e2 = swap;
                                if (pph < e0.Hash)
                                {
                                    swap = e0; e0 = e1; e1 = swap;
                                }
                            }
                        }
                    }
                }

                if (ph < pp.Hash)
                {
                    swap = pp; pp = p; p = swap;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }
                }

                ImMapEntry<V> e = entry;
                if (hash < p.Hash)
                {
                    swap = p; p = e; e = swap;
                    if (hash < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (hash < e4.Hash)
                        {
                            swap = e4; e4 = pp; pp = swap;
                            if (hash < e3.Hash)
                            {
                                swap = e3; e3 = e4; e4 = swap;
                                if (hash < e2.Hash)
                                {
                                    swap = e2; e2 = e3; e3 = swap;
                                    if (hash < e1.Hash)
                                    {
                                        swap = e1; e1 = e2; e2 = swap;
                                        if (hash < e0.Hash)
                                        {
                                            swap = e0; e0 = e1; e1 = swap;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (left)
                {
                    entry = e2;
                    splitRight = l;
                    return new Leaf2(e0, e1);
                }

                entry = pp;
                splitRight = new Leaf2(p, e);
                return right ? l : new Leaf5(e0, e1, e2, e3, e4);
            }

            internal override ImMap<V> ReplaceEntry(int hash, ImMapEntry<V> oldEntry, ImMapEntry<V> newEntry)
            {
                var p = Plus;
                if (p == oldEntry)
                    return new Leaf5Plus1Plus1(newEntry, L);

                var pp = L.Plus;
                if (pp == oldEntry)
                    return new Leaf5Plus1Plus1(p, new Leaf5Plus1(newEntry, L.L));

                var l = L.L;
                ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;
                return
                    oldEntry == e0 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(newEntry, e1, e2, e3, e4))) :
                    oldEntry == e1 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, newEntry, e2, e3, e4))) :
                    oldEntry == e2 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, e1, newEntry, e3, e4))) :
                    oldEntry == e3 ? new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, e1, e2, newEntry, e4))) :
                                     new Leaf5Plus1Plus1(p, new Leaf5Plus1(pp, new Leaf5(e0, e1, e2, e3, newEntry)));
            }

            internal override ImMap<V> RemoveEntry(ImMapEntry<V> removedEntry)
            {
                var p = Plus;
                if (p == removedEntry)
                    return L;

                var pp = L.Plus;
                if (pp == removedEntry)
                    return new Leaf5Plus1(p, L.L);

                var l = L.L;
                ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;
                int pph = pp.Hash, ph = p.Hash; 
                if (pph < e4.Hash)
                {
                    swap = e4; e4 = pp; pp = swap;
                    if (pph < e3.Hash)
                    {
                        swap = e3; e3 = e4; e4 = swap;
                        if (pph < e2.Hash)
                        {
                            swap = e2; e2 = e3; e3 = swap;
                            if (pph < e1.Hash)
                            {
                                swap = e1; e1 = e2; e2 = swap;
                                if (pph < e0.Hash)
                                {
                                    swap = e0; e0 = e1; e1 = swap;
                                }
                            }
                        }
                    }
                }
                if (ph < pp.Hash)
                {
                    swap = pp; pp = p; p = swap;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }
                }

                return removedEntry == e0 ? new Leaf5Plus1(p, new Leaf5(e1, e2, e3, e4, pp)) 
                    :  removedEntry == e1 ? new Leaf5Plus1(p, new Leaf5(e0, e2, e3, e4, pp))
                    :  removedEntry == e2 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e3, e4, pp))
                    :  removedEntry == e3 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e4, pp))
                    :  removedEntry == e4 ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, pp))
                    :  removedEntry == pp ? new Leaf5Plus1(p, new Leaf5(e0, e1, e2, e3, e4))
                    :                       new Leaf5Plus1(pp,new Leaf5(e0, e1, e2, e3, e4));
            }
        }

        internal class Branch2 : ImMap<V>
        {
            public readonly ImMapEntry<V> MidEntry;
            public readonly ImMap<V> Left, Right;

            public Branch2(ImMap<V> left, ImMapEntry<V> entry, ImMap<V> right)
            {
                Debug.Assert(left != Empty && right != Empty, $"left:{left} != Empty && right:{right} != Empty");
                MidEntry = entry;
                Left     = left;
                Right    = right;
            }

            public sealed override int Count() => 1 + Left.Count() + Right.Count();

#if !DEBUG
            public override string ToString() => "{B2:{E:" + MidEntry + ",L:" + Left + ",R:" + Right + "}}";
#endif

            internal sealed override ImMapEntry<V> GetMinHashEntryOrDefault() => Left .GetMinHashEntryOrDefault();
            internal sealed override ImMapEntry<V> GetMaxHashEntryOrDefault() => Right.GetMaxHashEntryOrDefault();

            internal override ImMapEntry<V> GetEntryOrNull(int hash) 
            {
                var mh = MidEntry.Hash;
                return hash > mh ? Right.GetEntryOrNull(hash) 
                    :  hash < mh ? Left .GetEntryOrNull(hash) 
                    :  MidEntry;
            }

            internal override ImMap<V> AddOrGetEntry(int hash, ImMapEntry<V> entry)
            {
                var e = MidEntry;
                ImMap<V> newBranch = null;
                if (hash > e.Hash)
                {
                    var right = Right;
                    if (right is OnTheVergeOfBalance r) 
                    {
                        ImMap<V> splitRight = null;
                        newBranch = r.AddOrGetEntry(hash, ref entry, ref splitRight);
                        if (splitRight != null)
                            return new Branch3(Left, e, newBranch, entry, splitRight);
                    }
                    else newBranch = right.AddOrGetEntry(hash, entry);
                    return newBranch is ImMapEntry<V> ? newBranch : new Branch2(Left, e, newBranch);
                }

                if (hash < e.Hash)
                {
                    var left = Left;
                    if (left is OnTheVergeOfBalance l) 
                    {
                        ImMap<V> splitRight = null;
                        newBranch = l.AddOrGetEntry(hash, ref entry, ref splitRight);
                        if (splitRight != null)
                            return new Branch3(newBranch, entry, splitRight, e, Right);
                    }
                    else newBranch = left.AddOrGetEntry(hash, entry);
                    return newBranch is ImMapEntry<V> ? newBranch : new Branch2(newBranch, e, Right);
                }

                return e;
            }

            internal override ImMap<V> ReplaceEntry(int hash, ImMapEntry<V> oldEntry, ImMapEntry<V> newEntry)
            {
                var h = MidEntry.Hash;
                return hash > h ? new Branch2(Left, MidEntry, Right.ReplaceEntry(hash, oldEntry, newEntry))
                    :  hash < h ? new Branch2(Left.ReplaceEntry(hash, oldEntry, newEntry), MidEntry, Right)
                    :  new Branch2(Left, newEntry, Right);
            }

            internal override ImMap<V> RemoveEntry(ImMapEntry<V> removedEntry) 
            {
                // The downward phase for deleting an element from a 2-3 tree is the same as the downward phase
                // for inserting an element except for the case when the element to be deleted is equal to the value in
                // a 2-node or a 3-node. In this case, if the value is not part of a terminal node, the value is replaced
                // by its in-order predecessor or in-order successor, just as in binary search tree deletion. So in any
                // case, deletion leaves a hole in a terminal node.
                // The goal of the rest of the deletion algorithm is to remove the hole without violating the other
                // invariants of the 2-3 tree.

                var mid = MidEntry;
                if (removedEntry.Hash > mid.Hash)
                {
                    var newRight = Right.RemoveEntry(removedEntry);
                    if (newRight == Empty)
                    {
                        // if the left node is not full yet then merge
                        if (Left is Leaf2Plus1Plus1 == false) 
                            return Left.AddOrGetEntry(mid.Hash, mid);
                        return new Branch2(Left.RemoveEntry(removedEntry = Left.GetMaxHashEntryOrDefault()), removedEntry, mid); //! the height does not change
                    }

                    //*rebalance needed: the branch was merged from Br2 to Br3 or to the leaf and the height decreased 
                    if (Right is Branch2 && newRight is Branch2 == false)
                    {
                        // the the hole has a 2-node as a parent and a 3-node as a sibling.
                        if (Left is Branch3 lb3) //! the height does not change
                            return new Branch2(new Branch2(lb3.Left, lb3.Entry0, lb3.Middle), lb3.Entry1, new Branch2(lb3.Right, mid, newRight));

                        // the the hole has a 2-node as a parent and a 2-node as a sibling.
                        var lb2 = (Branch2)Left; 
                        return new Branch3(lb2.Left, lb2.MidEntry, lb2.Right, mid, newRight);
                    }

                    return new Branch2(Left, mid, newRight);
                }

                // case 1, downward: swap the predecessor entry (max left entry) with the mid entry, then proceed to remove the predecessor from the Left branch
                if (removedEntry == mid)
                    removedEntry = mid = Left.GetMaxHashEntryOrDefault();

                // case 1, upward
                var newLeft = Left.RemoveEntry(removedEntry);
                if (newLeft == Empty)
                {
                    if (Right is Leaf2Plus1Plus1 == false) 
                        return Right.AddOrGetEntry(mid.Hash, mid);
                    return new Branch2(mid, removedEntry = Right.GetMinHashEntryOrDefault(), Right.RemoveEntry(removedEntry)); //! the height does not change
                }

                //*rebalance needed: the branch was merged from Br2 to Br3 or to the leaf and the height decreased 
                if (Left is Branch2 && newLeft is Branch2 == false)
                {
                    // the the hole has a 2-node as a parent and a 3-node as a sibling.
                    if (Right is Branch3 rb3) //! the height does not change
                        return new Branch2(new Branch2(newLeft, mid, rb3.Left), rb3.Entry0, new Branch2(rb3.Middle, rb3.Entry0, rb3.Right));

                    // the the hole has a 2-node as a parent and a 2-node as a sibling.
                    var rb2 = (Branch2)Right;
                    return new Branch3(newLeft, mid, rb2.Left, rb2.MidEntry, rb2.Right);
                }

                return new Branch2(newLeft, mid, Right);
            }
        }

        /// <summary>Branch of 3 with 2 nodes in between</summary>
        internal sealed class Branch3 : OnTheVergeOfBalance
        {
            public readonly ImMapEntry<V> Entry0, Entry1;
            public readonly ImMap<V> Left, Middle, Right;

            public Branch3(ImMap<V> left, ImMapEntry<V> e0, ImMap<V> middle, ImMapEntry<V> e1, ImMap<V> right) 
            {
                Debug.Assert(e0.Hash < e1.Hash, $"e0.Hash:{e0.Hash} < e1.Hash{e1.Hash}");
                Left   = left;
                Entry0 = e0;
                Middle = middle;
                Entry1 = e1;
                Right  = right;
            }

            public override int Count() => 2 + Left.Count() + Middle.Count() + Right.Count();

#if !DEBUG
            public override string ToString() => "{B3:{E0:" + Entry0 + ",E1:" + Entry0 + ",L:" + Left + ",M:" + Middle + ",R:" + Right + "}}";
#endif

            internal override ImMapEntry<V> GetMinHashEntryOrDefault() => Left .GetMinHashEntryOrDefault();
            internal override ImMapEntry<V> GetMaxHashEntryOrDefault() => Right.GetMaxHashEntryOrDefault();

            internal override ImMapEntry<V> GetEntryOrNull(int hash) 
            {
                var h1 = Entry1.Hash;
                if (hash > h1)
                    return Right.GetEntryOrNull(hash);
                var h0 = Entry0.Hash;
                if (hash < h0)
                    return Left.GetEntryOrNull(hash);
                if (h0 == hash)
                    return Entry0;
                if (h1 == hash)
                    return Entry1;
                return Middle.GetEntryOrNull(hash);
            }

            internal override ImMap<V> AddOrGetEntry(int hash, ImMapEntry<V> entry)
            {
                var h1 = Entry1.Hash;
                if (hash > h1)
                {
                    var right = Right;
                    var newRight = right.AddOrGetEntry(hash, entry);
                    if (newRight is ImMapEntry<V>)
                        return newRight;
                    if (right is OnTheVergeOfBalance && newRight is Branch2)
                        return new Branch2(new Branch2(Left, Entry0, Middle), Entry1, newRight);
                    return new Branch3(Left, Entry0, Middle, Entry1, newRight);
                }

                var h0 = Entry0.Hash;
                if (hash < h0)
                {
                    var left = Left;
                    var newLeft = left.AddOrGetEntry(hash, entry);
                    if (newLeft is ImMapEntry<V>)
                        return newLeft;
                    if (left is OnTheVergeOfBalance && newLeft is Branch2)
                        return new Branch2(newLeft, Entry0, new Branch2(Middle, Entry1, Right));
                    return new Branch3(newLeft, Entry0, Middle, Entry1, Right);
                }

                if (hash > h0 && hash < h1)
                {
                    var middle = Middle;
                    ImMap<V> newBranch = null;
                    if (middle is OnTheVergeOfBalance m)
                    {
                        ImMap<V> splitMiddleRight = null;
                        newBranch = m.AddOrGetEntry(hash, ref entry, ref splitMiddleRight);
                        if (splitMiddleRight != null)
                            return new Branch2(new Branch2(Left, Entry0, newBranch), entry, new Branch2(splitMiddleRight, Entry1, Right));
                    }
                    else newBranch = middle.AddOrGetEntry(hash, entry);
                    return newBranch is ImMapEntry<V> ? newBranch : new Branch3(Left, Entry0, newBranch, Entry1, Right);
                }

                return hash == h0 ? Entry0 : Entry1;
            }

            internal override ImMap<V> AddOrGetEntry(int hash, ref ImMapEntry<V> entry, ref ImMap<V> splitRight)
            {
                var h1 = Entry1.Hash;
                if (hash > h1)
                {
                    var right = Right;
                    var newRight = right.AddOrGetEntry(hash, entry);
                    if (newRight is ImMapEntry<V>)
                        return newRight;
                    if (right is OnTheVergeOfBalance && newRight is Branch2)
                    {
                        entry = Entry1;
                        splitRight = newRight;
                        return new Branch2(Left, Entry0, Middle);
                    }
                    return new Branch3(Left, Entry0, Middle, Entry1, newRight);
                }

                var h0 = Entry0.Hash;
                if (hash < h0)
                {
                    var left = Left;
                    var newLeft = left.AddOrGetEntry(hash, entry);
                    if (newLeft is ImMapEntry<V>)
                        return newLeft;
                    if (left is OnTheVergeOfBalance && newLeft is Branch2)
                    {
                        entry = Entry0;
                        splitRight = new Branch2(Middle, Entry1, Right);
                        return newLeft;
                    }

                    return new Branch3(newLeft, Entry0, Middle, Entry1, Right);
                }

                if (hash > h0 && hash < h1)
                {
                    var middle = Middle;
                    ImMap<V> newBranch = null;
                    if (middle is OnTheVergeOfBalance m)
                    {
                        ImMap<V> splitMiddleRight = null;
                        newBranch = m.AddOrGetEntry(hash, ref entry, ref splitMiddleRight);
                        if (splitMiddleRight != null)
                        {
                            // entry = entry; we don't need to assign the entry because it is already containing the proper value
                            splitRight = new Branch2(splitMiddleRight, Entry1, Right);
                            return new Branch2(Left, Entry0, newBranch);
                        }
                    }
                    else
                        newBranch = middle.AddOrGetEntry(hash, entry);
                    if (newBranch is ImMapEntry<V>)
                        return newBranch;
                    return new Branch3(Left, Entry0, newBranch, Entry1, Right);
                }

                return hash == h0 ? Entry0 : Entry1;
            }

            internal override ImMap<V> ReplaceEntry(int hash, ImMapEntry<V> oldEntry, ImMapEntry<V> newEntry)
            {
                int h0 = Entry0.Hash, h1 = Entry1.Hash;
                return hash > h1 ? new Branch3(Left, Entry0, Middle, Entry1, Right.ReplaceEntry(hash, oldEntry, newEntry)) 
                    :  hash < h0 ? new Branch3(Left.ReplaceEntry(hash, oldEntry, newEntry), Entry0, Middle, Entry1, Right)
                    :  hash > h0 && hash < h1 ? new Branch3(Left, Entry0, Middle.ReplaceEntry(hash, oldEntry, newEntry), Entry1, Right)
                    :  oldEntry == Entry0 ? new Branch3(Left, newEntry, Middle, Entry1, Right) : new Branch3(Left, Entry0, Middle, newEntry, Right);
            }

            internal override ImMap<V> RemoveEntry(ImMapEntry<V> removedEntry)
            {
                var midLeft  = Entry0;
                var middle   = Middle;
                var midRight = Entry1;
                var right    = Right;

                // case 1, downward: swap the predecessor entry (max left entry) with the mid entry, then proceed to remove the predecessor from the Left branch
                if (removedEntry == midLeft)
                    removedEntry = midLeft = Left.GetMaxHashEntryOrDefault();

                if (removedEntry.Hash <= midLeft.Hash)
                {
                    var newLeft = Left.RemoveEntry(removedEntry);
                    if (newLeft == Empty)
                    {
                        if (middle is Leaf2Plus1Plus1 == false) 
                            return new Branch2(middle.AddOrGetEntry(midLeft.Hash, midLeft), midRight, right); //! the height does not change
                        return new Branch3(midLeft, removedEntry = middle.GetMinHashEntryOrDefault(), middle.RemoveEntry(removedEntry), midRight, right); //! the height does not change
                    }

                    // rebalance is needed because the branch was merged from Br2 to Br3 or to Leaf and the height decrease
                    if (Left is Branch2 && newLeft is Branch2 == false)
                    {
                        // the hole has a 3-node as a parent and a 3-node as a sibling.
                        if (middle is Branch3 mb3) //! the height does not change
                            return new Branch3(new Branch2(newLeft, midLeft, mb3.Left), mb3.Entry0, new Branch2(mb3.Middle, mb3.Entry1, mb3.Right), midRight, right);

                        // the hole has a 3-node as a parent and a 2-node as a sibling.
                        var mb2 = (Branch2)middle;
                        return new Branch2(new Branch3(newLeft, midLeft, mb2.Left, mb2.MidEntry, mb2.Right), midRight, right);
                    }

                    return new Branch3(newLeft, midLeft, middle, midRight, right); // no rebalance needed
                }

                if (removedEntry == midRight)
                    removedEntry = midRight = middle.GetMaxHashEntryOrDefault();

                if (removedEntry.Hash <= midRight.Hash)
                {
                    var newMiddle = middle.RemoveEntry(removedEntry);
                    if (newMiddle == Empty)
                    {
                        if (right is Leaf2Plus1Plus1 == false)
                            return new Branch2(Left, midLeft, right.AddOrGetEntry(midLeft.Hash, midLeft)); // the Br3 become the Br2 but the height did not change - so no rebalance needed
                        return new Branch3(Left, midLeft, midRight, removedEntry = right.GetMinHashEntryOrDefault(), right.RemoveEntry(removedEntry)); //! the height does not change
                    }

                    if (middle is Branch2 && newMiddle is Branch2 == false)
                    {
                        // the hole has a 3-node as a parent and a 3-node as a sibling.
                        if (right is Branch3 rb3) //! the height does not change
                            return new Branch3(Left, midLeft, new Branch2(newMiddle, midRight, rb3.Left), rb3.Entry0, new Branch2(rb3.Middle, rb3.Entry1, rb3.Right));

                        // the hole has a 3-node as a parent and a 2-node as a sibling.
                        var rb2 = (Branch2)right;
                        return new Branch2(Left, midLeft, new Branch3(newMiddle, midRight, rb2.Left, rb2.MidEntry, rb2.Right));
                    }

                    return new Branch3(Left, midLeft, newMiddle, midRight, right);
                }

                var newRight = right.RemoveEntry(removedEntry);
                if (newRight == Empty)
                {
                    if (middle is Leaf2Plus1Plus1 == false)
                        return new Branch2(Left, midLeft, middle.AddOrGetEntry(midRight.Hash, midRight));
                    return new Branch3(Left, midLeft, middle.RemoveEntry(removedEntry = middle.GetMaxHashEntryOrDefault()), removedEntry, midRight);
                }

                // right was a Br2 but now is Leaf or Br3 - means the branch height is decrease
                if (right.GetType() == typeof(Branch2) && newRight.GetType() != typeof(Branch2))
                {
                    // the hole has a 3-node as a parent and a 3-node as a sibling.new
                    if (middle is Branch3 mb3) //! the height does not change
                        return new Branch3(Left, midLeft, new Branch2(mb3.Left, mb3.Entry0, mb3.Middle), mb3.Entry1, new Branch2(mb3.Right, midRight, newRight));

                    // the hole has a 3-node as a parent and a 2-node as a sibling.
                    var mb2 = (Branch2)middle;
                    return new Branch2(Left, midLeft, new Branch3(mb2.Left, mb2.MidEntry, mb2.Right, midRight, newRight));
                }

                return new Branch3(Left, midLeft, middle, midRight, newRight);
            }
        }
    }

    /// <summary>Helper stack wrapper for the array</summary>
    public sealed class MapParentStack
    {
        private const int DefaultInitialCapacity = 4;
        private object[] _items;

        /// <summary>Creates the list of the `DefaultInitialCapacity`</summary>
        public MapParentStack() => _items = new object[DefaultInitialCapacity];

        /// <summary>Pushes the item</summary>
        public void Push(object item, int count)
        {
            if (count >= _items.Length)
                _items = Expand(_items);
            _items[count] = item;
        }

        /// <summary>Gets the item by index</summary>
        public object Get(int index) => _items[index];

        /// <summary>Gets the item by index</summary>
        public object Set(int index, object x) => _items[index] = x;

        private static object[] Expand(object[] items)
        {
            var count = items.Length;
            var newItems = new object[count << 1]; // count * 2
            Array.Copy(items, 0, newItems, 0, count);
            return newItems;
        }
    }

    /// <summary>The map methods</summary>
    public static class ImHashMap
    {
        /// <summary>Creates the entry to help with inference</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> Entry<K, V>(K key, V value) => new ImHashMapEntry<K, V>(key.GetHashCode(), key, value);

        /// <summary>Creates the entry to help with inference</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> Entry<K, V>(int hash, K key, V value) => new ImHashMapEntry<K, V>(hash, key, value);

        /// <summary>Creates the conflicting entry out of two entries</summary>
        [MethodImpl((MethodImplOptions)256)]
        internal static ImHashMap<K, V>.Entry WithConflicting<K, V>(this ImHashMapEntry<K, V> one, ImHashMapEntry<K, V> two) => 
            new HashConflictingEntry<K, V>(one.Hash, one, two);

        /// <summary>Sets the value and returns the entry</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> SetValue<K, V>(this ImHashMapEntry<K, V> e, V value) 
        {
            e.Value = value;
            return e;
        }

        private sealed class GoRightInBranch3<K, V> 
        {
            public ImHashMap<K, V>.Branch3 Br3;
        }

        /// <summary>Enumerates all the map entries in the hash order.
        /// The `parents` parameter allow sto reuse the stack memory used for traversal between multiple enumerates.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent `Enumerate` calls</summary>
        public static IEnumerable<ImHashMapEntry<K, V>> Enumerate<K, V>(this ImHashMap<K, V> map, MapParentStack parents = null)
        {
            if (map == ImHashMap<K, V>.Empty)
                yield break;
            if (map is ImHashMap<K, V>.Entry e)
            {
                if (e is ImHashMapEntry<K, V> v) yield return v;
                else foreach (var c in ((HashConflictingEntry<K, V>)e).Conflicts) yield return c;
                yield break;
            }

            var count = 0;
            GoRightInBranch3<K, V> br3Wrapper = null;
            while (true)
            {
                if (map is ImHashMap<K, V>.Branch2 b2)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Push(map, count++);
                    map = b2.Left;
                    continue;
                }
                if (map is ImHashMap<K, V>.Branch3 b3)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Push(map, count++);
                    map = b3.Left;
                    continue;
                }

                if (map is ImHashMap<K, V>.Entry l1)
                {
                    if (l1 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l1).Conflicts) yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf2 l2)
                {
                    if (l2.Entry0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l2.Entry0).Conflicts) yield return c;
                    if (l2.Entry1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l2.Entry1).Conflicts) yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf2Plus1 l21)
                {
                    var p  = l21.Plus;
                    var ph = p.Hash;
                    var l  = l21.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = p; p = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) yield return c;
                    if (e1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) yield return c;
                    if (p  is ImHashMapEntry<K, V> v2) yield return v2;
                    else foreach (var c in ((HashConflictingEntry<K, V>)p ).Conflicts) yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf2Plus1Plus1 l211)
                {
                    var p  = l211.Plus;
                    var pp = l211.L.Plus;
                    var ph = pp.Hash;
                    var l  = l211.L.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = pp; pp = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    ph = p.Hash;
                    if (ph < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (ph < e1.Hash)
                        {
                            swap = e1; e1 = pp; pp = swap;
                            if (ph < e0.Hash)
                            {
                                swap = e0; e0 = e1; e1 = swap;
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) yield return c;
                    if (e1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) yield return c;
                    if (pp is ImHashMapEntry<K, V> v2) yield return v2;
                    else foreach (var c in ((HashConflictingEntry<K, V>)pp).Conflicts) yield return c;
                    if (p  is ImHashMapEntry<K, V> v3) yield return v3;
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts)  yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf5 l5)
                {
                    if (l5.Entry0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry0).Conflicts) yield return c;
                    if (l5.Entry1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry1).Conflicts) yield return c;
                    if (l5.Entry2 is ImHashMapEntry<K, V> v2) yield return v2;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry2).Conflicts) yield return c;
                    if (l5.Entry3 is ImHashMapEntry<K, V> v3) yield return v3;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry3).Conflicts) yield return c;
                    if (l5.Entry4 is ImHashMapEntry<K, V> v4) yield return v4;
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry4).Conflicts) yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf5Plus1 l51)
                {
                    var p  = l51.Plus;
                    var ph = p.Hash;
                    var l  = l51.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = p; p = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) yield return c;
                    if (e1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) yield return c;
                    if (e2 is ImHashMapEntry<K, V> v2) yield return v2;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e2).Conflicts) yield return c;
                    if (e3 is ImHashMapEntry<K, V> v3) yield return v3;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e3).Conflicts) yield return c;
                    if (e4 is ImHashMapEntry<K, V> v4) yield return v4;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e4).Conflicts) yield return c;
                    if (p  is ImHashMapEntry<K, V> v5) yield return v5;
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts)  yield return c;
                }
                else if (map is ImHashMap<K, V>.Leaf5Plus1Plus1 l511)
                {
                    var l = l511.L.L;
                    ImHashMap<K, V>.Entry 
                        e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus, swap = null;
                    var h = pp.Hash;
                    if (h < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (h < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (h < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (h < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (h < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    h = p.Hash;
                    if (h < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (h < e4.Hash)
                        {
                            swap = e4; e4 = pp; pp = swap;
                            if (h < e3.Hash)
                            {
                                swap = e3; e3 = e4; e4 = swap;
                                if (h < e2.Hash)
                                {
                                    swap = e2; e2 = e3; e3 = swap;
                                    if (h < e1.Hash)
                                    {
                                        swap = e1; e1 = e2; e2 = swap;
                                        if (h < e0.Hash)
                                        {
                                            swap = e0; e0 = e1; e1 = swap;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) yield return v0;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) yield return c;
                    if (e1 is ImHashMapEntry<K, V> v1) yield return v1;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) yield return c;
                    if (e2 is ImHashMapEntry<K, V> v2) yield return v2;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e2).Conflicts) yield return c;
                    if (e3 is ImHashMapEntry<K, V> v3) yield return v3;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e3).Conflicts) yield return c;
                    if (e4 is ImHashMapEntry<K, V> v4) yield return v4;
                    else foreach (var c in ((HashConflictingEntry<K, V>)e4).Conflicts) yield return c;
                    if (pp is ImHashMapEntry<K, V> v5) yield return v5;
                    else foreach (var c in ((HashConflictingEntry<K, V>)pp).Conflicts) yield return c;
                    if (p  is ImHashMapEntry<K, V> v6) yield return v6;
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts)  yield return c;
                }

                if (count == 0)
                    break; // we yield the leaf and there is nothing in stack - we are DONE!

                var b = parents.Get(--count); // otherwise get the parent
                if (b is ImHashMap<K,V>.Branch2 pb2)
                {
                    if (pb2.MidEntry is ImHashMapEntry<K, V> v) yield return v;
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb2.MidEntry).Conflicts) yield return c;
                    map = pb2.Right;
                }
                else if (b is ImHashMap<K, V>.Branch3 pb3)
                {
                    if (pb3.Entry0 is ImHashMapEntry<K, V> v) yield return v;
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb3.Entry0).Conflicts) yield return c;
                    if (br3Wrapper == null)
                        br3Wrapper = new GoRightInBranch3<K, V>();
                    br3Wrapper.Br3 = pb3;
                    parents.Set(count++, br3Wrapper);
                    br3Wrapper = null; // set to null to mark that the wrapper is in use and longer shared
                    map = pb3.Middle;
                }
                else 
                {
                    br3Wrapper = (GoRightInBranch3<K, V>)b;
                    if (br3Wrapper.Br3.Entry1 is ImHashMapEntry<K, V> v) yield return v;
                    else foreach (var c in ((HashConflictingEntry<K, V>)br3Wrapper.Br3.Entry1).Conflicts) yield return c;
                    map = br3Wrapper.Br3.Right;
                }
            }
        }

        /// <summary>
        /// Depth-first in-order of hash traversal as described in http://en.wikipedia.org/wiki/Tree_traversal.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static S ForEach<K, V, S>(this ImHashMap<K, V> map, S state, Action<ImHashMapEntry<K, V>, int, S> handler, MapParentStack parents = null)
        {
            if (map == ImHashMap<K, V>.Empty)
                return state;
            var i = 0;
            if (map is ImHashMap<K, V>.Entry e)
            {
                if (e is ImHashMapEntry<K, V> kv) handler(kv, 0, state);
                else foreach (var c in ((HashConflictingEntry<K, V>)e).Conflicts) handler(c, i++, state);
                return state;
            }

            var count = 0;
            GoRightInBranch3<K, V> br3Wrapper = null;
            while (true)
            {
                if (map is ImHashMap<K, V>.Branch2 b2)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Push(map, count++);
                    map = b2.Left;
                    continue;
                }
                if (map is ImHashMap<K, V>.Branch3 b3)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Push(map, count++);
                    map = b3.Left;
                    continue;
                }

                if (map is ImHashMap<K, V>.Entry l1)
                {
                    if (l1 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l1).Conflicts) handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf2 l2)
                {
                    if (l2.Entry0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l2.Entry0).Conflicts) handler(c, i++, state);
                    if (l2.Entry1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l2.Entry1).Conflicts) handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf2Plus1 l21)
                {
                    var p  = l21.Plus;
                    var ph = p.Hash;
                    var l  = l21.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = p; p = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler(c, i++, state);
                    if (p  is ImHashMapEntry<K, V> v2) handler(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p ).Conflicts) handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf2Plus1Plus1 l211)
                {
                    var p  = l211.Plus;
                    var pp = l211.L.Plus;
                    var ph = pp.Hash;
                    var l  = l211.L.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = pp; pp = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    ph = p.Hash;
                    if (ph < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (ph < e1.Hash)
                        {
                            swap = e1; e1 = pp; pp = swap;
                            if (ph < e0.Hash)
                            {
                                swap = e0; e0 = e1; e1 = swap;
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler(c, i++, state);
                    if (pp is ImHashMapEntry<K, V> v2) handler(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pp).Conflicts) handler(c, i++, state);
                    if (p  is ImHashMapEntry<K, V> v3) handler(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts)  handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf5 l5)
                {
                    if (l5.Entry0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry0).Conflicts) handler(c, i++, state);
                    if (l5.Entry1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry1).Conflicts) handler(c, i++, state);
                    if (l5.Entry2 is ImHashMapEntry<K, V> v2) handler(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry2).Conflicts) handler(c, i++, state);
                    if (l5.Entry3 is ImHashMapEntry<K, V> v3) handler(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry3).Conflicts) handler(c, i++, state);
                    if (l5.Entry4 is ImHashMapEntry<K, V> v4) handler(v4, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry4).Conflicts) handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf5Plus1 l51)
                {
                    var p  = l51.Plus;
                    var ph = p.Hash;
                    var l  = l51.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = p; p = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler(c, i++, state);
                    if (e2 is ImHashMapEntry<K, V> v2) handler(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e2).Conflicts) handler(c, i++, state);
                    if (e3 is ImHashMapEntry<K, V> v3) handler(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e3).Conflicts) handler(c, i++, state);
                    if (e4 is ImHashMapEntry<K, V> v4) handler(v4, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e4).Conflicts) handler(c, i++, state);
                    if (p  is ImHashMapEntry<K, V> v5) handler(v5, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts)  handler(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf5Plus1Plus1 l511)
                {
                    var l = l511.L.L;
                    ImHashMap<K, V>.Entry 
                        e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus, swap = null;
                    var h = pp.Hash;
                    if (h < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (h < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (h < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (h < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (h < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    h = p.Hash;
                    if (h < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (h < e4.Hash)
                        {
                            swap = e4; e4 = pp; pp = swap;
                            if (h < e3.Hash)
                            {
                                swap = e3; e3 = e4; e4 = swap;
                                if (h < e2.Hash)
                                {
                                    swap = e2; e2 = e3; e3 = swap;
                                    if (h < e1.Hash)
                                    {
                                        swap = e1; e1 = e2; e2 = swap;
                                        if (h < e0.Hash)
                                        {
                                            swap = e0; e0 = e1; e1 = swap;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler(c, i++, state);
                    if (e2 is ImHashMapEntry<K, V> v2) handler(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e2).Conflicts) handler(c, i++, state);
                    if (e3 is ImHashMapEntry<K, V> v3) handler(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e3).Conflicts) handler(c, i++, state);
                    if (e4 is ImHashMapEntry<K, V> v4) handler(v4, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e4).Conflicts) handler(c, i++, state);
                    if (pp is ImHashMapEntry<K, V> v5) handler(v5, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pp).Conflicts) handler(c, i++, state);
                    if (p  is ImHashMapEntry<K, V> v6) handler(v6, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts)  handler(c, i++, state);
                }

                if (count == 0)
                    break; // we yield the leaf and there is nothing in stack - we are DONE!

                var b = parents.Get(--count); // otherwise get the parent
                if (b is ImHashMap<K,V>.Branch2 pb2)
                {
                    if (pb2.MidEntry is ImHashMapEntry<K, V> v) handler(v, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb2.MidEntry).Conflicts) handler(c, i++, state);
                    map = pb2.Right;
                }
                else if (b is ImHashMap<K, V>.Branch3 pb3)
                {
                    if (pb3.Entry0 is ImHashMapEntry<K, V> v) handler(v, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb3.Entry0).Conflicts) handler(c, i++, state);
                    if (br3Wrapper == null)
                        br3Wrapper = new GoRightInBranch3<K, V>();
                    br3Wrapper.Br3 = pb3;
                    parents.Set(count++, br3Wrapper);
                    br3Wrapper = null; // set to null to mark that the wrapper is in use and longer shared
                    map = pb3.Middle;
                }
                else 
                {
                    br3Wrapper = (GoRightInBranch3<K, V>)b;
                    if (br3Wrapper.Br3.Entry1 is ImHashMapEntry<K, V> v) handler(v, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)br3Wrapper.Br3.Entry1).Conflicts) handler(c, i++, state);
                    map = br3Wrapper.Br3.Right;
                }
            }

            return state;
        }

        /// <summary>Struct handler to allow inlining of the Invoke implementation. Important: will be inlined only with the non-generic implementation</summary>
        public interface IHandler<K, V, S>
        {
            /// <summary>Handler code</summary>
            void Invoke(ImHashMapEntry<K, V> entry, int i, S state);
        }

        /// <summary>
        /// Depth-first in-order of hash traversal as described in http://en.wikipedia.org/wiki/Tree_traversal.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static S ForEach<K, V, S, THandler>(this ImHashMap<K, V> map, S state, THandler handler, MapParentStack parents = null)
            where THandler : struct, IHandler<K, V, S>
        {
            if (map == ImHashMap<K, V>.Empty)
                return state;
            var i = 0;
            if (map is ImHashMap<K, V>.Entry e)
            {
                if (e is ImHashMapEntry<K, V> kv) handler.Invoke(kv, 0, state);
                else foreach (var c in ((HashConflictingEntry<K, V>)e).Conflicts) handler.Invoke(c, i++, state);
                return state;
            }

            var count = 0;
            GoRightInBranch3<K, V> br3Wrapper = null;
            while (true)
            {
                if (map is ImHashMap<K, V>.Branch2 b2)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Push(map, count++);
                    map = b2.Left;
                    continue;
                }
                if (map is ImHashMap<K, V>.Branch3 b3)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Push(map, count++);
                    map = b3.Left;
                    continue;
                }

                if (map is ImHashMap<K, V>.Entry l1)
                {
                    if (l1 is ImHashMapEntry<K, V> v0) handler.Invoke(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l1).Conflicts) handler.Invoke(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf2 l2)
                {
                    if (l2.Entry0 is ImHashMapEntry<K, V> v0) handler.Invoke(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l2.Entry0).Conflicts) handler.Invoke(c, i++, state);
                    if (l2.Entry1 is ImHashMapEntry<K, V> v1) handler.Invoke(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l2.Entry1).Conflicts) handler.Invoke(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf2Plus1 l21)
                {
                    var p  = l21.Plus;
                    var ph = p.Hash;
                    var l  = l21.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = p; p = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler.Invoke(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler.Invoke(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler.Invoke(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler.Invoke(c, i++, state);
                    if (p  is ImHashMapEntry<K, V> v2) handler.Invoke(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p ).Conflicts) handler.Invoke(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf2Plus1Plus1 l211)
                {
                    var p  = l211.Plus;
                    var pp = l211.L.Plus;
                    var ph = pp.Hash;
                    var l  = l211.L.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = pp; pp = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    ph = p.Hash;
                    if (ph < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (ph < e1.Hash)
                        {
                            swap = e1; e1 = pp; pp = swap;
                            if (ph < e0.Hash)
                            {
                                swap = e0; e0 = e1; e1 = swap;
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler.Invoke(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler.Invoke(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler.Invoke(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler.Invoke(c, i++, state);
                    if (pp is ImHashMapEntry<K, V> v2) handler.Invoke(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pp).Conflicts) handler.Invoke(c, i++, state);
                    if (p  is ImHashMapEntry<K, V> v3) handler.Invoke(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts)  handler.Invoke(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf5 l5)
                {
                    if (l5.Entry0 is ImHashMapEntry<K, V> v0) handler.Invoke(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry0).Conflicts) handler.Invoke(c, i++, state);
                    if (l5.Entry1 is ImHashMapEntry<K, V> v1) handler.Invoke(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry1).Conflicts) handler.Invoke(c, i++, state);
                    if (l5.Entry2 is ImHashMapEntry<K, V> v2) handler.Invoke(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry2).Conflicts) handler.Invoke(c, i++, state);
                    if (l5.Entry3 is ImHashMapEntry<K, V> v3) handler.Invoke(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry3).Conflicts) handler.Invoke(c, i++, state);
                    if (l5.Entry4 is ImHashMapEntry<K, V> v4) handler.Invoke(v4, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)l5.Entry4).Conflicts) handler.Invoke(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf5Plus1 l51)
                {
                    var p  = l51.Plus;
                    var ph = p.Hash;
                    var l  = l51.L;
                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = p; p = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler.Invoke(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler.Invoke(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler.Invoke(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler.Invoke(c, i++, state);
                    if (e2 is ImHashMapEntry<K, V> v2) handler.Invoke(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e2).Conflicts) handler.Invoke(c, i++, state);
                    if (e3 is ImHashMapEntry<K, V> v3) handler.Invoke(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e3).Conflicts) handler.Invoke(c, i++, state);
                    if (e4 is ImHashMapEntry<K, V> v4) handler.Invoke(v4, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e4).Conflicts) handler.Invoke(c, i++, state);
                    if (p  is ImHashMapEntry<K, V> v5) handler.Invoke(v5, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts)  handler.Invoke(c, i++, state);
                }
                else if (map is ImHashMap<K, V>.Leaf5Plus1Plus1 l511)
                {
                    var l = l511.L.L;
                    ImHashMap<K, V>.Entry 
                        e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus, swap = null;
                    var h = pp.Hash;
                    if (h < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (h < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (h < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (h < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (h < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    h = p.Hash;
                    if (h < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (h < e4.Hash)
                        {
                            swap = e4; e4 = pp; pp = swap;
                            if (h < e3.Hash)
                            {
                                swap = e3; e3 = e4; e4 = swap;
                                if (h < e2.Hash)
                                {
                                    swap = e2; e2 = e3; e3 = swap;
                                    if (h < e1.Hash)
                                    {
                                        swap = e1; e1 = e2; e2 = swap;
                                        if (h < e0.Hash)
                                        {
                                            swap = e0; e0 = e1; e1 = swap;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (e0 is ImHashMapEntry<K, V> v0) handler.Invoke(v0, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e0).Conflicts) handler.Invoke(c, i++, state);
                    if (e1 is ImHashMapEntry<K, V> v1) handler.Invoke(v1, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e1).Conflicts) handler.Invoke(c, i++, state);
                    if (e2 is ImHashMapEntry<K, V> v2) handler.Invoke(v2, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e2).Conflicts) handler.Invoke(c, i++, state);
                    if (e3 is ImHashMapEntry<K, V> v3) handler.Invoke(v3, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e3).Conflicts) handler.Invoke(c, i++, state);
                    if (e4 is ImHashMapEntry<K, V> v4) handler.Invoke(v4, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)e4).Conflicts) handler.Invoke(c, i++, state);
                    if (pp is ImHashMapEntry<K, V> v5) handler.Invoke(v5, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pp).Conflicts) handler.Invoke(c, i++, state);
                    if (p  is ImHashMapEntry<K, V> v6) handler.Invoke(v6, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)p).Conflicts)  handler.Invoke(c, i++, state);
                }

                if (count == 0)
                    break; // we yield the leaf and there is nothing in stack - we are DONE!

                var b = parents.Get(--count); // otherwise get the parent
                if (b is ImHashMap<K,V>.Branch2 pb2)
                {
                    if (pb2.MidEntry is ImHashMapEntry<K, V> v) handler.Invoke(v, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb2.MidEntry).Conflicts) handler.Invoke(c, i++, state);
                    map = pb2.Right;
                }
                else if (b is ImHashMap<K, V>.Branch3 pb3)
                {
                    if (pb3.Entry0 is ImHashMapEntry<K, V> v) handler.Invoke(v, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)pb3.Entry0).Conflicts) handler.Invoke(c, i++, state);
                    if (br3Wrapper == null)
                        br3Wrapper = new GoRightInBranch3<K, V>();
                    br3Wrapper.Br3 = pb3;
                    parents.Set(count++, br3Wrapper);
                    br3Wrapper = null; // set to null to mark that the wrapper is in use and longer shared
                    map = pb3.Middle;
                }
                else 
                {
                    br3Wrapper = (GoRightInBranch3<K, V>)b;
                    if (br3Wrapper.Br3.Entry1 is ImHashMapEntry<K, V> v) handler.Invoke(v, i++, state);
                    else foreach (var c in ((HashConflictingEntry<K, V>)br3Wrapper.Br3.Entry1).Conflicts) handler.Invoke(c, i++, state);
                    map = br3Wrapper.Br3.Right;
                }
            }

            return state;
        }

        /// <summary>Do something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static void ForEach<K, V>(this ImHashMap<K, V> map, Action<ImHashMapEntry<K, V>, int> handler, MapParentStack parents = null) =>
            map.ForEach(handler, (e, i, r) => r(e, i), parents);

        /// <summary>Collect something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static S Fold<K, V, S>(this ImHashMap<K, V> map, S state, Func<ImHashMapEntry<K, V>, int, S, S> handler, MapParentStack parents = null) =>
            map.ForEach(St.Rent(state, handler), (e, i, s) => s.a = s.b(e, i, s.a), parents).ResetButGetA();

        /// <summary>Converts map to an array with the minimum allocations</summary>
        public static S[] ToArray<K, V, S>(this ImHashMap<K, V> map, Func<ImHashMapEntry<K, V>, S> selector) =>
            map == ImHashMap<K, V>.Empty ? ArrayTools.Empty<S>() : 
                map.ForEach(St.Rent(new S[map.Count()], selector), (e, i, s) => s.a[i] = s.b(e)).ResetButGetA();

        /// <summary>Converts map to an array with the minimum allocations</summary>
        public static ImHashMapEntry<K, V>[] ToArray<K, V>(this ImHashMap<K, V> map) =>
            map == ImHashMap<K, V>.Empty ? ArrayTools.Empty<ImHashMapEntry<K, V>>() : 
                map.ForEach(new ImHashMapEntry<K, V>[map.Count()], (e, i, a) => a[i] = e);

        /// <summary>Converts the map to the dictionary</summary>
        public static Dictionary<K, V> ToDictionary<K, V>(this ImHashMap<K, V> map) =>
            map == ImHashMap<K, V>.Empty ? new Dictionary<K, V>(0) :
                map.ForEach(new Dictionary<K, V>(), (e, _, d) => d.Add(e.Key, e.Value));

        /// <summary>Get the key value entry if the hash and key is in the map or the default `null` value otherwise.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            var e = map.GetEntryOrNull(hash);

            if (e is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(key) ? kv : null;

            if (e is HashConflictingEntry<K, V> hc)
                foreach (var x in hc.Conflicts)
                    if (x.Key.Equals(key))
                        return x;

            return null;
        }

        /// <summary>Get the key value entry if the key is in the map or the default `null` value otherwise.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, K key) =>
            GetEntryOrDefault(map, key.GetHashCode(), key);

        /// <summary>Returns <see langword="true"/> if map contains the hash and key, otherwise returns <see langword="false"/></summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool Contains<K, V>(this ImHashMap<K, V> map, int hash, K key) => map.GetEntryOrDefault(hash, key) != null;

        /// <summary>Returns <see langword="true"/> if map contains the key, otherwise returns <see langword="false"/></summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool Contains<K, V>(this ImHashMap<K, V> map, K key) => map.GetEntryOrDefault(key.GetHashCode(), key) != null;

        /// <summary>Returns the entry ASSUMING it is present otherwise its behavior is UNDEFINED.
        /// You can use the method after the Add and Update methods on the same map instance - because the map is immutable it is for sure contains added or updated entry.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMapEntry<K, V> GetSurePresentEntry<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            var e = map.GetEntryOrNull(hash);
            if (e is HashConflictingEntry<K, V> c)
                foreach (var x in c.Conflicts) 
                    if (x.Key.Equals(key))
                        return x;

            return (ImHashMapEntry<K, V>)e; // we don't need the comparison of the key because there is only one entry with the key
        }

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.Equals` for equality, 
        /// returns the default `V` if hash, key are not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            var e = map.GetEntryOrNull(hash);
            if (e is ImHashMapEntry<K, V> kv)
            {
                if (kv.Key.Equals(key))
                    return kv.Value;
            }
            else if (e is HashConflictingEntry<K, V> hc)
            {
                foreach (var x in hc.Conflicts) 
                    if (x.Key.Equals(key))
                        return x.Value;
            }
            return default(V);
        }

        /// <summary>Lookup for the value by key using its hash and checking the key with the `object.Equals` for equality, 
        /// returns the default `V` if hash, key are not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, K key) =>
            map.GetValueOrDefault(key.GetHashCode(), key);

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,
        ///  returns found value or the default value if not found</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V> map, int hash, K key) where K : class
        {
            var e = map.GetEntryOrNull(hash);
            if (e is ImHashMapEntry<K, V> kv)
            {
                if (kv.Key == key)
                    return kv.Value;
            }
            else if (e is HashConflictingEntry<K, V> hc)
            {
                foreach (var x in hc.Conflicts) 
                    if (x.Key == key)
                        return x.Value;
            }
            return default(V);
        }

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.Equals` for equality,
        /// returns the `true` and the found value or the `false` otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V> map, int hash, K key, out V value)
        {
            var e = map.GetEntryOrNull(hash);
            if (e is ImHashMapEntry<K, V> kv)
            {
                if (kv.Key.Equals(key))
                {
                    value = kv.Value;
                    return true;
                }
            }
            else if (e is HashConflictingEntry<K, V> hc)
            {
                foreach (var x in hc.Conflicts) 
                    if (x.Key.Equals(key)) 
                    {
                        value = x.Value;
                        return true;
                    }
            }

            value = default(V);
            return false;
        }

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals`, 
        /// returns the `true` and the found value or the `false` otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V> map, int hash, K key, out V value) where K : class
        {
            var e = map.GetEntryOrNull(hash);
            if (e is ImHashMapEntry<K, V> kv)
            {
                if (kv.Key == key)
                {
                    value = kv.Value;
                    return true;
                }
            }
            else if (e is HashConflictingEntry<K, V> hc)
            {
                foreach (var x in hc.Conflicts) 
                    if (x.Key == key) 
                    {
                        value = x.Value;
                        return true;
                    }
            }

            value = default(V);
            return false;
        }

        /// <summary>Lookup for the value by the key using its hash and checking the key with the `object.Equals` for equality,
        /// returns the `true` and the found value or the `false` otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V> map, K key, out V value) =>
            map.TryFind(key.GetHashCode(), key, out value);

        /// <summary>Adds the entry and returns the new map or if the hash is present then return the found entry or the newEntry if the map is empty, 
        /// so you may check the result like this `if (res is ImMapEntry&lt;V&gt; entry &amp;&amp; entry != newEntry)`</summary>
        public static ImHashMap<K, V> AddOrGetEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry)
        {
            if (map == ImHashMap<K, V>.Empty)
                return newEntry;

            var hash = newEntry.Hash;
            var oldEntryOrMap = map.AddOrGetEntry(hash, newEntry);
            if (oldEntryOrMap is ImHashMap<K, V>.Entry == false)
                return oldEntryOrMap;

            if (oldEntryOrMap is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(newEntry.Key) ? oldEntryOrMap 
                    : map.ReplaceEntry(hash, kv, new HashConflictingEntry<K, V>(hash, kv, newEntry));

            var key = newEntry.Key;
            var hc = (HashConflictingEntry<K, V>)oldEntryOrMap;
            var cs = hc.Conflicts;
            var n = cs.Length;
            var i = n - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            if (i != -1)
                return cs[i];

            var newConflicts = new ImHashMapEntry<K, V>[n + 1];
            Array.Copy(cs, 0, newConflicts, 0, n);
            newConflicts[n] = newEntry;
            return map.ReplaceEntry(hash, hc, new HashConflictingEntry<K, V>(hash, newConflicts));
        }

        /// <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, int hash, K key, V value) 
        {
            var newEntry = new ImHashMapEntry<K, V>(hash, key, value);
            if (map == ImHashMap<K, V>.Empty)
                return newEntry;

            var oldEntryOrMap = map.AddOrGetEntry(hash, newEntry);
            if (oldEntryOrMap is ImHashMap<K, V>.Entry oldEntry)
                return map.ReplaceEntry(hash, oldEntry, oldEntry.Update(newEntry));

            return oldEntryOrMap;
        }

        /// <summary>Adds or updates (no in-place mutation) the map with the new entry, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrUpdateEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry) 
        {
            if (map == ImHashMap<K, V>.Empty)
                return newEntry;

            var hash = newEntry.Hash;
            var oldEntryOrMap = map.AddOrGetEntry(hash, newEntry);
            if (oldEntryOrMap is ImHashMap<K, V>.Entry oldEntry)
                return map.ReplaceEntry(hash, oldEntry, oldEntry.Update(newEntry));

            return oldEntryOrMap;
        }

        /// <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, K key, V value) =>
            map.AddOrUpdate(key.GetHashCode(), key, value);

        /// <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, int hash, K key, V value, Update<K, V> update) 
        {
            var newEntry = new ImHashMapEntry<K, V>(hash, key, value);
            if (map == ImHashMap<K, V>.Empty)
                return newEntry;

            var oldEntryOrMap = map.AddOrGetEntry(hash, newEntry);
            if (oldEntryOrMap is ImHashMap<K, V>.Entry oldEntry)
                return map.ReplaceEntry(hash, oldEntry, UpdateEntry(oldEntry, newEntry, update));

            return oldEntryOrMap;
        }

        /// <summary>Updates the possibly the conflicted entry with the new key and value entry using the provided update function.</summary>
        public static ImHashMap<K, V>.Entry UpdateEntry<K, V>(ImHashMap<K, V>.Entry oldEntry, ImHashMapEntry<K, V> newEntry, Update<K, V> update)
        {
            var key = newEntry.Key;
            if (oldEntry is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(key) ? new ImHashMapEntry<K, V>(newEntry.Hash, key, update(key, kv.Value, newEntry.Value))
                    : (ImHashMap<K, V>.Entry)new HashConflictingEntry<K, V>(oldEntry.Hash, kv, newEntry);

            var cs = ((HashConflictingEntry<K, V>)oldEntry).Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            return new HashConflictingEntry<K, V>(oldEntry.Hash, cs.AppendOrUpdate(newEntry, i));
        }

        /// <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, K key, V value, Update<K, V> update) =>
            map.AddOrUpdate(key.GetHashCode(), key, value, update);

        /// <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, int hash, K key, V value) 
        {
            var entry = map.GetEntryOrNull(hash);
            if (entry == null)
                return map;

            if (entry is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(key) ? map.ReplaceEntry(hash, entry, new ImHashMapEntry<K, V>(hash, key, value)) : map;

            var cs = ((HashConflictingEntry<K, V>)entry).Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            return i == -1 ? map :
                map.ReplaceEntry(hash, entry, new HashConflictingEntry<K, V>(hash, cs.UpdateNonEmpty(new ImHashMapEntry<K, V>(hash, key, value), i)));
        }

        /// <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, K key, V value) =>
            map.Update(key.GetHashCode(), key, value);

        /// <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        public static ImHashMap<K, V> UpdateToDefault<K, V>(this ImHashMap<K, V> map, int hash, K key) 
        {
            var entry = map.GetEntryOrNull(hash);
            if (entry == null)
                return map;

            if (entry is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(key) ? map.ReplaceEntry(hash, entry, new ImHashMapEntry<K, V>(hash, key)) : map;

            var cs = ((HashConflictingEntry<K, V>)entry).Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            return i == -1 ? map :
                map.ReplaceEntry(hash, entry, new HashConflictingEntry<K, V>(hash, cs.UpdateNonEmpty(new ImHashMapEntry<K, V>(hash, key), i)));
        }

        /// <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> UpdateToDefault<K, V>(this ImHashMap<K, V> map, K key) =>
            map.UpdateToDefault(key.GetHashCode(), key);

        /// <summary>Updates the map with the new value and the `update` function if the key is found otherwise returns the same unchanged map.
        /// If `update` returns the same map if the updated result is the same</summary>
        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, int hash, K key, V value, Update<K, V> update)
        {
            var entry = map.GetEntryOrNull(hash);
            if (entry == null)
                return map;

            if (entry is ImHashMapEntry<K, V> kv)
                return !kv.Key.Equals(key) || ReferenceEquals(kv.Value, value = update(key, kv.Value, value)) 
                    ? map 
                    : map.ReplaceEntry(hash, entry, new ImHashMapEntry<K, V>(hash, key, value));

            var cs = ((HashConflictingEntry<K, V>)entry).Conflicts;
            var i = cs.Length - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            if (i == -1 || ReferenceEquals(cs[i].Value, value = update(key, cs[i].Value, value)))
                return map;
            return map.ReplaceEntry(hash, entry, new HashConflictingEntry<K, V>(hash, cs.UpdateNonEmpty(new ImHashMapEntry<K, V>(hash, key, value), i)));
        }

        /// <summary>Updates the map with the new value and the `update` function if the key is found otherwise returns the same unchanged map.
        /// If `update` returns the same map if the updated result is the same</summary>
        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, K key, V value, Update<K, V> update) =>
            map.Update(key.GetHashCode(), key, value, update);

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrKeepEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry) 
        {
            if (map == ImHashMap<K, V>.Empty)
                return newEntry;

            var hash = newEntry.Hash;
            var oldEntryOrMap = map.AddOrGetEntry(hash, newEntry);
            if (oldEntryOrMap is ImHashMap<K, V>.Entry oldEntry)
            {
                var e = KeepOrAddEntry(oldEntry, newEntry);
                return e == oldEntry ? map : map.ReplaceEntry(hash, oldEntry, e);
            }

            return oldEntryOrMap;
        }

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrKeep<K, V>(this ImHashMap<K, V> map, int hash, K key, V value)
        {
            var newEntry = new ImHashMapEntry<K, V>(hash, key, value); // todo: @perf newEntry may not be needed here - consider the pooling of entries here
            if (map == ImHashMap<K, V>.Empty)
                return newEntry;

            var oldEntryOrMap = map.AddOrGetEntry(hash, newEntry);
            if (oldEntryOrMap is ImHashMap<K, V>.Entry oldEntry)
            {
                var e = KeepOrAddEntry(oldEntry, newEntry);
                return e == oldEntry ? map : map.ReplaceEntry(hash, oldEntry, e);
            }

            return oldEntryOrMap;
        }

        private static ImHashMap<K, V>.Entry KeepOrAddEntry<K, V>(ImHashMap<K, V>.Entry oldEntry, ImHashMapEntry<K, V> newEntry)
        {
            if (oldEntry is ImHashMapEntry<K, V> kv)
                return kv.Key.Equals(newEntry.Key) ? oldEntry : (ImHashMap<K, V>.Entry)new HashConflictingEntry<K, V>(oldEntry.Hash, kv, newEntry);

            var hc = (HashConflictingEntry<K, V>)oldEntry;
            var key  = newEntry.Key;
            var cs = hc.Conflicts;
            var n = cs.Length;
            var i = n - 1;
            while (i != -1 && !key.Equals(cs[i].Key)) --i;
            if (i != -1) // return the existing map
                return oldEntry;

            var newConflicts = new ImHashMapEntry<K, V>[n + 1];
            Array.Copy(cs, 0, newConflicts, 0, n);
            newConflicts[n] = newEntry;

            return new HashConflictingEntry<K, V>(oldEntry.Hash, newConflicts);
        }

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> AddOrKeep<K, V>(this ImHashMap<K, V> map, K key, V value) => 
            map.AddOrKeep(key.GetHashCode(), key, value);

        /// <summary>Returns the new map without the specified hash and key (if found) or returns the same map otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> Remove<K, V>(this ImHashMap<K, V> map, int hash, K key)
        {
            var entryToRemove = map.GetEntryOrNull(hash);
            if (entryToRemove is ImHashMapEntry<K, V>)
                return map.RemoveEntry(entryToRemove);

            if (entryToRemove is HashConflictingEntry<K, V> hc)
            {
                var entryToReplace = RemoveEntryToReplaceOrDefault(hc, key);
                return entryToReplace == null ? map : map.ReplaceEntry(hash, entryToRemove, entryToReplace);
            }

            return map;
        }

        private static ImHashMap<K, V>.Entry RemoveEntryToReplaceOrDefault<K, V>(HashConflictingEntry<K, V> hc, K key)
        {
            var cs = hc.Conflicts;
            var n = cs.Length;
            var i = n - 1;
            while (i != -1 && !cs[i].Key.Equals(key)) --i;
            if (i != -1)
            {
                if (n == 2)
                    return i == 0 ? cs[1] : cs[0];
                var newConflicts = new ImHashMapEntry<K, V>[n -= 1]; // the new n is less by one
                if (i > 0) // copy the 1st part
                    Array.Copy(cs, 0, newConflicts, 0, i);
                if (i < n) // copy the 2nd part
                    Array.Copy(cs, i + 1, newConflicts, i, n - i);
                return new HashConflictingEntry<K, V>(hc.Hash, newConflicts);
            }

            return null;
        }

        /// <summary>Returns the new map without the specified hash and key (if found) or returns the same map otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V> Remove<K, V>(this ImHashMap<K, V> map, K key) =>
            map == ImHashMap<K, V>.Empty ? map : map.Remove(key.GetHashCode(), key); // it make sense to have the empty map condition here to prevent the probably costly `GetHashCode()` for the empty map.
    }

    /// <summary>The map methods</summary>
    public static class ImMap
    {
        /// <summary>Creates the entry to help with inference</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMapEntry<V> Entry<V>(int hash, V value) => new ImMapEntry<V>(hash, value);

        private sealed class GoRightInBranch3<V> 
        {
            public ImMap<V>.Branch3 Br3;
        }

        /// <summary>Enumerates all the map entries in the hash order.
        /// `parents` parameter allows to reuse the stack memory used for traversal between multiple enumerates.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent `Enumerate` calls</summary>
        public static IEnumerable<ImMapEntry<V>> Enumerate<V>(this ImMap<V> map, MapParentStack parents = null)
        {
            if (map == ImMap<V>.Empty)
                yield break;
            if (map is ImMapEntry<V> v)
            {
                yield return v;
                yield break;
            }

            var count = 0;
            GoRightInBranch3<V> br3Wrapper = null;
            while (true)
            {
                if (map is ImMap<V>.Branch2 b2)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Push(map, count++);
                    map = b2.Left;
                    continue;
                }

                if (map is ImMap<V>.Branch3 b3)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Push(map, count++);
                    map = b3.Left;
                    continue;
                }

                if (map is ImMapEntry<V> l1)
                    yield return l1;
                else if (map is ImMap<V>.Leaf2 l2)
                {
                    yield return l2.Entry0;
                    yield return l2.Entry1;
                }
                else if (map is ImMap<V>.Leaf2Plus1 l21)
                {
                    var p  = l21.Plus;
                    var ph = p.Hash;
                    var l  = l21.L;
                    ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = p; p = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    yield return e0;
                    yield return e1;
                    yield return p ;
                }
                else if (map is ImMap<V>.Leaf2Plus1Plus1 l211)
                {
                    var p  = l211.Plus;
                    var pp = l211.L.Plus;
                    var ph = pp.Hash;
                    var l  = l211.L.L;
                    ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = pp; pp = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    ph = p.Hash;
                    if (ph < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (ph < e1.Hash)
                        {
                            swap = e1; e1 = pp; pp = swap;
                            if (ph < e0.Hash)
                            {
                                swap = e0; e0 = e1; e1 = swap;
                            }
                        }
                    }

                    yield return e0;
                    yield return e1;
                    yield return pp;
                    yield return p ;
                }
                else if (map is ImMap<V>.Leaf5 l5)
                {
                    yield return l5.Entry0;
                    yield return l5.Entry1;
                    yield return l5.Entry2;
                    yield return l5.Entry3;
                    yield return l5.Entry4;
                }
                else if (map is ImMap<V>.Leaf5Plus1 l51)
                {
                    var p  = l51.Plus;
                    var ph = p.Hash;
                    var l  = l51.L;
                    ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = p; p = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    yield return e0;
                    yield return e1;
                    yield return e2;
                    yield return e3;
                    yield return e4;
                    yield return p ;
                }
                else if (map is ImMap<V>.Leaf5Plus1Plus1 l511)
                {
                    var l = l511.L.L;
                    ImMapEntry<V> 
                        e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus, swap = null;
                    var h = pp.Hash;
                    if (h < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (h < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (h < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (h < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (h < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    h = p.Hash;
                    if (h < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (h < e4.Hash)
                        {
                            swap = e4; e4 = pp; pp = swap;
                            if (h < e3.Hash)
                            {
                                swap = e3; e3 = e4; e4 = swap;
                                if (h < e2.Hash)
                                {
                                    swap = e2; e2 = e3; e3 = swap;
                                    if (h < e1.Hash)
                                    {
                                        swap = e1; e1 = e2; e2 = swap;
                                        if (h < e0.Hash)
                                        {
                                            swap = e0; e0 = e1; e1 = swap;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    yield return e0;
                    yield return e1;
                    yield return e2;
                    yield return e3;
                    yield return e4;
                    yield return pp;
                    yield return p ;
                }

                if (count == 0)
                    break; // we yield the leaf and there is nothing in stack - we are DONE!

                var b = parents.Get(--count); // otherwise get the parent
                if (b is ImMap<V>.Branch2 pb2)
                {
                    yield return pb2.MidEntry;
                    map = pb2.Right;
                }
                else if (b is ImMap<V>.Branch3 pb3)
                {
                    yield return pb3.Entry0;
                    if (br3Wrapper == null)
                        br3Wrapper = new GoRightInBranch3<V>();
                    br3Wrapper.Br3 = pb3;
                    parents.Set(count++, br3Wrapper);
                    br3Wrapper = null; // set to null to mark that the wrapper is in use and longer shared
                    map = pb3.Middle;
                }
                else 
                {
                    br3Wrapper = (GoRightInBranch3<V>)b;
                    yield return br3Wrapper.Br3.Entry1;
                    map = br3Wrapper.Br3.Right;
                }
            }
        }

        /// <summary>Depth-first in-order of hash traversal as described in http://en.wikipedia.org/wiki/Tree_traversal.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static S ForEach<V, S>(this ImMap<V> map, S state, Action<ImMapEntry<V>, int, S> handler, MapParentStack parents = null)
        {
            if (map == ImMap<V>.Empty)
                return state;
            if (map is ImMapEntry<V> v)
            {
                handler(v, 0, state);
                return state;
            }

            GoRightInBranch3<V> br3Wrapper = null;

            int count = 0, i = 0;
            while (true)
            {
                if (map is ImMap<V>.Branch2 b2)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Push(map, count++);
                    map = b2.Left;
                    continue;
                }
                if (map is ImMap<V>.Branch3 b3)
                {
                    if (parents == null)
                        parents = new MapParentStack();
                    parents.Push(map, count++);
                    map = b3.Left;
                    continue;
                }
                
                if (map is ImMapEntry<V> l1)
                    handler(l1, i++, state);
                else if (map is ImMap<V>.Leaf2 l2)
                {
                    handler(l2.Entry0, i++, state);
                    handler(l2.Entry1, i++, state);
                }
                else if (map is ImMap<V>.Leaf2Plus1 l21)
                {
                    var p  = l21.Plus;
                    var ph = p.Hash;
                    var l  = l21.L;
                    ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = p; p = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    handler(e0, i++, state);
                    handler(e1, i++, state);
                    handler(p,  i++, state);
                }
                else if (map is ImMap<V>.Leaf2Plus1Plus1 l211)
                {
                    var p  = l211.Plus;
                    var pp = l211.L.Plus;
                    var ph = pp.Hash;
                    var l  = l211.L.L;
                    ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, swap = null;
                    if (ph < e1.Hash)
                    {
                        swap = e1; e1 = pp; pp = swap;
                        if (ph < e0.Hash)
                        {
                            swap = e0; e0 = e1; e1 = swap;
                        }
                    }

                    ph = p.Hash;
                    if (ph < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (ph < e1.Hash)
                        {
                            swap = e1; e1 = pp; pp = swap;
                            if (ph < e0.Hash)
                            {
                                swap = e0; e0 = e1; e1 = swap;
                            }
                        }
                    }

                    handler(e0, i++, state);
                    handler(e1, i++, state);
                    handler(pp, i++, state);
                    handler(p,  i++, state);
                }
                else if (map is ImMap<V>.Leaf5 l5)
                {
                    handler(l5.Entry0, i++, state);
                    handler(l5.Entry1, i++, state);
                    handler(l5.Entry2, i++, state);
                    handler(l5.Entry3, i++, state);
                    handler(l5.Entry4, i++, state);
                }
                else if (map is ImMap<V>.Leaf5Plus1 l51)
                {
                    var p  = l51.Plus;
                    var ph = p.Hash;
                    var l  = l51.L;
                    ImMapEntry<V> e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, swap = null;
                    if (ph < e4.Hash)
                    {
                        swap = e4; e4 = p; p = swap;
                        if (ph < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (ph < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (ph < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (ph < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    handler(e0, i++, state);
                    handler(e1, i++, state);
                    handler(e2, i++, state);
                    handler(e3, i++, state);
                    handler(e4, i++, state);
                    handler(p , i++, state);
                }
                else if (map is ImMap<V>.Leaf5Plus1Plus1 l511)
                {
                    var l = l511.L.L;
                    ImMapEntry<V> 
                        e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus, swap = null;
                    var h = pp.Hash;
                    if (h < e4.Hash)
                    {
                        swap = e4; e4 = pp; pp = swap;
                        if (h < e3.Hash)
                        {
                            swap = e3; e3 = e4; e4 = swap;
                            if (h < e2.Hash)
                            {
                                swap = e2; e2 = e3; e3 = swap;
                                if (h < e1.Hash)
                                {
                                    swap = e1; e1 = e2; e2 = swap;
                                    if (h < e0.Hash)
                                    {
                                        swap = e0; e0 = e1; e1 = swap;
                                    }
                                }
                            }
                        }
                    }

                    h = p.Hash;
                    if (h < pp.Hash)
                    {
                        swap = pp; pp = p; p = swap;
                        if (h < e4.Hash)
                        {
                            swap = e4; e4 = pp; pp = swap;
                            if (h < e3.Hash)
                            {
                                swap = e3; e3 = e4; e4 = swap;
                                if (h < e2.Hash)
                                {
                                    swap = e2; e2 = e3; e3 = swap;
                                    if (h < e1.Hash)
                                    {
                                        swap = e1; e1 = e2; e2 = swap;
                                        if (h < e0.Hash)
                                        {
                                            swap = e0; e0 = e1; e1 = swap;
                                        }
                                    }
                                }
                            }
                        }
                    }

                    handler(e0, i++, state);
                    handler(e1, i++, state);
                    handler(e2, i++, state);
                    handler(e3, i++, state);
                    handler(e4, i++, state);
                    handler(pp, i++, state);
                    handler(p , i++, state);
                }

                if (count == 0)
                    break; // we yield the leaf and there is nothing in stack - we are DONE!

                var b = parents.Get(--count); // otherwise get the parent
                if (b is ImMap<V>.Branch2 pb2)
                {
                    handler(pb2.MidEntry, i++, state);
                    map = pb2.Right;
                }
                else if (b is ImMap<V>.Branch3 pb3)
                {
                    handler(pb3.Entry0, i++, state);
                    if (br3Wrapper == null)
                        br3Wrapper = new GoRightInBranch3<V>();
                    br3Wrapper.Br3 = pb3;
                    parents.Set(count++, br3Wrapper);
                    br3Wrapper = null; // set to null to mark that the wrapper is in use and longer shared
                    map = pb3.Middle;
                }
                else 
                {
                    br3Wrapper = (GoRightInBranch3<V>)b;
                    handler(br3Wrapper.Br3.Entry1, i++, state);
                    map = br3Wrapper.Br3.Right;
                }
            }

            return state;
        }

        /// <summary>Do something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static void ForEach<V>(this ImMap<V> map, Action<ImMapEntry<V>, int> handler, MapParentStack parents = null) =>
            map.ForEach(handler, (e, i, r) => r(e, i), parents);

        /// <summary>Collect something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static S Fold<V, S>(this ImMap<V> map, S state, Func<ImMapEntry<V>, int, S, S> handler, MapParentStack parents = null) =>
            map.ForEach(St.Rent(state, handler), (e, i, s) => s.a = s.b(e, i, s.a), parents).ResetButGetA();

        /// <summary>Converts the map to an array with the minimum allocations</summary>
        public static S[] ToArray<V, S>(this ImMap<V> map, Func<ImMapEntry<V>, S> selector) =>
            map == ImMap<V>.Empty ? ArrayTools.Empty<S>() :
                map.ForEach(St.Rent(new S[map.Count()], selector), (e, i, s) => s.a[i] = s.b(e)).ResetButGetA();

        /// <summary>Converts the map to an array with the minimum allocations</summary>
        public static ImMapEntry<V>[] ToArray<K, V>(this ImMap<V> map) =>
            map == ImMap<V>.Empty ? ArrayTools.Empty<ImMapEntry<V>>() : map.ForEach(new ImMapEntry<V>[map.Count()], (e, i, a) => a[i] = e);

        /// <summary>Converts the map to the dictionary</summary>
        public static Dictionary<int, V> ToDictionary<V>(this ImMap<V> map) =>
            map == ImMap<V>.Empty ? new Dictionary<int, V>(0) :
                map.ForEach(new Dictionary<int, V>(), (e, _, d) => d.Add(e.Hash, e.Value));

        /// <summary>Returns the entry ASSUMING it is present otherwise its behavior is UNDEFINED.
        /// You can use the method after the Add and Update methods on the same map instance - because the map is immutable it is for sure contains added or updated entry.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMapEntry<V> GetSurePresentEntry<V>(this ImMap<V> map, int hash) =>
            map.GetEntryOrNull(hash);

        /// <summary>Lookup for the entry by hash, returns the found entry or `null`.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMapEntry<V> GetEntryOrDefault<V>(this ImMap<V> map, int hash) =>
            map.GetEntryOrNull(hash);

        /// <summary>Lookup for the value by hash, returns the default `V` if hash is not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImMap<V> map, int hash) =>
            map.GetEntryOrNull(hash) is ImMapEntry<V> kv ? kv.Value : default(V);

        /// <summary>Lookup for the value by its hash, returns the `true` and the found value or the `false` otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImMap<V> map, int hash, out V value)
        {
            if (map is ImMapEntry<V> v && v.Hash == hash)
            {
                value = v.Value;
                return true;
            }

            var e = map.GetEntryOrNull(hash);
            if (e != null)
            {
                value = e.Value;
                return true;
            }

            value = default(V);
            return false;
        }

        /// <summary>Adds the entry and returns the new map or if the hash is present then return the found entry or the newEntry if the map is empty, 
        /// so you may check the result like this `if (res is ImMapEntry&lt;V&gt; entry &amp;&amp; entry != newEntry)`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V> AddOrGetEntry<V>(this ImMap<V> map, ImMapEntry<V> newEntry) =>
            map == ImMap<V>.Empty ? newEntry : map.AddOrGetEntry(newEntry.Hash, newEntry);

        /// <summary>Adds or updates (no in-place mutation) the map with the new entry, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V> AddOrUpdateEntry<V>(this ImMap<V> map, ImMapEntry<V> newEntry)
        {
            if (map == ImMap<V>.Empty)
                return newEntry;

            var hash = newEntry.Hash;
            var oldEntryOrMap = map.AddOrGetEntry(hash, newEntry);
            if (oldEntryOrMap is ImMapEntry<V> oldEntry)
                return map.ReplaceEntry(hash, oldEntry, newEntry); // todo: @perf here we have a chance to compare the old and the new value and prevent the updated if the values are equal

            return oldEntryOrMap;
        }

        /// <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V> AddOrUpdate<V>(this ImMap<V> map, int hash, V value)
        {
            var newEntry = new ImMapEntry<V>(hash, value);
            if (map == ImMap<V>.Empty)
                return newEntry;

            var oldEntryOrMap = map.AddOrGetEntry(hash, newEntry);
            if (oldEntryOrMap is ImMapEntry<V> oldEntry)
                return map.ReplaceEntry(hash, oldEntry, newEntry); // todo: @perf here we have a chance to compare the old and the new value and prevent the updated if the values are equal

            return oldEntryOrMap;
        }

        /// <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V> AddOrUpdate<V>(this ImMap<V> map, int hash, V value, Update<int, V> update)
        {
            var newEntry = new ImMapEntry<V>(hash, value);
            if (map == ImMap<V>.Empty)
                return newEntry;

            var oldEntryOrMap = map.AddOrGetEntry(hash, newEntry);
            if (oldEntryOrMap is ImMapEntry<V> oldEntry)
                return map.ReplaceEntry(hash, oldEntry, new ImMapEntry<V>(hash, update(hash, oldEntry.Value, value))); // todo: @perf here we have a chance to compare the old and the new value and prevent the updated if the values are equal

            return oldEntryOrMap;
        }

        /// <summary>Updates the map with the new value if the hash is found otherwise returns the same unchanged map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V> Update<V>(this ImMap<V> map, int hash, V value) 
        {
            var entry = map.GetEntryOrNull(hash);
            return entry == null ? map : map.ReplaceEntry(hash, entry, new ImMapEntry<V>(hash, value));
        }

        /// <summary>Updates the map with the default value if the hash is found otherwise returns the same unchanged map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V> UpdateToDefault<V>(this ImMap<V> map, int hash)
        {
            var entry = map.GetEntryOrNull(hash);
            return entry == null ? map : map.ReplaceEntry(hash, entry, new ImMapEntry<V>(hash));
        }

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V> AddOrKeepEntry<V>(this ImMap<V> map, ImMapEntry<V> newEntry) 
        {
            if (map == ImMap<V>.Empty)
                return newEntry;
            var oldEntryOrMap = map.AddOrGetEntry(newEntry.Hash, newEntry);
            return oldEntryOrMap is ImMapEntry<V> ? map : oldEntryOrMap;
        }

        /// <summary>Produces the new map with the new entry or keeps the existing map if the entry with the hash is already present</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V> AddOrKeep<V>(this ImMap<V> map, int hash, V value) 
        {
            var newEntry = new ImMapEntry<V>(hash, value); // todo: @perf newEntry may not be needed here - consider the pooling of entries here
            if (map == ImMap<V>.Empty)
                return newEntry;
            var oldEntryOrMap = map.AddOrGetEntry(hash, newEntry);
            return oldEntryOrMap is ImMapEntry<V> ? map : oldEntryOrMap;
        }

        /// <summary>Returns the new map without the specified hash (if found) or returns the same map otherwise</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V> Remove<V>(this ImMap<V> map, int hash)
        {
            var entryToRemove = map.GetEntryOrNull(hash);
            return entryToRemove == null ? map : map.RemoveEntry(entryToRemove);
        }
    }

    /// <summary>
    /// The fixed array of maps (partitions) where the key first (lower) bits are used to locate the partion to lookup into.
    /// Note: The partition array is NOT immutable and operates by swapping the updated partition with the new one.
    /// The number of partitions may be specified by user or you can use the default number 16.
    /// The default number 16 was selected to be not so big to pay for the few items and not so small to diminish the use of partitions.
    /// </summary>
    public static class PartitionedHashMap
    {
        /// <summary>The default number of partitions</summary>
        public const int PARTITION_COUNT_POWER_OF_TWO = 16;

        /// <summary>The default mask to partition the key</summary>
        public const int PARTITION_HASH_MASK = PARTITION_COUNT_POWER_OF_TWO - 1;

        /// <summary>Creates the new collection with the empty partions</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImHashMap<K, V>[] CreateEmpty<K, V>(int partionCountOfPowerOfTwo = PARTITION_COUNT_POWER_OF_TWO)
        {
            var parts = new ImHashMap<K, V>[partionCountOfPowerOfTwo];
            for (var i = 0; i < parts.Length; ++i)
                parts[i] = ImHashMap<K, V>.Empty;
            return parts;
        }

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.Equals` for equality, 
        /// returns the default `V` if hash, key are not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, int partHashMask = PARTITION_HASH_MASK)
        {
            var p = parts[hash & partHashMask];
            return p != null ? p.GetValueOrDefault(hash, key) : default(V);
        }

        /// <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,
        ///  returns found value or the default value if not found</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, int partHashMask = PARTITION_HASH_MASK) where K : class
        {
            var p = parts[hash & partHashMask];
            return p != null ? p.GetValueOrDefaultByReferenceEquals(hash, key) : default(V);
        }

        /// <summary>Lookup for the value by the key using its hash and checking the key with the `object.Equals` for equality, 
        /// returns the default `V` if hash, key are not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V>[] parts, K key, int partHashMask = PARTITION_HASH_MASK) =>
            parts.GetValueOrDefault(key.GetHashCode(), key, partHashMask);

        /// <summary>Lookup for the value by the key using the hash code and checking the key with the `object.Equals` for equality,
        /// returns the `true` and the found value or the `false`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, out V value, int partHashMask = PARTITION_HASH_MASK)
        {
            var p = parts[hash & partHashMask];
            if (p != null) 
                return p.TryFind(hash, key, out value);
            value = default(V);
            return false;
        }

        /// <summary>Lookup for the value by the key using its hash code and checking the key with the `object.Equals` for equality,
        /// returns the `true` and the found value or the `false`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<K, V>(this ImHashMap<K, V>[] parts, K key, out V value, int partHashMask = PARTITION_HASH_MASK) =>
            parts.TryFind(key.GetHashCode(), key, out value, partHashMask);

        /// <summary>Lookup for the value by the key using the hash code and checking the key with the `object.ReferenceEquals` for equality,
        /// returns the `true` and the found value or the `false`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, out V value, 
            int partHashMask = PARTITION_HASH_MASK) where K : class
        {
            var p = parts[hash & partHashMask];
            if (p != null) 
                return p.TryFindByReferenceEquals(hash, key, out value);
            value = default(V);
            return false;
        }

        /// <summary>Lookup for the value by the key using its hash and checking the key with the `object.ReferenceEquals` for equality, 
        /// returns the default `V` if hash, key are not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, K key, int partHashMask = PARTITION_HASH_MASK) where K : class => 
            parts.GetValueOrDefaultByReferenceEquals(key.GetHashCode(), key, partHashMask);

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, int partHashMask = PARTITION_HASH_MASK)
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, key, value), p) != p)
                RefAddOrUpdatePart(ref part, hash, key, value);
        }

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        [MethodImpl((MethodImplOptions) 256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, K key, V value, int partHashMask = PARTITION_HASH_MASK) =>
            parts.AddOrUpdate(key.GetHashCode(), key, value, partHashMask);

        private static void RefAddOrUpdatePart<K, V>(ref ImHashMap<K, V> part, int hash, K key, V value) =>
            Ref.Swap(ref part, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        [MethodImpl((MethodImplOptions) 256)]
        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, Update<K, V> update,
            int partHashMask = PARTITION_HASH_MASK)
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, key, value, update), p) != p)
                Ref.Swap(ref part, new ImHashMapEntry<K, V>(hash, key, value), update, (x, e, u) => x.AddOrUpdate(e.Hash, e.Key, e.Value, u));
        }

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrKeep<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, int partHashMask = PARTITION_HASH_MASK)
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.AddOrKeep(hash, key, value), p) != p)
                RefAddOrKeepPart(ref part, hash, key, value);
        }

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion</summary>
        [MethodImpl((MethodImplOptions) 256)]
        public static void AddOrKeep<K, V>(this ImHashMap<K, V>[] parts, K key, V value, 
            int partHashMask = PARTITION_HASH_MASK) =>
            parts.AddOrKeep(key.GetHashCode(), key, value, partHashMask);

        private static void RefAddOrKeepPart<K, V>(ref ImHashMap<K, V> part, int hash, K key, V value) =>
            Ref.Swap(ref part, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));

        /// <summary>Do something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static IEnumerable<ImHashMapEntry<K, V>> Enumerate<K, V>(this ImHashMap<K, V>[] parts, MapParentStack parents = null)
        {
            if (parents == null)
                parents = new MapParentStack();
            foreach (var map in parts) 
            {
                if (map == ImHashMap<K, V>.Empty)
                    continue;
                foreach (var entry in map.Enumerate(parents))
                    yield return entry;
            }
        }

        /// <summary>Do something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static S ForEach<K, V, S>(this ImHashMap<K, V>[] parts, S state, Action<ImHashMapEntry<K, V>, int, S> handler, 
            MapParentStack parents = null)
        {
            if (parents == null)
                parents = new MapParentStack();
            foreach (var map in parts) 
            {
                if (map == ImHashMap<K, V>.Empty)
                    continue;
                state = map.ForEach(state, handler, parents);
            }
            return state;
        }
    }

    /// <summary>
    /// The fixed array of maps (partitions) where the key first (lower) bits are used to locate the partion to lookup into.
    /// Note: The partition array is NOT immutable and operates by swapping the updated partition with the new one.
    /// The number of partitions may be specified by user or you can use the default number 16.
    /// The default number 16 was selected to be not so big to pay for the few items and not so small to diminish the use of partitions.
    /// </summary>
    public static class PartitionedMap
    {
        /// <summary>The default number of partions</summary>
        public const int PARTITION_COUNT_POWER_OF_TWO = 16;

        /// <summary>The default mask to partition the key</summary>
        public const int PARTITION_HASH_MASK = PARTITION_COUNT_POWER_OF_TWO - 1;

        /// <summary>Creates the new collection with the empty partions</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static ImMap<V>[] CreateEmpty<V>(int partionCountOfPowerOfTwo = PARTITION_COUNT_POWER_OF_TWO)
        {
            var parts = new ImMap<V>[partionCountOfPowerOfTwo];
            for (var i = 0; i < parts.Length; ++i)
                parts[i] = ImMap<V>.Empty;
            return parts;
        }

        /// <summary>Lookup for the value by the key using its hash, returns the default `V` if hash is not found.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static V GetValueOrDefault<V>(this ImMap<V>[] parts, int hash, int partHashMask = PARTITION_HASH_MASK)
        {
            var p = parts[hash & partHashMask];
            return p != null && p.GetEntryOrNull(hash) is ImMapEntry<V> kv ? kv.Value : default(V);
        }

        /// <summary>Lookup for the value by the key using the hash, returns the `true` and the found value or the `false`</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static bool TryFind<V>(this ImMap<V>[] parts, int hash, out V value, int partHashMask = PARTITION_HASH_MASK)
        {
            var p = parts[hash & partHashMask];
            if (p != null) 
                return p.TryFind(hash, out value);
            value = default(V);
            return false;
        }

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        [MethodImpl((MethodImplOptions) 256)]
        public static void AddOrUpdate<V>(this ImMap<V>[] parts, int hash, V value, int partHashMask = PARTITION_HASH_MASK) 
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, value), p) != p)
                RefAddOrUpdatePart(ref part, hash, value);
        }

        private static void RefAddOrUpdatePart<V>(ref ImMap<V> part, int hash, V value) =>
            Ref.Swap(ref part, hash, value, (x, h, v) => x.AddOrUpdate(h, v));

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion</summary>
        [MethodImpl((MethodImplOptions) 256)]
        public static void AddOrUpdate<V>(this ImMap<V>[] parts, int hash, V value, Update<int, V> update, int partHashMask = PARTITION_HASH_MASK)
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, value, update), p) != p)
                Ref.Swap(ref part, hash, value, update, (x, h, k, u) => x.AddOrUpdate(h, k, u));
        }

        /// <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void AddOrKeep<V>(this ImMap<V>[] parts, int hash, V value, int partHashMask = PARTITION_HASH_MASK)
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.AddOrKeep(hash, value), p) != p)
                RefAddOrKeepPart(ref part, hash, value);
        }

        private static void RefAddOrKeepPart<V>(ref ImMap<V> part, int hash, V value) =>
            Ref.Swap(ref part, hash, value, (x, h, v) => x.AddOrUpdate(h, v));

        /// <summary>Updates the map with the new value if the hash is found otherwise returns the same unchanged map.</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static void Update<V>(this ImMap<V>[] parts, int hash, V value, int partHashMask = PARTITION_HASH_MASK) 
        {
            ref var part = ref parts[hash & partHashMask];
            var p = part;
            if (Interlocked.CompareExchange(ref part, p.Update(hash, value), p) != p)
                RefUpdatePart(ref part, hash, value);
        }

        private static void RefUpdatePart<V>(ref ImMap<V> part, int hash, V value) =>
            Ref.Swap(ref part, hash, value, (x, h, v) => x.Update(h, v));

        /// <summary>Do something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        [MethodImpl((MethodImplOptions)256)]
        public static IEnumerable<ImMapEntry<V>> Enumerate<V>(this ImMap<V>[] parts, MapParentStack parents = null)
        {
            if (parents == null)
                parents = new MapParentStack();
            foreach (var map in parts) 
            {
                if (map == ImMap<V>.Empty)
                    continue;
                foreach (var entry in map.Enumerate(parents))
                    yield return entry;
            }
        }

        /// <summary>Do something for each entry.
        /// The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.
        /// So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls</summary>
        public static S ForEach<V, S>(this ImMap<V>[] parts, S state, Action<ImMapEntry<V>, int, S> handler, MapParentStack parents = null)
        {
            if (parents == null)
                parents = new MapParentStack();
            foreach (var map in parts) 
            {
                if (map == ImMap<V>.Empty)
                    continue;
                state = map.ForEach(state, handler, parents);
            }
            return state;
        }
    }
}
